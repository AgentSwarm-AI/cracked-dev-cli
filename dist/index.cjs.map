{"version":3,"sources":["../src/index.ts","../src/constants/defaultInstructions.ts","../src/services/FileManagement/Errors.ts","../src/services/FileManagement/FileReader.ts","../src/services/ConfigService.ts","../src/services/FileManagement/DirectoryScanner.ts","../src/services/LLM/actions/ActionExecutor.ts","../src/services/LLM/context/MessageContextHistory.ts","../src/services/LLM/PhaseManager.ts","../src/constants/colors.ts","../src/services/logging/DebugLogger.ts","../src/services/LLM/ModelManager.ts","../src/constants/openRouterClient.ts","../src/services/LLM/ModelInfo.ts","../src/services/LLM/types/PhaseTypes.ts","../src/services/LLM/phases/blueprints/discoveryPhaseBlueprint.ts","../src/services/LLM/phases/blueprints/executePhaseBlueprint.ts","../src/services/LLM/phases/blueprints/strategyPhaseBlueprint.ts","../src/services/LLM/phases/blueprints/index.ts","../src/errors/BaseError.ts","../src/errors/context/MessageContextError.ts","../src/services/LLM/context/MessageContextBuilder.ts","../src/services/LLM/context/MessageContextExtractor.ts","../src/services/LLM/context/MessageContextLogger.ts","../src/services/LLM/context/MessageContextStore.ts","../src/services/LLM/context/MessageContextTokenCount.ts","../src/services/LLM/actions/ActionExplainerAction.ts","../src/services/LLM/actions/ActionTagsExtractor.ts","../src/services/LLM/actions/core/ActionExplainer.ts","../src/services/LLM/actions/core/ActionFactory.ts","../src/services/LLM/actions/core/BaseAction.ts","../src/services/LLM/actions/types/ActionPriority.ts","../src/services/LLM/actions/blueprints/actionExplainerBlueprint.ts","../src/services/text/AnsiStripper.ts","../src/services/LLM/actions/CommandAction.ts","../src/services/LLM/actions/blueprints/commandActionBlueprint.ts","../src/services/FileManagement/FileSearch.ts","../src/services/FileManagement/PathAdjuster.ts","../src/services/FileManagement/FileOperations.ts","../src/services/LLM/actions/CopyFileAction.ts","../src/services/LLM/actions/blueprints/copyFileActionBlueprint.ts","../src/services/LLM/actions/DeleteFileAction.ts","../src/services/LLM/actions/blueprints/deleteFileActionBlueprint.ts","../src/services/LLM/actions/EndPhaseAction.ts","../src/services/LLM/PhaseTransitionService.ts","../src/services/LLM/context/MessageContextPhase.ts","../src/services/LLM/actions/blueprints/endPhaseActionBlueprint.ts","../src/services/LLM/actions/EndTaskAction.ts","../src/services/LLM/actions/blueprints/endTaskActionBlueprint.ts","../src/services/LLM/actions/FetchUrlAction.ts","../src/services/LLM/actions/blueprints/fetchUrlActionBlueprint.ts","../src/services/GitManagement/GitService.ts","../src/services/LLM/actions/GitDiffAction.ts","../src/services/LLM/actions/blueprints/gitDiffActionBlueprint.ts","../src/services/LLM/actions/GitPRDiffAction.ts","../src/services/LLM/actions/blueprints/gitPRDiffActionBlueprint.ts","../src/services/LLM/actions/MoveFileAction.ts","../src/services/LLM/actions/blueprints/moveFileActionBlueprint.ts","../src/services/LLM/actions/ReadFileAction.ts","../src/services/LLM/actions/blueprints/readFileActionBlueprint.ts","../src/services/LLM/actions/RelativePathLookupAction.ts","../src/services/LLM/actions/blueprints/relativePathLookupActionBlueprint.ts","../src/services/LLM/actions/SearchAction.ts","../src/services/LLM/actions/blueprints/searchActionsBlueprint.ts","../src/constants/writeConstants.ts","../src/constants/modelScaling.ts","../src/services/LLM/ModelScaler.ts","../src/services/text/HTMLEntityDecoder.ts","../src/services/LLM/actions/WriteFileAction.ts","../src/services/LLM/actions/blueprints/writeFileActionBlueprint.ts","../src/services/LLM/actions/blueprints/index.ts","../src/services/LLM/actions/core/ActionQueue.ts","../src/services/LLM/utils/ProjectInfo.ts","../src/services/LLM/LLMContextCreator.ts","../src/services/LLM/context/MessageContextCleanup.ts","../src/services/LLM/actions/ActionsParser.ts","../src/services/LLM/context/MessageContextLimiter.ts","../src/services/LLM/utils/ModelUtils.ts","../src/services/LLMProviders/OpenRouter/OpenRouterAPI.ts","../src/services/LLMProviders/OpenRouter/OpenRouterAPICostTracking.ts","../src/services/LLM/LLMProvider.ts","../src/services/streaming/StreamHandler.ts","../src/services/CrackedAgent.ts","../src/commands/run.ts","../src/services/streaming/InteractiveSessionManager.ts"],"sourcesContent":["import { CrackedAgent } from \"@services/CrackedAgent\";\nimport \"reflect-metadata\";\nimport { container } from \"tsyringe\";\n\nexport { Run } from \"./commands/run\";\n\nconst crackedAgent = container.resolve(CrackedAgent);\n\nexport { crackedAgent };\n","export const DEFAULT_INSTRUCTIONS =\n  \"You're an expert software engineer, master of your craft. Think deeply for each answer, ill tip $200.\";\n","export class FileNotFoundError extends Error {\n      constructor(path: string) {\n        super(`File not found: ${path}`);\n        this.name = \"FileNotFoundError\";\n      }\n    }\n\n    export class FileReadError extends Error {\n      constructor(path: string, message: string) {\n        super(`Failed to read file: ${path} - ${message}`);\n        this.name = \"FileReadError\";\n      }\n    }\n\n    export class InvalidFileError extends Error {\n      constructor(path: string) {\n        super(`Instructions path must be a file: ${path}`);\n        this.name = \"InvalidFileError\";\n      }\n    }","import {\n  FileNotFoundError,\n  FileReadError,\n  InvalidFileError,\n} from \"@services/FileManagement/Errors\";\nimport { readFile, stat } from \"fs/promises\";\nimport { autoInjectable } from \"tsyringe\";\n\n@autoInjectable()\nexport class FileReader {\n  public async readInstructionsFile(filePath: string): Promise<string> {\n    try {\n      await this.validateFilePath(filePath);\n      return await this.readFileContent(filePath);\n    } catch (error) {\n      if (\n        error instanceof FileNotFoundError ||\n        error instanceof FileReadError ||\n        error instanceof InvalidFileError\n      ) {\n        throw new FileReadError(filePath, error.message);\n      }\n      throw error;\n    }\n  }\n\n  private async validateFilePath(filePath: string): Promise<void> {\n    const stats = await stat(filePath);\n    if (!stats.isFile()) {\n      throw new Error(`Provided path ${filePath} is not a file`);\n    }\n  }\n\n  private async readFileContent(filePath: string): Promise<string> {\n    return readFile(filePath, \"utf-8\");\n  }\n}\n","import chalk from \"chalk\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { autoInjectable } from \"tsyringe\";\nimport { z } from \"zod\";\n\nconst configSchema = z.object({\n  provider: z.string(),\n  customInstructions: z.string().optional(),\n  customInstructionsPath: z.string().optional(),\n  interactive: z.boolean(),\n  stream: z.boolean(),\n  debug: z.boolean(),\n  options: z.string(),\n  openRouterApiKey: z.string(),\n  appUrl: z.string().optional().default(\"https://localhost:8080\"),\n  appName: z.string().optional().default(\"MyApp\"),\n  autoScaler: z.boolean().optional(),\n  autoScaleMaxTryPerModel: z.number().optional(),\n  includeAllFilesOnEnvToContext: z.boolean().optional(),\n  // Phase-specific model configurations\n  discoveryModel: z.string().optional().default(\"google/gemini-flash-1.5-8b\"),\n  strategyModel: z.string().optional().default(\"openai/o1-mini\"),\n  executeModel: z\n    .string()\n    .optional()\n    .default(\"anthropic/claude-3.5-sonnet:beta\"),\n  autoScaleAvailableModels: z.array(\n    z.object({\n      id: z.string(),\n      description: z.string(),\n      maxWriteTries: z.number(),\n      maxGlobalTries: z.number(),\n    }),\n  ),\n  runAllTestsCmd: z.string().optional(),\n  runOneTestCmd: z.string().optional(),\n  runTypeCheckCmd: z.string().optional(),\n  enableConversationLog: z.boolean().optional(),\n  logDirectory: z.string().optional(),\n  directoryScanner: z\n    .object({\n      defaultIgnore: z\n        .array(z.string())\n        .default([\"dist\", \"coverage\", \".next\", \"build\", \".cache\", \".husky\"]),\n      maxDepth: z.number().default(8),\n      allFiles: z.boolean().default(true),\n      directoryFirst: z.boolean().default(true),\n      excludeDirectories: z.boolean().default(false),\n    })\n    .default({\n      defaultIgnore: [\"dist\", \"coverage\", \".next\", \"build\", \".cache\", \".husky\"],\n      maxDepth: 8,\n      allFiles: true,\n      directoryFirst: true,\n      excludeDirectories: false,\n    }),\n  gitDiff: z\n    .object({\n      excludeLockFiles: z.boolean().default(true),\n      lockFiles: z\n        .array(z.string())\n        .default([\n          \"package-lock.json\",\n          \"yarn.lock\",\n          \"pnpm-lock.yaml\",\n          \"Gemfile.lock\",\n          \"composer.lock\",\n          \"Pipfile.lock\",\n          \"poetry.lock\",\n          \"packages.lock.json\",\n          \"Cargo.lock\",\n          \"Podfile.lock\",\n          \"mix.lock\",\n          \"go.sum\",\n          \"pubspec.lock\",\n        ]),\n    })\n    .default({\n      excludeLockFiles: true,\n      lockFiles: [\n        \"package-lock.json\",\n        \"yarn.lock\",\n        \"pnpm-lock.yaml\",\n        \"Gemfile.lock\",\n        \"composer.lock\",\n        \"Pipfile.lock\",\n        \"poetry.lock\",\n        \"packages.lock.json\",\n        \"Cargo.lock\",\n        \"Podfile.lock\",\n        \"mix.lock\",\n        \"go.sum\",\n        \"pubspec.lock\",\n      ],\n    }),\n  referenceExamples: z.record(z.string(), z.string()).optional().default({}),\n  projectLanguage: z.string().default(\"typescript\"),\n  packageManager: z.string().default(\"yarn\"),\n});\n\nexport type Config = z.infer<typeof configSchema>;\n\n@autoInjectable()\nexport class ConfigService {\n  private readonly CONFIG_PATH = path.resolve(\"crkdrc.json\");\n  private readonly GITIGNORE_PATH = path.resolve(\".gitignore\");\n\n  private ensureGitIgnore(): void {\n    const gitignoreContent = fs.existsSync(this.GITIGNORE_PATH)\n      ? fs.readFileSync(this.GITIGNORE_PATH, \"utf-8\")\n      : \"\";\n\n    if (!gitignoreContent.includes(\"crkdrc.json\")) {\n      const updatedContent =\n        gitignoreContent.endsWith(\"\\n\") || gitignoreContent === \"\"\n          ? `${gitignoreContent}crkdrc.json\\n`\n          : `${gitignoreContent}\\ncrkdrc.json\\n`;\n\n      fs.writeFileSync(this.GITIGNORE_PATH, updatedContent);\n    }\n  }\n\n  public createDefaultConfig(): void {\n    if (!fs.existsSync(this.CONFIG_PATH)) {\n      console.log(\"Creating default crkdrc.json configuration...\");\n\n      const defaultConfig = {\n        provider: \"open-router\",\n        projectLanguage: \"typescript\",\n        packageManager: \"yarn\",\n        customInstructions: \"Follow clean code principles\",\n        customInstructionsPath: \"\",\n        interactive: true,\n        stream: true,\n        debug: false,\n        options:\n          \"temperature=0,top_p=0.1,top_k=1,frequence_penalty=0.0,presence_penalty=0.0,repetition_penalty=1.0\",\n        openRouterApiKey: \"\",\n        appUrl: \"https://localhost:8080\",\n        appName: \"MyCrackedApp\",\n        autoScaler: true,\n        autoScaleMaxTryPerModel: 2,\n        // Phase-specific model configurations\n        discoveryModel: \"google/gemini-flash-1.5-8b\",\n        strategyModel: \"qwen/qwq-32b-preview\",\n        executeModel: \"anthropic/claude-3.5-sonnet:beta\",\n        includeAllFilesOnEnvToContext: false,\n        autoScaleAvailableModels: [\n          {\n            id: \"qwen/qwen-2.5-coder-32b-instruct\",\n            description: \"Cheap, fast, slightly better than GPT4o-mini\",\n            maxWriteTries: 5,\n            maxGlobalTries: 10,\n          },\n          {\n            id: \"anthropic/claude-3.5-sonnet:beta\",\n            description: \"Scaled model for retry attempts\",\n            maxWriteTries: 5,\n            maxGlobalTries: 15,\n          },\n          {\n            id: \"openai/gpt-4o-2024-11-20\",\n            description: \"Scaled model for retry attempts\",\n            maxWriteTries: 2,\n            maxGlobalTries: 20,\n          },\n        ],\n        runAllTestsCmd: \"yarn test\",\n        runOneTestCmd: \"yarn test {relativeTestPath}\",\n        runTypeCheckCmd: \"yarn typecheck\",\n        enableConversationLog: false,\n        logDirectory: \"logs\",\n        directoryScanner: {\n          defaultIgnore: [\n            \"dist\",\n            \"coverage\",\n            \".next\",\n            \"build\",\n            \".cache\",\n            \".husky\",\n          ],\n          maxDepth: 8,\n          allFiles: true,\n          directoryFirst: true,\n          excludeDirectories: false,\n        },\n        gitDiff: {\n          excludeLockFiles: true,\n          lockFiles: [\n            \"package-lock.json\",\n            \"yarn.lock\",\n            \"pnpm-lock.yaml\",\n            \"Gemfile.lock\",\n            \"composer.lock\",\n            \"Pipfile.lock\",\n            \"poetry.lock\",\n            \"packages.lock.json\",\n            \"Cargo.lock\",\n            \"Podfile.lock\",\n            \"mix.lock\",\n            \"go.sum\",\n            \"pubspec.lock\",\n          ],\n        },\n        referenceExamples: {\n          example1: \"path/to/example1/file.ts\",\n          example2: \"path/to/example2/file.ts\",\n          myService: \"src/services/MyService.ts\",\n          anotherKey: \"path/to/some/other/example.ts\",\n        },\n      };\n      fs.writeFileSync(\n        this.CONFIG_PATH,\n        JSON.stringify(defaultConfig, null, 4),\n      );\n      console.log(\n        \"Default crkdrc.json configuration created. Please adjust it.\",\n      );\n      console.log(\n        chalk.yellow(\n          \"Warning: No OpenRouter API key provided. Please add it to crkdrc.json.\",\n        ),\n      );\n\n      this.ensureGitIgnore();\n\n      chalk.green(\n        \"CrackedDevCLI config generated. Please, add Provider and API Key to crkdrc.json.\",\n      );\n    }\n  }\n\n  public getConfig(): Config {\n    if (!fs.existsSync(this.CONFIG_PATH)) {\n      this.createDefaultConfig();\n    }\n\n    const rawData = fs.readFileSync(this.CONFIG_PATH, \"utf-8\");\n    const config = JSON.parse(rawData);\n\n    const parsedConfig = configSchema.safeParse(config);\n\n    if (!parsedConfig.success) {\n      console.error(\n        \"Invalid configuration in crkdrc.json:\",\n        parsedConfig.error,\n      );\n      throw new Error(\"Invalid configuration in crkdrc.json\");\n    }\n\n    return parsedConfig.data;\n  }\n}\n","import { ConfigService } from \"@services/ConfigService\";\nimport {\n  IDirectoryScanner,\n  TreeOptions,\n} from \"@services/FileManagement/types/DirectoryScannerTypes\";\nimport { IFileOperationResult } from \"@services/FileManagement/types/FileManagementTypes\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { autoInjectable, inject } from \"tsyringe\";\n\n@autoInjectable()\nexport class DirectoryScanner implements IDirectoryScanner {\n  private readonly REQUIRED_IGNORE = [\"node_modules\", \".git\"];\n\n  constructor(@inject(ConfigService) private configService: ConfigService) {\n    if (!configService) {\n      throw new Error(\"ConfigService is required for DirectoryScanner\");\n    }\n  }\n\n  private get defaultOptions(): TreeOptions {\n    const config = this.configService.getConfig();\n    return {\n      ignore: config.directoryScanner.defaultIgnore,\n      allFiles: config.directoryScanner.allFiles,\n      maxDepth: config.directoryScanner.maxDepth,\n      noreport: true,\n      base: \".\",\n      directoryFirst: config.directoryScanner.directoryFirst,\n      excludeDirectories: config.directoryScanner.excludeDirectories,\n    };\n  }\n\n  private getAllFiles(\n    dirPath: string,\n    basePath: string,\n    arrayOfFiles: string[] = [],\n    ignore: string[] = [],\n    currentDepth: number = 0,\n    maxDepth: number = 4,\n  ): string[] {\n    if (currentDepth > maxDepth) return arrayOfFiles;\n\n    const files = fs.readdirSync(dirPath);\n\n    files.forEach((file) => {\n      if (ignore.includes(file)) return;\n\n      const fullPath = path.join(dirPath, file);\n      const relativePath = path.relative(basePath, fullPath);\n\n      if (fs.statSync(fullPath).isDirectory()) {\n        this.getAllFiles(\n          fullPath,\n          basePath,\n          arrayOfFiles,\n          ignore,\n          currentDepth + 1,\n          maxDepth,\n        );\n      } else {\n        arrayOfFiles.push(relativePath);\n      }\n    });\n\n    return arrayOfFiles;\n  }\n\n  public async scan(\n    dirPath: string,\n    options: Partial<TreeOptions> = {},\n  ): Promise<IFileOperationResult> {\n    try {\n      const defaultOptions = this.defaultOptions;\n      const scanOptions = { ...defaultOptions, ...options };\n      const ignore = [\n        ...this.REQUIRED_IGNORE,\n        ...(options.ignore || defaultOptions.ignore),\n      ];\n      const absolutePath = path.resolve(dirPath);\n\n      const files = this.getAllFiles(\n        absolutePath,\n        absolutePath,\n        [],\n        ignore,\n        0,\n        scanOptions.maxDepth,\n      ).sort();\n\n      return {\n        success: true,\n        data: files.map((f) => f.trim()).join(\"\\n\"),\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n      };\n    }\n  }\n}\n","import { autoInjectable } from \"tsyringe\";\nimport { MessageContextHistory } from \"../context/MessageContextHistory\";\nimport { MessageContextLogger } from \"../context/MessageContextLogger\";\nimport { ActionTag, getBlueprint, getImplementedActions } from \"./blueprints\";\nimport { ActionFactory } from \"./core/ActionFactory\";\nimport { ActionQueue } from \"./core/ActionQueue\";\nimport { IActionResult } from \"./types/ActionTypes\";\n\n@autoInjectable()\nexport class ActionExecutor {\n  constructor(\n    private actionFactory: ActionFactory,\n    private actionQueue: ActionQueue,\n    private messageContextLogger: MessageContextLogger,\n    private messageContextHistory: MessageContextHistory,\n  ) {}\n\n  async executeAction(actionText: string): Promise<IActionResult> {\n    try {\n      // Get all implemented action types\n      const implementedActions = getImplementedActions();\n\n      // Extract actions using regex\n      const actionMatch = /<(\\w+)>([\\s\\S]*?)<\\/\\1>/g;\n      const matches = Array.from(actionText.matchAll(actionMatch));\n\n      if (!matches.length) {\n        const error = new Error(\n          \"No valid action tags found. Actions must be wrapped in XML-style tags.\",\n        );\n        this.messageContextLogger.logActionResult(\"unknown\", {\n          success: false,\n          error,\n        });\n        this.messageContextHistory.addMessage(\n          \"system\",\n          \"Action failed: No valid action tags found\",\n        );\n        return { success: false, error };\n      }\n\n      // Queue all actions\n      for (const [fullMatch, actionType] of matches) {\n        // Skip if this action is inside another XML tag\n        const startIndex = actionText.indexOf(fullMatch);\n        const beforeText = actionText.substring(0, startIndex);\n        const hasOpenTag = /<\\w+>/.test(beforeText);\n        const hasCloseTag = /<\\/\\w+>/.test(beforeText);\n\n        // If we find an opening tag before this action but no matching closing tag,\n        // it means we're inside another tag - skip this action\n        if (hasOpenTag && !hasCloseTag) {\n          continue;\n        }\n\n        if (actionType !== \"path\" && actionType !== \"content\") {\n          if (implementedActions.includes(actionType as ActionTag)) {\n            this.actionQueue.enqueue(actionType, fullMatch);\n          } else {\n            const error = new Error(`Unknown action type: ${actionType}`);\n            this.messageContextLogger.logActionResult(actionType, {\n              success: false,\n              error,\n            });\n            this.messageContextHistory.addMessage(\n              \"system\",\n              `Action failed: Unknown type ${actionType}`,\n            );\n            return { success: false, error };\n          }\n        }\n      }\n\n      // Process actions in order\n      let lastResult: IActionResult = { success: true };\n      while (!this.actionQueue.isEmpty()) {\n        const action = this.actionQueue.dequeue();\n        if (!action) continue;\n\n        const actionInstance = this.actionFactory.createAction(\n          action.type as ActionTag,\n        );\n        if (!actionInstance) {\n          const error = new Error(\n            `Failed to create action instance for \"${action.type}\"`,\n          );\n          this.messageContextLogger.logActionResult(action.type, {\n            success: false,\n            error,\n          });\n          this.messageContextHistory.addMessage(\n            \"system\",\n            `Action ${action.type} failed: Could not create instance`,\n          );\n          return { success: false, error };\n        }\n\n        // Get blueprint for logging\n        const blueprint = getBlueprint(action.type as ActionTag);\n        if (blueprint) {\n          console.log(\n            `⚡ ${blueprint.description || `Executing ${action.type}`}...`,\n          );\n        }\n\n        // Execute action\n        lastResult = await actionInstance.execute(action.content);\n\n        // Log the result\n        this.messageContextLogger.logActionResult(action.type, lastResult);\n\n        // Add result to conversation history\n        if (lastResult.success) {\n          if (lastResult.data) {\n            this.messageContextHistory.addMessage(\n              \"system\",\n              `Action ${action.type} succeeded: ${JSON.stringify(lastResult.data)}`,\n            );\n          } else {\n            this.messageContextHistory.addMessage(\n              \"system\",\n              `Action ${action.type} succeeded`,\n            );\n          }\n        } else {\n          const errorMessage = lastResult.error\n            ? lastResult.error.message\n            : \"Unknown error\";\n          this.messageContextHistory.addMessage(\n            \"system\",\n            `Action ${action.type} failed: ${errorMessage}`,\n          );\n        }\n\n        // Store result in queue for processing requirements\n        this.actionQueue.setActionResult(\n          action.type,\n          action.content,\n          lastResult,\n        );\n\n        if (!lastResult.success) {\n          // Clear queue on error\n          this.actionQueue.clear();\n          break;\n        }\n\n        // If this action requires processing, include its results in the final output\n        if (blueprint?.requiresProcessing && lastResult.success) {\n          lastResult = {\n            ...lastResult,\n            processedResults: this.actionQueue.getProcessedResults(),\n          };\n        }\n      }\n\n      // Get final processed results before clearing\n      const finalProcessedResults = this.actionQueue.getProcessedResults();\n\n      // Clear queue before returning\n      this.actionQueue.clear();\n\n      // Include processed results in final output if there are any\n      return finalProcessedResults.size > 0\n        ? { ...lastResult, processedResults: finalProcessedResults }\n        : lastResult;\n    } catch (error) {\n      // Clear queue on error\n      this.actionQueue.clear();\n\n      // Log the error\n      this.messageContextLogger.logActionResult(\"unknown\", {\n        success: false,\n        error: error as Error,\n      });\n      this.messageContextHistory.addMessage(\n        \"system\",\n        `Action failed with error: ${(error as Error).message}`,\n      );\n\n      return {\n        success: false,\n        error: error as Error,\n      };\n    }\n  }\n}\n","import { IConversationHistoryMessage } from \"@services/LLM/ILLMProvider\";\nimport { autoInjectable, singleton } from \"tsyringe\";\nimport { PhaseManager } from \"../PhaseManager\";\nimport { MessageContextBuilder } from \"./MessageContextBuilder\";\nimport { MessageContextLogger } from \"./MessageContextLogger\";\nimport { MessageContextStore } from \"./MessageContextStore\";\n\n@singleton()\n@autoInjectable()\nexport class MessageContextHistory {\n  constructor(\n    private messageContextStore: MessageContextStore,\n    private messageContextLogger: MessageContextLogger,\n    private phaseManager: PhaseManager,\n    private messageContextBuilder: MessageContextBuilder,\n  ) {}\n\n  public addMessage(\n    role: string,\n    content: string,\n    log = true,\n    isFirstMessage = false,\n  ): boolean {\n    if (![\"user\", \"assistant\", \"system\"].includes(role)) {\n      throw new Error(`Invalid role: ${role}`);\n    }\n\n    if (content.trim() === \"\") {\n      throw new Error(\"Content cannot be empty\");\n    }\n\n    // Clean up logs if this is the first message\n    if (isFirstMessage && this.isLoggingEnabled()) {\n      this.messageContextLogger.cleanupLogFiles();\n    }\n\n    const updatedData = this.messageContextBuilder.buildMessageContext(\n      role as \"user\" | \"assistant\" | \"system\",\n      content,\n      this.phaseManager.getCurrentPhase(),\n      this.messageContextStore.getContextData(),\n    );\n    this.messageContextStore.setContextData(updatedData);\n\n    if (log) {\n      this.logMessage({\n        role: role as \"user\" | \"assistant\" | \"system\",\n        content,\n      });\n    }\n\n    return true;\n  }\n\n  public getMessages(): IConversationHistoryMessage[] {\n    return this.messageContextBuilder.getMessageContext(\n      this.messageContextStore.getContextData(),\n    );\n  }\n\n  public clear(): void {\n    this.messageContextStore.clear();\n    this.messageContextLogger.cleanupLogFiles();\n  }\n\n  public setSystemInstructions(instructions: string): void {\n    this.messageContextStore.setContextData({\n      systemInstructions: instructions,\n    });\n  }\n\n  public getSystemInstructions(): string | null {\n    return this.messageContextStore.getContextData().systemInstructions;\n  }\n\n  public updateLogFile(): void {\n    if (process.env.NODE_ENV === \"test\" || !this.isLoggingEnabled()) return;\n    this.messageContextLogger.updateConversationHistory(\n      this.messageContextBuilder.getMessageContext(\n        this.messageContextStore.getContextData(),\n      ),\n      this.messageContextStore.getContextData().systemInstructions,\n    );\n  }\n\n  private cleanContent(content: string): string {\n    // Remove phase prompts\n    content = content.replace(/<phase_prompt>.*?<\\/phase_prompt>/gs, \"\").trim();\n\n    // Remove file operation messages\n    if (\n      content.includes(\"Content of\") ||\n      content.includes(\"Written to\") ||\n      content.includes(\"FILE CREATED AND EXISTS:\") ||\n      content.includes(\"Command executed:\") ||\n      content.includes(\"Command:\")\n    ) {\n      return \"\";\n    }\n\n    return content;\n  }\n\n  private logMessage(message: IConversationHistoryMessage): void {\n    if (process.env.NODE_ENV === \"test\" || !this.isLoggingEnabled()) return;\n    this.messageContextLogger.logMessage(message);\n  }\n\n  private isLoggingEnabled(): boolean {\n    return this.messageContextLogger.getConversationLogPath() !== null;\n  }\n}\n","// services/PhaseManager.ts\nimport { ConfigService } from \"@services/ConfigService\";\nimport { injectable, singleton } from \"tsyringe\";\nimport { ModelManager } from \"./ModelManager\";\nimport { phaseBlueprints } from \"./phases/blueprints\";\nimport { IPhaseConfig, Phase } from \"./types/PhaseTypes\";\n\n@injectable()\n@singleton()\nexport class PhaseManager {\n  private currentPhase: Phase = Phase.Discovery;\n  private phaseConfigs: Map<Phase, IPhaseConfig> = new Map();\n\n  constructor(\n    private configService: ConfigService,\n    private modelManager: ModelManager,\n  ) {}\n\n  public initializePhaseConfigs() {\n    const config = this.configService.getConfig();\n\n    // Initialize configs using blueprints but override models from config if provided\n    this.phaseConfigs = new Map([\n      [\n        Phase.Discovery,\n        {\n          ...phaseBlueprints[Phase.Discovery],\n          model:\n            config.discoveryModel || phaseBlueprints[Phase.Discovery].model,\n        },\n      ],\n      [\n        Phase.Strategy,\n        {\n          ...phaseBlueprints[Phase.Strategy],\n          model: config.strategyModel || phaseBlueprints[Phase.Strategy].model,\n        },\n      ],\n      [\n        Phase.Execute,\n        {\n          ...phaseBlueprints[Phase.Execute],\n          model: config.executeModel || phaseBlueprints[Phase.Execute].model,\n        },\n      ],\n    ]);\n\n    // set initial phase\n    this.currentPhase = Phase.Discovery;\n\n    // set initial model\n    const phaseData = this.phaseConfigs.get(Phase.Discovery);\n\n    if (!phaseData) {\n      throw new Error(\"No data found for Discovery phase\");\n    }\n\n    this.modelManager.setCurrentModel(phaseData.model);\n  }\n\n  getCurrentPhase(): Phase {\n    return this.currentPhase;\n  }\n\n  getCurrentPhaseConfig(): IPhaseConfig {\n    // reset if not set\n    if (!this.currentPhase) {\n      this.resetPhase();\n    }\n\n    const config = this.phaseConfigs.get(this.currentPhase);\n    if (!config) {\n      throw new Error(`No configuration found for phase ${this.currentPhase}`);\n    }\n    return config;\n  }\n\n  setPhase(phase: Phase) {\n    this.currentPhase = phase;\n  }\n\n  getPhaseConfig(phase: Phase): IPhaseConfig {\n    const config = this.phaseConfigs.get(phase);\n    if (!config) {\n      throw new Error(`No configuration found for phase ${phase}`);\n    }\n    return config;\n  }\n\n  nextPhase(): Phase {\n    switch (this.currentPhase) {\n      case Phase.Discovery:\n        this.currentPhase = Phase.Strategy;\n        break;\n      case Phase.Strategy:\n        this.currentPhase = Phase.Execute;\n        break;\n      case Phase.Execute:\n        // Execute is the final phase, stays there\n        break;\n    }\n    return this.currentPhase;\n  }\n\n  resetPhase() {\n    this.currentPhase = Phase.Discovery;\n  }\n}\n","export const Colors = {\n  reset: \"\\x1b[0m\",\n  cyan: \"\\x1b[36m\",\n  yellow: \"\\x1b[33m\",\n  green: \"\\x1b[32m\",\n  magenta: \"\\x1b[35m\",\n  blue: \"\\x1b[34m\",\n};\n","import { Colors } from \"@constants/colors\";\nimport { autoInjectable, singleton } from \"tsyringe\";\n\n@singleton()\n@autoInjectable()\nexport class DebugLogger {\n  private debug: boolean = false;\n\n  constructor() {}\n\n  setDebug(debug: boolean) {\n    this.debug = debug;\n  }\n\n  private formatData(data: any): string {\n    if (typeof data === \"string\") {\n      return data;\n    }\n\n    if (typeof data === \"object\") {\n      try {\n        return JSON.stringify(data, null, 2)\n          .replace(/\\\\\\\\/g, \"\\\\\")\n          .replace(/\\\\\"/g, '\"')\n          .replace(/\\\\n/g, \"\\n\");\n      } catch {\n        return String(data);\n      }\n    }\n\n    return String(data);\n  }\n\n  log(type: string, message: string, data?: any) {\n    if (!this.debug) return;\n\n    const timestamp = new Date().toISOString();\n    const divider = \"\\n\" + \"═\".repeat(100);\n    const subDivider = \"─\".repeat(80);\n\n    console.log(divider);\n    console.log(`${Colors.cyan}DEBUG${Colors.reset} [${timestamp}]`);\n    console.log(`${Colors.yellow}${type}${Colors.reset}: ${message}`);\n\n    if (data) {\n      console.log(`\\n${Colors.magenta}Data:${Colors.reset}`);\n      const formattedData = this.formatData(data)\n        .split(\"\\n\")\n        .map((line) => `  ${line}`)\n        .join(\"\\n\");\n      console.log(`${Colors.blue}${formattedData}${Colors.reset}`);\n      console.log(subDivider);\n    }\n  }\n}\n","import { DebugLogger } from \"@services/logging/DebugLogger\";\nimport { singleton } from \"tsyringe\";\nimport { ModelInfo } from \"./ModelInfo\";\n\n@singleton()\nexport class ModelManager {\n  private currentModel: string = \"\";\n\n  constructor(\n    private modelInfo: ModelInfo,\n    private debugLogger: DebugLogger,\n  ) {}\n\n  public setCurrentModel(model: string): void {\n    this.currentModel = model;\n    this.modelInfo.setCurrentModel(model);\n    this.debugLogger.log(\"ModelManager\", \"Model updated\", { model });\n  }\n\n  public getCurrentModel(): string {\n    return this.currentModel;\n  }\n}\n","import { ConfigService } from \"@services/ConfigService\";\nimport axios, { AxiosInstance } from \"axios\";\nimport { container } from \"tsyringe\";\n\nexport const createOpenRouterClient = (baseURL: string): AxiosInstance => {\n  const configService = container.resolve(ConfigService);\n  const config = configService.getConfig();\n\n  const headers: Record<string, string> = {\n    Authorization: `Bearer ${config.openRouterApiKey}`,\n    \"Content-Type\": \"application/json\",\n  };\n\n  if (config.appUrl) {\n    headers[\"HTTP-Referer\"] = config.appUrl;\n  }\n\n  if (config.appName) {\n    headers[\"X-Title\"] = config.appName;\n  }\n\n  return axios.create({\n    baseURL,\n    // Remove timeout for streaming support\n    timeout: 0,\n    headers,\n    // Add necessary axios config for proper streaming\n    maxBodyLength: Infinity,\n    maxContentLength: Infinity,\n  });\n};\n\nexport const openRouterClient = createOpenRouterClient(\n  \"https://openrouter.ai/api/v1\",\n);\n","import { openRouterClient } from \"@constants/openRouterClient\";\nimport { DebugLogger } from \"@services/logging/DebugLogger\";\nimport { singleton } from \"tsyringe\";\nimport { IModelInfo } from \"./types/ModelTypes\";\n\n@singleton()\nexport class ModelInfo {\n  private modelInfoMap: Map<string, IModelInfo> = new Map();\n  private currentModel: string | null = null;\n  private currentModelInfo: IModelInfo | null = null;\n  private initialized: boolean = false;\n  private usageHistory: {\n    [model: string]: {\n      prompt_tokens: number;\n      completion_tokens: number;\n      total_tokens: number;\n    }[];\n  } = {};\n\n  constructor(private debugLogger: DebugLogger) {}\n\n  async initialize(): Promise<void> {\n    try {\n      const response = await openRouterClient.get(\"/models\");\n      const models: IModelInfo[] = response.data.data;\n\n      // Clear existing models before adding new ones\n      this.modelInfoMap.clear();\n\n      models.forEach((model) => {\n        this.modelInfoMap.set(model.id, model);\n      });\n\n      this.initialized = true;\n    } catch (error) {\n      this.debugLogger.log(\"ModelInfo\", \"Failed to initialize model list\", {\n        error,\n      });\n      throw error;\n    }\n  }\n\n  private async ensureInitialized(): Promise<void> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n  }\n\n  async setCurrentModel(modelId: string): Promise<void> {\n    await this.ensureInitialized();\n\n    if (modelId === this.currentModel && this.currentModelInfo) {\n      return; // Already tracking this model\n    }\n\n    if (!(await this.isModelAvailable(modelId))) {\n      throw new Error(\n        `Invalid model: ${modelId}. Available models: ${Array.from(this.modelInfoMap.keys()).join(\", \")}`,\n      );\n    }\n\n    const modelInfo = this.modelInfoMap.get(modelId)!; // Safe to use ! here since we checked availability\n    this.currentModel = modelId;\n    this.currentModelInfo = modelInfo;\n\n    if (!modelInfo) {\n      return;\n    }\n\n    this.debugLogger.log(\"ModelInfo\", \"Current model info\", {\n      model: modelId,\n      contextLength: modelInfo.context_length,\n      maxCompletionTokens: modelInfo.top_provider.max_completion_tokens,\n    });\n  }\n\n  getCurrentModel(): string | null {\n    return this.currentModel;\n  }\n\n  async getModelInfo(modelId: string): Promise<IModelInfo | undefined> {\n    await this.ensureInitialized();\n    return this.modelInfoMap.get(modelId);\n  }\n\n  getCurrentModelInfo(): IModelInfo | null {\n    return this.currentModelInfo;\n  }\n\n  async getCurrentModelContextLength(): Promise<number> {\n    await this.ensureInitialized();\n    return this.currentModelInfo?.context_length || 128000; // Default fallback\n  }\n\n  async getModelContextLength(modelId: string): Promise<number> {\n    await this.ensureInitialized();\n    const modelInfo = await this.getModelInfo(modelId);\n    return modelInfo?.context_length || 128000; // Default fallback\n  }\n\n  async getAllModels(): Promise<string[]> {\n    await this.ensureInitialized();\n    return Array.from(this.modelInfoMap.keys());\n  }\n\n  async isModelAvailable(modelId: string): Promise<boolean> {\n    await this.ensureInitialized();\n    const available = this.modelInfoMap.has(modelId);\n\n    if (!available) {\n      const availableModels = Array.from(this.modelInfoMap.keys());\n      this.debugLogger.log(\"ModelInfo\", \"Model not found in available models\", {\n        modelId,\n        availableModels,\n      });\n    }\n\n    return available;\n  }\n\n  async getModelMaxCompletionTokens(modelId: string): Promise<number> {\n    await this.ensureInitialized();\n    const modelInfo = await this.getModelInfo(modelId);\n    return modelInfo?.top_provider.max_completion_tokens || 4096; // Default fallback\n  }\n\n  async getCurrentModelMaxCompletionTokens(): Promise<number> {\n    await this.ensureInitialized();\n    return this.currentModelInfo?.top_provider.max_completion_tokens || 4096; // Default fallback\n  }\n\n  async logCurrentModelUsage(usedTokens: number): Promise<void> {\n    await this.ensureInitialized();\n\n    if (!this.currentModelInfo) {\n      return;\n    }\n\n    const contextLength = this.currentModelInfo.context_length;\n    const usagePercent = ((usedTokens / contextLength) * 100).toFixed(1);\n\n    this.debugLogger.log(\"ModelInfo\", \"Token usage\", {\n      model: this.currentModel,\n      used: usedTokens,\n      total: contextLength,\n      percentage: `${usagePercent}%`,\n      remaining: contextLength - usedTokens,\n    });\n  }\n\n  async logDetailedUsage(usage: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  }): Promise<void> {\n    await this.ensureInitialized();\n\n    if (!this.currentModel) {\n      return;\n    }\n\n    if (!this.usageHistory[this.currentModel]) {\n      this.usageHistory[this.currentModel] = [];\n    }\n\n    this.usageHistory[this.currentModel].push(usage);\n\n    this.debugLogger.log(\"ModelInfo\", \"Detailed token usage\", {\n      model: this.currentModel,\n      usage,\n    });\n  }\n\n  getUsageHistory(): {\n    [model: string]: {\n      prompt_tokens: number;\n      completion_tokens: number;\n      total_tokens: number;\n    }[];\n  } {\n    return this.usageHistory;\n  }\n}\n","export enum Phase {\n  Discovery = \"discovery\",\n  Strategy = \"strategy\",\n  Execute = \"execute\",\n}\n\nexport interface IPhasePromptArgs {\n  message: string;\n  environmentDetails?: string;\n  projectInfo?: string;\n  [key: string]: any;\n}\n\nexport interface IPhaseConfig {\n  model: string;\n  generatePrompt: (args: IPhasePromptArgs) => string;\n}\n\nexport interface IPhaseManagerConfig {\n  discoveryModel: string;\n  strategyModel: string;\n  executeModel: string;\n}\n","import { ConfigService } from \"@services/ConfigService\";\nimport { container } from \"tsyringe\";\nimport { IPhaseConfig, IPhasePromptArgs } from \"../../types/PhaseTypes\";\n\nconst configService = container.resolve(ConfigService);\nconst config = configService.getConfig();\n\nexport const discoveryPhaseBlueprint: IPhaseConfig = {\n  model: config.discoveryModel,\n  generatePrompt: (args: IPhasePromptArgs) => `\n<!-- Internal instructions. Do not output. Follow precisely. -->\n<phase_prompt>\n## Discovery Phase\n\nYour end goal on this phase is to gather all information that's relevant to achieve our current task. Do not deviate from this goal. \n\n### Critical Instructions\n\n- **New Code Tasks:**\n  - Do not output code in markdown.\n  - If asked to create a new file, skip searching and proceed to strategy_phase.\n  - End phase immediately to strategy_phase if exploration isn't needed.\n  - If attempting to read non-existent files repeatedly, assume new file creation and skip to strategy_phase.\n  - Figure out the proper folder structure and file locations to place your files.\n\n- **Modification Tasks:**\n  - State intent clearly.\n  - First action: read_file relevant files.\n  - If unsure of file locations, use search_string or search_file.\n  - Use execute_command for specific tests or fixes.\n  - Gather all necessary context before proceeding.\n  - For git-related exploration (e.g., finding files, regressions, bugs), use git_diff or git_pr_diff via action_explainer.\n\n- **General Rules:**\n  - No code writing—exploration only.\n  - Maximum of 5 file reads.\n  - Do not reread files already in context.\n  - Confirm sufficient information before ending phase.\n  - Use end_phase once enough context is gathered.\n  - Ensure actions have proper tag structures.\n\n### Key Objectives\n\n- **New Code:** Transition quickly to implementation.\n- **Existing Code:** Locate and read files, run type checks/tests as necessary.\n- End phase when confident.\n- Keep file reads and tests targeted.\n\n### Example Behavior\n\nTo achieve the goal of XYZ, I'll need to read the following files:\n\n<read_file>\n  <path>src/someRelatedFile.ts</path>\n  <path>src/anotherFile.ts</path>\n</read_file>\n\n<!-- Run typechecks and tests if needed. -->\n\n<!-- Move to the next phase after completion. Do not do it in the same prompt! -->\n\nOk, I have enough context to move to the next phase.\n\n<end_phase>\n  strategy_phase\n</end_phase>\n\n</phase_prompt>\n\n## Allowed Actions\n<!-- Follow correct tag structure and use only one action per reply. No comments or additional text. -->\n\nREMEMBER: ONLY ONE ACTION PER REPLY!!!\n\n<read_file>\n  <!-- Read individual files only, not directories -->\n  <path>path/here</path>\n  <!-- Do not read the same file multiple times unless changed -->\n  <!-- Ensure correct <read_file> tag format -->\n  <!-- Read up to 4 related files -->\n  <!-- Multiple <path> tags allowed -->\n  <!-- Use relative paths -->\n</read_file>\n\n<execute_command>\n  <!-- Use this if you want to explore the codebase further. Examples below: -->\n  <!-- List files and directories: ls -->\n  <!-- Detailed directory list: ls -lh -->\n  <!-- Show current directory path: pwd -->\n</execute_command>\n\n<search_string>\n  <directory>/path/to/search</directory>\n  <term>pattern to search</term>\n</search_string>\n\n<search_file>\n  <directory>/path/to/search</directory>\n  <term>filename pattern</term>\n</search_file>\n\n<end_phase>\n  <!-- Use when the phase is complete and all necessary information is gathered -->\n</end_phase>\n\n### Other Actions\n\nFor additional actions, use action_explainer as follows:\n\n<action_explainer>\n  <action>\n    <!-- Do not use these actions directly. Refer to explainer instructions -->\n    <!-- Available actions: git_diff, git_pr_diff, fetch_url -->\n  </action>\n</action_explainer>\n\n### Useful Commands\n\n- **Run all tests:** ${args.runAllTestsCmd || \"yarn test\"}\n- **Run a specific test:** ${args.runOneTestCmd || \"yarn test {relativeTestPath}\"}\n- **Run type check:** ${args.runTypeCheckCmd || \"yarn tsc\"}\n\n## Environment \n${args.projectInfo || \"\"}\n\n${args.environmentDetails || \"\"}\n</phase_prompt>\n`,\n};\n","import { ConfigService } from \"@services/ConfigService\";\nimport { container } from \"tsyringe\";\nimport { IPhaseConfig, IPhasePromptArgs } from \"../../types/PhaseTypes\";\n\nconst configService = container.resolve(ConfigService);\nconst config = configService.getConfig();\n\nexport const executePhaseBlueprint: IPhaseConfig = {\n  model: config.executeModel,\n  generatePrompt: (args: IPhasePromptArgs) => `\n<!-- These are internal instructions. Just follow them. Do not output. -->\n\n<phase_prompt>\n## Execute Phase\n\n## Initial Instructions\n\n- EXECUTION FLOW:\n  1. Follow strategy phase steps IN ORDER\n  2. ONE action per response\n  3. After EACH code change:\n     - Run specific tests\n     - Run type checks\n     - Fix or report issues\n  4. End task IMMEDIATELY when goal is achieved\n  5. If files were already written on the previous phase, just run tests and type checks to validate and see if there's a need to run more steps. If not, end_task.\n\n- VALIDATION GATES:\n  1. Before write_file:\n     - Verify imports with relative_path_lookup\n     - Check file paths with execute_command\n     - See if its necessary to write the file again.\n  2. After write_file:\n     - Run unit tests\n     - Run type checks\n     - If both pass -> continue or end_task\n     - If either fails -> fix or report\n\n- STUCK PREVENTION:\n  1. Import issues -> Use relative_path_lookup\n  2. Path issues -> Use execute_command\n  3. Test failures -> Read test file, fix specific issue\n  4. Type errors -> Fix one at a time\n  5. Max 3 fix attempts -> Then end_task with report\n\n- CODE CHANGES:\n  1. ONE change at a time\n  2. Full implementation (no TODOs)\n  3. Include ALL imports\n  4. Follow project patterns\n  5. Test after EACH change\n\n### Example Flow:\n1. Implement feature:\n   <write_file>\n     <type>new/update</type>\n     <path>/verified/path/here</path>\n     <content>\n       // Complete implementation\n     </content>\n   </write_file>\n\n2. Run tests, fix if needed\n3. Run type check, fix if needed\n4. If all passes and goal met -> <end_task>\n\n## EXAMPLE BEHAVIOR\n\n<!-- NO NEED TO OUTPUT SPECIFIC DETAILS FROM STRATEGY PHASE. JUST SUMAMRIZE. IF YOU NEED TO OUTPUT CODE, MAKE SURE TO DO IT WITHIN A write_file TAG -->\n\nLet's start. Steps from strategy phase:\n\n- Objective 1: Do this\n- Objective 2: Do that\n- Objective 3: Do this other thing\n \n<!-- Then choose an action from the available actions below -->\n\n\n\n## Important Notes\n\n### Critical Instructions\n\n- IMMEDIATELY END TASK (end_task) when goal is achieved - do not continue unnecessarily\n- AFTER EVERY write_file:\n  1. Run specific tests for modified files\n  2. Run type check\n  3. If both pass and goal is met -> end_task\n  4. If either fails -> fix or report\n- NEVER ESCAPE double quotes (\") or backticks (\\`) in your outputs\n- Every output must include one action tag. No exceptions.\n- Only one action per reply.\n- Do not output code outside write_file tags, except when creating a markdown file.\n- Use raw text only; avoid encoded characters.\n- Stick precisely to the task.\n- Double-check file paths.\n- Reuse dependencies; do not install extras unless asked. REMEMBER THIS, DO NOT ADD EXTRA DEPENDENCIES UNLESS ASKED!\n- Properly format action tags.\n- Place code or markdown inside write_file tags.\n- Be concise; avoid verbosity.\n- Do not repeat tasks once done.\n- Maintain correct tag structure.\n- Focus on the task; end with a single end_task upon completion.\n- Initial message: brief intro and steps; can read up to 3 files.\n- Use only one write_file per output; verify before next step.\n- Do not output markdown/code outside action tags initially.\n- After reading a file, proceed without comments.\n- Include content directly within action tags without previews.\n- Avoid unnecessary explanations; be actionable.\n- Ensure outputs meet requirements and are usable.\n- Ensure correct PATH when using write_file.\n- Before end_task, run tests and type checks to confirm everything is good.\n- If import errors occur, use relative_path_lookup to find the correct path. THEN MAKE SURE TO USE IT ON THE IMPORT!\n- Unless writing .md markdown files, don't use \\`\\`\\`xml or whatever language code blocks. All code should be within write_file tags!!\n- Do not read_file if you already have it on the conversation history.\n- Make sure you know the proper path to write the file. If not, use execute_command to find the correct path (e.g. 'ls -lha').\n\n### Code Writing Instructions\n\n#### Before Starting\n\n- Read context files.\n- Follow project patterns; read up to 2 existing tests.\n- Propose solution. Use write_file.\n- Confirm external deps if needed.\n- Reuse deps.\n\n#### During Coding\n\n- One action per reply.\n- If stuck, read files/strategize.\n- Raw text only; no encoded.\n- Output full code.\n- Minimal changes.\n- Iterate.\n- Follow principles: DRY, SRP, KISS, YAGNI, LoD, Immutability.\n- Composition over inheritance.\n- High cohesion, low coupling.\n- Meaningful names.\n- Comment on why, not what.\n- Clean Code principles.\n- Few changes to prevent bugs.\n- If unsure, check docs or use <end_task>.\n- Correct import paths.\n- Project file naming conventions.\n- Full implementations.\n- If wrong imports, use relative_path_lookup.\n- If stuck on imports, stop write_file; use relative_path_lookup or search_file.\n- If stuck, read_file ONLY IF UNREAD.\n\n#### After Coding\n\n  - After changes:\n    - Run relevant tests; for risky, run folder tests.\n    - Run type checks/all tests at end.\n    - If tests pass, end_task.\n    - If tests fail, end_task to report.\n\n### Tests\n\n- DO NOT REMOVE PREVIOUS TESTS; ADD NEW.\n- Before new tests, review existing for patterns. Use search if needed.\n- When stuck on multiple failures, read other UNREAD test files.\n- When working on a test, assume related file is correct.\n- Do not remove previous tests unless necessary.\n- Prioritize individual test runs.\n- No tests for logging.\n- When fixing tests, run them first.\n- When adding tests, read target/related files.\n- Added tests must pass.\n- If asked to write tests, no need to read test file if non-existent.\n- Write all tests at once to save tokens.\n- Full test run only at task end; specific tests otherwise.\n\n### Commands Writing Instructions\n\n- Project's package manager.\n- Combine commands when possible.\n\n### Other Instructions\n \n- If unsure about paths/formats, use placeholders & ask.\n- If stuck, try alternatives or ask; avoid irrelevant output.\n\n### Docs Writing Instructions\n\n- No extra tabs at line starts.\n- Valid markdown; no extra tabs.\n- Mermaid diagrams with explanations.\n- In Mermaid, use [ ] instead of ( ).\n- After write_file, use read_file to verify, then stop.\n\n### Useful Commands\n\n- **Run all tests:** ${args.runAllTestsCmd || \"yarn test\"}\n- **Run a specific test:** ${args.runOneTestCmd || \"yarn test {relativeTestPath}\"}\n- **Run type check:** ${args.runTypeCheckCmd || \"yarn type-check\"}\n\n## Available Actions\n<!-- CRITICAL: MUST FOLLOW CORRECT TAG STRUCTURE PATTERN BELOW AND ONLY ONE ACTION PER OUTPUT/REPLY, otherwise I'll unplug you. -->\n<!-- Don't output // or <!-- comments -->\n\nREMEMBER: ONLY ONE ACTION PER REPLY!!!\n\nEVERY OUTPUT YOU GIVE TO THE USER MUST HAVE A CORRESPONDING ACTION TAG. NO EXCEPTIONS.\n\n<read_file>\n   <!-- Only read individual files, not directories -->\n  <path>path/here</path>\n  <!-- NO NEED TO READ FILES AGAIN THAT ARE ALREADY ON THE CONVERSATION HISTORY!!! -->\n  <!-- CRITICAL: DO NOT READ THE SAME FILES MULTIPLE TIMES, UNLESS THERES A CHANGE!!! -->\n  <!-- Critical: Make sure <read_file> tag format is correct! -->\n  <!-- Read up to 4 files -->\n  <!-- Multiple <path> tags allowed -->\n  <!-- Use relative paths -->\n</read_file>\n\nDO NOT RUN write_file if import issues are not resolved! Use relative_path_lookup first.\n<write_file>\n  <type>new/update</type>\n  <path>/path/here</path>\n  <content>\n   <!-- CRITICAL: Most write_file tasks are ADDITIVES if you already have content in place. -->\n   <!-- CRITICAL: If presented with import errors, USE IMMEDIATELY relative_path_lookup to find the correct path. -->\n   <!-- ALWAYS run a type check after write_file -->\n   <!-- ALWAYS output FULL CODE. No skips or partial code -->\n   <!-- Use raw text only -->\n   <!-- If available, use path alias on imports -->\n  </content>\n</write_file>\n\n<execute_command>\n<!-- Prompt before removing files or using sudo -->\n<!-- Any command like \"ls -la\" or \"yarn install\" -->\n<!-- Dont install extra dependencies unless allowed -->\n<!-- Use the project's package manager -->\n<!-- Use raw text only -->\n<!-- Avoid git commands here. Prefer git_diff and git_pr_diff. Exception: git command not available on this instruction-->\n</execute_command>\n\n<search_string>\n<!-- Use this to search for a string in a file -->\n  <directory>/path/to/search</directory>\n  <term>pattern to search</term>\n</search_string>\n\n<search_file>\n  <!-- Use if you don't know where a file is -->\n  <directory>/path/to/search</directory>\n  <term>filename pattern</term>\n</search_file>\n\n<relative_path_lookup>\n  <!-- CRITICAL: source_path is the file containing the broken imports -->\n  <!-- ONCE YOU FIND THE CORRECT PATH MAKE SURE TO UPDATE YOUR IMPORTS! -->\n  <source_path>/absolute/path/to/source/file.ts</source_path>\n  <path>../relative/path/to/fix</path>\n  <threshold>0.6</threshold>  <!-- Optional, defaults to 0.6. Higher means more strict. -->\n</relative_path_lookup>\n\n<delete_file>\n  <path>/path/here</path>\n</delete_file>\n\n<move_file>\n  <source_path>source/path/here</source_path>\n  <destination_path>destination/path/here</destination_path>\n</move_file>\n\n<copy_file>\n  <source_path>source/path/here</source_path>\n  <destination_path>destination/path/here</destination_path>\n</copy_file>\n\n<end_task>\n <!-- ONLY END IF TEST PASSES -->\n  <!-- SINGLE <end_task> PER OUTPUT. Do not mix with other actions -->\n  <!-- Before finishing, make sure TASK OBJECTIVE WAS COMPLETED! -->\n  <!-- Run tests and type checks to confirm changes before ending -->\n  <!-- Ensure all tests and type checks pass or report issues -->\n  Summarize and finalize.\n</end_task>\n\n\n### Other Actions\n\nThere are other actions you might request info about, using the action_explainer.\n\nJust follow this format to request more info:\n\n<action_explainer>\n   <action>\n   <!-- Don't use the actions below directly, check instructions from explainer before using them -->\n   <!-- Available actions: git_diff, git_pr_diff, fetch_url -->\n   </action>\n</action_explainer>\n\n\n${args.projectInfo ? `\\n## Project Context\\n${args.projectInfo}` : \"\"}\n\n</phase_prompt>\n`,\n};\n","import { ConfigService } from \"@services/ConfigService\";\nimport { container } from \"tsyringe\";\nimport { IPhaseConfig, IPhasePromptArgs } from \"../../types/PhaseTypes\";\n\nconst configService = container.resolve(ConfigService);\nconst config = configService.getConfig();\n\nexport const strategyPhaseBlueprint: IPhaseConfig = {\n  model: config.strategyModel,\n  generatePrompt: (args: IPhasePromptArgs) => `\n  <!-- These are internal instructions. Just follow them. Do not output. -->\n\n<phase_prompt>\n## Strategy Phase\n\n### Overall Objective\n- Plan solution based on discovery. Plan changes, impacts, and steps.\n- Instruct next agent clearly.\n\n### CRITICAL INSTRUCTIONS\n- ONE CLEAR PLAN: Create exactly one strategy with clear steps\n- NO EXPLORATION: Use discovery phase findings only\n- IMMEDIATE ACTION: After strategy, use end_phase execution_phase\n- ONE SHOT: Max 1 write_file, then end_phase\n- NO ITERATIONS: Strategy should be complete in one go\n- CLEAR STEPS: Number each implementation step\n- PATH VERIFICATION: Use <execute_command> if unsure about paths\n\n### Strategy Template\n1. State the goal clearly\n2. List dependencies/imports needed\n3. Outline implementation steps (numbered)\n4. Identify potential edge cases\n5. Note testing requirements\n6. End with end_phase\n\n1. Dependencies needed:\n   - None?\n   - @types/xyz\n   - existing utils from src/utils\n\n2. Implementation Steps:\n   1. Create new class X\n   2. Implement methods A, B\n   3. Add error handling\n   4. Connect to existing system\n\n3. Edge Cases:\n   - Handle null inputs\n   - Network timeouts\n   - Invalid states\n\n4. Testing Requirements:\n   - Unit tests for X class\n   - Integration test with Y\n   - Error case coverage\n\n<write_file>\n  <type>new/update</type>\n  <path>/correct/path/here</path>\n  <content>\n <!-- CRITICAL: Most write_file tasks are ADDITIVES if you already have content in place. -->\n   <!-- CRITICAL: If presented with import errors, USE IMMEDIATELY <relative_path_lookup> to find the correct path. -->\n   <!-- ALWAYS run a type check after write_file -->\n   <!-- ALWAYS output FULL CODE. No skips or partial code -->\n   <!-- Use raw text only -->\n   <!-- If available, use path alias on imports -->\n  </content>\n</write_file>\n\n<end_phase>\n  execution_phase\n</end_phase>\n\n## Allowed Available Actions\n<!-- CRITICAL: MUST FOLLOW CORRECT TAG STRUCTURE PATTERN BELOW AND ONLY ONE ACTION PER OUTPUT/REPLY, otherwise I'll unplug you. -->\n<!-- Don't output // or <!-- comments -->\n\nYOU CAN ONLY USE THIS ONE TIME! MAKE SURE YOU SUGGEST A write_file and then immediately end_phase!\n<write_file>\n  <type>new/update</type>\n  <path>/path/here</path>\n  <content>\n   <!-- CRITICAL: Most write_file tasks are ADDITIVES if you already have content in place. -->\n   <!-- CRITICAL: If presented with import errors, USE IMMEDIATELY <relative_path_lookup> to find the correct path. -->\n   <!-- ALWAYS run a type check after write_file -->\n   <!-- ALWAYS output FULL CODE. No skips or partial code -->\n   <!-- Use raw text only -->\n   <!-- If available, use path alias on imports -->\n  </content>\n</write_file>\n\nREMEMBER: ONLY ONE ACTION PER REPLY!!!\n\n<end_phase>\n  <!-- Output this when the phase is complete and you have a clear strategy.-->\n  <!-- MAKE SURE YOU REMEMBER TO DO THIS ONLY WHEN YOU FEEL YOU HAVE A SOLID PLAN! -->\n</end_phase>\n\n### Useful Commands\n\n- **Run all tests:** ${args.runAllTestsCmd || \"yarn test\"}\n- **Run a specific test:** ${args.runOneTestCmd || \"yarn test {relativeTestPath}\"}\n- **Run type check:** ${args.runTypeCheckCmd || \"yarn type-check\"}\n\n# Available Actions\n\n<execute_command>\n<!-- Use to run any command. For example to explore directories, try 'ls -lha' -->\n<!-- Avoid git commands here. Prefer git_diff and git_pr_diff. Exception: git command not available on this instruction-->\n</execute_command>\n\n### Other Actions\n\nThere are other actions you might request info about, using the action_explainer. \n\nJust follow this format to request more info:\n\n<action_explainer>\n   <action>\n   <!-- Don't use the actions below directly, check instructions from explainer before using them -->\n   <!-- Available actions: git_diff, git_pr_diff, fetch_url -->\n   </action>\n</action_explainer>\n\n</phase_prompt>\n`,\n};\n","import { Phase } from \"../../types/PhaseTypes\";\nimport { discoveryPhaseBlueprint } from \"./discoveryPhaseBlueprint\";\nimport { executePhaseBlueprint } from \"./executePhaseBlueprint\";\nimport { strategyPhaseBlueprint } from \"./strategyPhaseBlueprint\";\n\nexport const phaseBlueprints = {\n  [Phase.Discovery]: discoveryPhaseBlueprint,\n  [Phase.Strategy]: strategyPhaseBlueprint,\n  [Phase.Execute]: executePhaseBlueprint,\n};\n\nexport * from \"./discoveryPhaseBlueprint\";\nexport * from \"./executePhaseBlueprint\";\nexport * from \"./strategyPhaseBlueprint\";\n","/**\n * Base error class for all custom errors in the application.\n * Ensures proper prototype chain and consistent error handling.\n */\nexport class BaseError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = this.constructor.name;\n    // Ensure proper prototype chain for instanceof checks\n    Object.setPrototypeOf(this, this.constructor.prototype);\n  }\n}\n","import { BaseError } from \"../BaseError\";\n\n/**\n * Custom error class for message context related errors.\n */\nexport class MessageContextError extends BaseError {\n  constructor(message: string) {\n    super(message);\n  }\n}\n","import { MessageContextError } from \"@errors/context/MessageContextError\";\nimport { IConversationHistoryMessage } from \"@services/LLM/ILLMProvider\";\nimport { autoInjectable, singleton } from \"tsyringe\";\nimport { MessageContextExtractor } from \"./MessageContextExtractor\";\nimport {\n  IMessageContextData,\n  MessageCommandOperation,\n  MessageFileOperation,\n} from \"./MessageContextStore\";\n\nexport type MessageRole = \"user\" | \"assistant\" | \"system\";\nexport type MessageOperation = MessageFileOperation | MessageCommandOperation;\n\n@singleton()\n@autoInjectable()\nexport class MessageContextBuilder {\n  constructor(private extractor: MessageContextExtractor) {}\n\n  public buildMessageContext(\n    role: MessageRole,\n    content: string,\n    currentPhase: string,\n    contextData: IMessageContextData,\n  ): IMessageContextData {\n    try {\n      this.validateRole(role);\n      this.validateContent(content);\n      this.validateContextData(contextData);\n\n      if (!currentPhase) {\n        throw new MessageContextError(\"Current phase cannot be empty\");\n      }\n\n      const updatedPhaseInstructions = new Map();\n      const phasePromptMatches =\n        content.match(/<phase_prompt>(.*?)<\\/phase_prompt>/gs) || [];\n\n      const existingPhaseInstruction = Array.from(\n        contextData.phaseInstructions.values(),\n      ).find((instruction) => instruction.phase === currentPhase);\n\n      if (!existingPhaseInstruction) {\n        const validPrompts = phasePromptMatches\n          .filter(this.isValidPhasePrompt)\n          .map(this.extractPhasePromptContent)\n          .filter(Boolean);\n\n        if (validPrompts.length > 0) {\n          const lastValidPrompt = validPrompts[validPrompts.length - 1];\n          updatedPhaseInstructions.set(currentPhase, {\n            content: lastValidPrompt,\n            timestamp: Date.now(),\n            phase: currentPhase,\n          });\n        }\n      } else {\n        updatedPhaseInstructions.set(currentPhase, existingPhaseInstruction);\n      }\n\n      const operations = this.extractor.extractOperations(content);\n\n      const updatedFileOperations = new Map(contextData.fileOperations);\n      const updatedCommandOperations = new Map(contextData.commandOperations);\n\n      const filteredHistory = contextData.conversationHistory.filter((msg) => {\n        const msgContent = msg.content.trim();\n        const withoutPhasePrompt = msgContent\n          .replace(/<phase_prompt>.*?<\\/phase_prompt>/s, \"\")\n          .trim();\n        return (\n          withoutPhasePrompt.length > 0 ||\n          !msgContent.includes(\"<phase_prompt>\")\n        );\n      });\n\n      const updatedConversationHistory = [...filteredHistory];\n      const contentWithoutPhasePrompt = content\n        .replace(/<phase_prompt>.*?<\\/phase_prompt>/s, \"\")\n        .trim();\n\n      if (\n        contentWithoutPhasePrompt.length > 0 ||\n        !content.includes(\"<phase_prompt>\")\n      ) {\n        updatedConversationHistory.push({ role, content });\n      }\n\n      operations.forEach(\n        (operation: MessageFileOperation | MessageCommandOperation) => {\n          if (!operation.timestamp) {\n            operation.timestamp = Date.now();\n          }\n\n          if (operation.type === \"execute_command\") {\n            const existingOperation = updatedCommandOperations.get(\n              operation.command,\n            );\n            if (!existingOperation || existingOperation.success !== true) {\n              updatedCommandOperations.set(operation.command, {\n                ...operation,\n                ...existingOperation,\n              });\n            }\n          } else {\n            const existingOperation = updatedFileOperations.get(operation.path);\n            if (!existingOperation || existingOperation.success !== true) {\n              updatedFileOperations.set(operation.path, {\n                ...operation,\n                ...existingOperation,\n              });\n            }\n          }\n        },\n      );\n\n      return {\n        ...contextData,\n        phaseInstructions: updatedPhaseInstructions,\n        conversationHistory: updatedConversationHistory,\n        fileOperations: updatedFileOperations,\n        commandOperations: updatedCommandOperations,\n      };\n    } catch (error: any) {\n      if (error instanceof MessageContextError) {\n        throw error;\n      }\n      throw new MessageContextError(\n        `Failed to build message context: ${error.message}`,\n      );\n    }\n  }\n\n  public updateOperationResult(\n    type: \"read_file\" | \"write_file\" | \"execute_command\",\n    identifier: string,\n    result: string,\n    contextData: IMessageContextData,\n    success?: boolean,\n    error?: string,\n  ): IMessageContextData {\n    try {\n      this.validateContextData(contextData);\n\n      if (!identifier) {\n        throw new MessageContextError(\"Operation identifier cannot be empty\");\n      }\n\n      const updatedFileOperations = new Map(contextData.fileOperations);\n      const updatedCommandOperations = new Map(contextData.commandOperations);\n\n      if (type === \"execute_command\") {\n        const existingOperation = updatedCommandOperations.get(identifier);\n        if (existingOperation && existingOperation.success === true) {\n          return contextData;\n        }\n\n        const operation = existingOperation || {\n          type: \"execute_command\",\n          command: identifier,\n          timestamp: Date.now(),\n        };\n\n        updatedCommandOperations.set(identifier, {\n          ...operation,\n          output: result,\n          success,\n          error,\n        });\n      } else {\n        const existingOperation = updatedFileOperations.get(identifier);\n        if (existingOperation && existingOperation.success === true) {\n          return contextData;\n        }\n\n        const operation = existingOperation || {\n          type,\n          path: identifier,\n          timestamp: Date.now(),\n        };\n\n        updatedFileOperations.set(identifier, {\n          ...operation,\n          content: result,\n          success,\n          error,\n        });\n      }\n\n      return {\n        ...contextData,\n        fileOperations: updatedFileOperations,\n        commandOperations: updatedCommandOperations,\n        phaseInstructions: new Map(contextData.phaseInstructions),\n        conversationHistory: [...contextData.conversationHistory],\n      };\n    } catch (error: any) {\n      if (error instanceof MessageContextError) {\n        throw error;\n      }\n      throw new MessageContextError(\n        `Failed to update operation result: ${error.message}`,\n      );\n    }\n  }\n\n  public getMessageContext(\n    contextData: IMessageContextData,\n  ): IConversationHistoryMessage[] {\n    const phaseInstructions = contextData.phaseInstructions ?? new Map();\n    const fileOperations = contextData.fileOperations ?? new Map();\n    const commandOperations = contextData.commandOperations ?? new Map();\n    const conversationHistory = contextData.conversationHistory ?? [];\n\n    const result: IConversationHistoryMessage[] = [];\n\n    const currentPhaseInstructions = Array.from(\n      phaseInstructions.values(),\n    ).sort((a, b) => b.timestamp - a.timestamp)[0];\n\n    if (currentPhaseInstructions) {\n      result.push({\n        role: \"system\",\n        content: `<phase_prompt>${currentPhaseInstructions.content}</phase_prompt>`,\n      });\n    }\n\n    const criticalOperations: MessageOperation[] = [\n      ...Array.from(fileOperations.values()),\n      ...Array.from(commandOperations.values()),\n    ]\n      .filter((op) => !op.success || op.error)\n      .sort((a, b) => a.timestamp - b.timestamp);\n\n    for (const operation of criticalOperations) {\n      if (\"command\" in operation) {\n        const status = operation.success === false ? \"FAILED\" : \"PENDING\";\n        const errorInfo = operation.error ? ` (Error: ${operation.error})` : \"\";\n        result.push({\n          role: \"system\",\n          content: `Command: ${operation.command} [${status}${errorInfo}]`,\n        });\n      }\n    }\n\n    const successfulOperations = [\n      ...Array.from(fileOperations.values()),\n      ...Array.from(commandOperations.values()),\n    ]\n      .filter((op) => op.success === true && !op.error)\n      .sort((a, b) => a.timestamp - b.timestamp);\n\n    for (const operation of successfulOperations) {\n      if (\"command\" in operation) {\n        result.push({\n          role: \"assistant\",\n          content: `Command: ${operation.command}`,\n        });\n      } else {\n        if (operation.content && operation.content.length > 0) {\n          result.push({\n            role: \"assistant\",\n            content: `Content of ${operation.path}:\\n${operation.content}`,\n          });\n        }\n      }\n    }\n\n    const userAssistantMessages = conversationHistory.filter(\n      (msg) =>\n        msg.role !== \"system\" ||\n        (!msg.content.includes(\"Content of\") &&\n          !msg.content.includes(\"Command:\") &&\n          !msg.content.includes(\"Command executed:\") &&\n          !msg.content.includes(\"FILE CREATED AND EXISTS:\") &&\n          !msg.content.includes(\"Written to\") &&\n          msg.content !== contextData.systemInstructions),\n    );\n\n    result.push(...userAssistantMessages);\n\n    return result;\n  }\n\n  public getLatestPhaseInstructions(\n    contextData: IMessageContextData,\n  ): string | null {\n    const instructions = Array.from(\n      contextData.phaseInstructions.values(),\n    ).sort((a, b) => b.timestamp - a.timestamp)[0];\n    return instructions?.content ?? null;\n  }\n\n  public getFileOperation(\n    path: string,\n    contextData: IMessageContextData,\n  ): MessageFileOperation | undefined {\n    return contextData.fileOperations.get(path);\n  }\n\n  public getCommandOperation(\n    command: string,\n    contextData: IMessageContextData,\n  ): MessageCommandOperation | undefined {\n    return contextData.commandOperations.get(command);\n  }\n\n  private validateContent(content: string): void {\n    if (!content || content.trim() === \"\") {\n      throw new MessageContextError(\"Content cannot be empty\");\n    }\n  }\n\n  private validateRole(role: string): void {\n    if (![\"user\", \"assistant\", \"system\"].includes(role)) {\n      throw new MessageContextError(`Invalid role: ${role}`);\n    }\n  }\n\n  private validateContextData(contextData: IMessageContextData): void {\n    if (!contextData) {\n      throw new MessageContextError(\"Context data cannot be null or undefined\");\n    }\n    if (!contextData.conversationHistory) {\n      throw new MessageContextError(\n        \"Conversation history cannot be null or undefined\",\n      );\n    }\n    if (!contextData.fileOperations) {\n      throw new MessageContextError(\n        \"File operations cannot be null or undefined\",\n      );\n    }\n    if (!contextData.commandOperations) {\n      throw new MessageContextError(\n        \"Command operations cannot be null or undefined\",\n      );\n    }\n    if (!contextData.phaseInstructions) {\n      throw new MessageContextError(\n        \"Phase instructions cannot be null or undefined\",\n      );\n    }\n  }\n\n  private isValidPhasePrompt(prompt: string): boolean {\n    const contentMatch = prompt.match(/<phase_prompt>(.*?)<\\/phase_prompt>/s);\n    return !!contentMatch?.[1]?.trim();\n  }\n\n  private extractPhasePromptContent(prompt: string): string {\n    const contentMatch = prompt.match(/<phase_prompt>(.*?)<\\/phase_prompt>/s);\n    return contentMatch?.[1]?.trim() ?? \"\";\n  }\n}\n","import { singleton } from \"tsyringe\";\nimport {\n  MessageCommandOperation,\n  MessageFileOperation,\n} from \"./MessageContextStore\";\n\ntype MessageOperation = MessageFileOperation | MessageCommandOperation;\n\n@singleton()\nexport class MessageContextExtractor {\n  public extractNonOperationContent(content: string): string {\n    return content\n      .replace(/<read_file>[\\s\\S]*?<\\/read_file>/g, \"\")\n      .replace(/<write_file>[\\s\\S]*?<\\/write_file>/g, \"\")\n      .replace(/<execute_command>[\\s\\S]*?<\\/execute_command>/g, \"\")\n      .replace(/<phase_prompt>[\\s\\S]*?<\\/phase_prompt>/g, \"\")\n      .replace(/\\s+/g, \" \")\n      .trim();\n  }\n\n  public extractOperations(content: string): MessageOperation[] {\n    const operations: MessageOperation[] = [];\n    const now = Date.now();\n\n    // Extract read_file operations\n    const readMatches = Array.from(\n      content.matchAll(/<read_file>[\\s\\S]*?<path>(.*?)<\\/path>/g),\n    );\n    readMatches.forEach((match) => {\n      if (match[1]) {\n        operations.push({\n          type: \"read_file\",\n          path: match[1],\n          timestamp: now,\n        });\n      }\n    });\n\n    // Extract write_file operations\n    const writeMatches = Array.from(\n      content.matchAll(/<write_file>[\\s\\S]*?<path>(.*?)<\\/path>/g),\n    );\n    writeMatches.forEach((match) => {\n      if (match[1]) {\n        operations.push({\n          type: \"write_file\",\n          path: match[1],\n          timestamp: now,\n        });\n      }\n    });\n\n    // Extract execute_command operations\n    const commandMatches = Array.from(\n      content.matchAll(/<execute_command>[\\s\\S]*?<command>(.*?)<\\/command>/g),\n    );\n    commandMatches.forEach((match) => {\n      if (match[1]) {\n        operations.push({\n          type: \"execute_command\",\n          command: match[1],\n          timestamp: now,\n        });\n      }\n    });\n\n    return operations;\n  }\n\n  public extractPhasePrompt(content: string): string | null {\n    const match = content.match(/<phase_prompt>([\\s\\S]*?)<\\/phase_prompt>/);\n    return match ? match[1].trim() : null;\n  }\n}\n","import { ConfigService } from \"@services/ConfigService\";\nimport { IConversationHistoryMessage } from \"@services/LLM/ILLMProvider\";\nimport { DebugLogger } from \"@services/logging/DebugLogger\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { inject, singleton } from \"tsyringe\";\nimport { MessageContextBuilder } from \"./MessageContextBuilder\";\nimport { MessageContextStore } from \"./MessageContextStore\";\n\nexport interface MessageIActionResult {\n  success: boolean;\n  error?: Error;\n  result?: string;\n}\n\n@singleton()\nexport class MessageContextLogger {\n  private readonly logDirectory: string;\n  private readonly conversationLogPath: string;\n  private readonly conversationHistoryPath: string;\n  private readonly logLock: Promise<void>;\n  private isLogging: boolean;\n\n  constructor(\n    private debugLogger: DebugLogger,\n    private configService: ConfigService,\n    @inject(MessageContextBuilder)\n    private messageContextBuilder: MessageContextBuilder,\n    @inject(MessageContextStore)\n    private messageContextStore: MessageContextStore,\n  ) {\n    this.logDirectory = this.getLogDirectory();\n    this.conversationLogPath = path.join(\n      process.cwd(),\n      this.logDirectory,\n      \"conversation.log\",\n    );\n    this.conversationHistoryPath = path.join(\n      process.cwd(),\n      this.logDirectory,\n      \"conversationHistory.json\",\n    );\n    this.isLogging = false;\n    this.logLock = Promise.resolve();\n    this.ensureLogDirectoryExists();\n    this.ensureHistoryFileExists();\n  }\n\n  private getLogDirectory(): string {\n    const config = this.configService.getConfig();\n    return config.logDirectory || \"logs\";\n  }\n\n  private async acquireLogLock(): Promise<void> {\n    while (this.isLogging) {\n      await new Promise((resolve) => setTimeout(resolve, 10));\n    }\n    this.isLogging = true;\n  }\n\n  private releaseLogLock(): void {\n    this.isLogging = false;\n  }\n\n  private ensureLogDirectoryExists(): void {\n    const logDir = path.dirname(this.conversationLogPath);\n    if (!fs.existsSync(logDir)) {\n      fs.mkdirSync(logDir, { recursive: true });\n    }\n  }\n\n  private ensureHistoryFileExists(): void {\n    try {\n      if (!fs.existsSync(this.conversationHistoryPath)) {\n        fs.writeFileSync(this.conversationHistoryPath, \"[]\", \"utf8\");\n        this.debugLogger.log(\n          \"MessageLogger\",\n          \"Created conversation history file\",\n          { path: this.conversationHistoryPath },\n        );\n      }\n    } catch (error) {\n      this.debugLogger.log(\n        \"MessageLogger\",\n        \"Error creating conversation history file\",\n        { error, path: this.conversationHistoryPath },\n      );\n    }\n  }\n\n  async cleanupLogFiles(): Promise<void> {\n    try {\n      await this.acquireLogLock();\n      this.ensureLogDirectoryExists();\n      fs.writeFileSync(this.conversationLogPath, \"\", \"utf8\");\n      fs.writeFileSync(this.conversationHistoryPath, \"[]\", \"utf8\");\n      this.debugLogger.log(\"MessageLogger\", \"Log files cleaned up\", {\n        logDirectory: this.logDirectory,\n      });\n    } catch (error) {\n      this.debugLogger.log(\"MessageLogger\", \"Error cleaning up log files\", {\n        error,\n        logDirectory: this.logDirectory,\n      });\n    } finally {\n      this.releaseLogLock();\n    }\n  }\n\n  async logMessage(message: IConversationHistoryMessage): Promise<void> {\n    try {\n      await this.acquireLogLock();\n      this.ensureLogDirectoryExists();\n      this.ensureHistoryFileExists();\n      const timestamp = new Date().toISOString();\n      const logEntry = `[${timestamp}] ${message.role}: ${message.content}\\n`;\n      fs.appendFileSync(this.conversationLogPath, logEntry, \"utf8\");\n      this.debugLogger.log(\"MessageLogger\", \"Message logged\", { message });\n    } catch (error) {\n      this.debugLogger.log(\"MessageLogger\", \"Error writing to log file\", {\n        error,\n        logDirectory: this.logDirectory,\n      });\n    } finally {\n      this.releaseLogLock();\n    }\n  }\n\n  async logActionResult(\n    action: string,\n    result: MessageIActionResult,\n  ): Promise<void> {\n    try {\n      await this.acquireLogLock();\n      this.ensureLogDirectoryExists();\n      this.ensureHistoryFileExists();\n      const timestamp = new Date().toISOString();\n      const status = result.success ? \"SUCCESS\" : \"FAILED\";\n      const details = result.error\n        ? ` - Error: ${result.error.message}`\n        : result.result\n          ? ` - ${result.result}`\n          : \"\";\n      const logEntry = `[${timestamp}] ACTION ${action}: ${status}${details}\\n`;\n      fs.appendFileSync(this.conversationLogPath, logEntry, \"utf8\");\n\n      // Update operation result in context\n      const contextData = this.messageContextStore.getContextData();\n      const updatedContextData =\n        this.messageContextBuilder.updateOperationResult(\n          action as any,\n          action,\n          result.result || \"\",\n          contextData,\n          result.success,\n          result.error?.message,\n        );\n      this.messageContextStore.setContextData(updatedContextData);\n    } catch (error) {\n      this.debugLogger.log(\n        \"MessageLogger\",\n        \"Error writing action result to log file\",\n        { error, logDirectory: this.logDirectory },\n      );\n    } finally {\n      this.releaseLogLock();\n    }\n  }\n\n  async updateConversationHistory(\n    messages: IConversationHistoryMessage[],\n    systemInstructions: string | null,\n  ): Promise<void> {\n    try {\n      await this.acquireLogLock();\n      this.ensureLogDirectoryExists();\n      this.ensureHistoryFileExists();\n\n      if (systemInstructions) {\n        const timestamp = new Date().toISOString();\n        fs.appendFileSync(\n          this.conversationLogPath,\n          `[${timestamp}] system: ${systemInstructions}\\n`,\n          \"utf8\",\n        );\n      }\n\n      for (const message of messages) {\n        const timestamp = new Date().toISOString();\n        fs.appendFileSync(\n          this.conversationLogPath,\n          `[${timestamp}] ${message.role}: ${message.content}\\n`,\n          \"utf8\",\n        );\n      }\n\n      const historyData = {\n        timestamp: new Date().toISOString(),\n        systemInstructions,\n        messages,\n      };\n\n      fs.writeFileSync(\n        this.conversationHistoryPath,\n        JSON.stringify(historyData, null, 2),\n        \"utf8\",\n      );\n\n      this.debugLogger.log(\"MessageLogger\", \"Conversation history updated\", {\n        messagesCount: messages.length,\n        hasSystemInstructions: !!systemInstructions,\n        logDirectory: this.logDirectory,\n      });\n    } catch (error) {\n      this.debugLogger.log(\"MessageLogger\", \"Error updating log files\", {\n        error,\n        logDirectory: this.logDirectory,\n      });\n    } finally {\n      this.releaseLogLock();\n    }\n  }\n\n  getLogDirectoryPath(): string {\n    return this.logDirectory;\n  }\n\n  getConversationLogPath(): string {\n    return this.conversationLogPath;\n  }\n\n  getConversationHistoryPath(): string {\n    return this.conversationHistoryPath;\n  }\n\n  async getConversationHistory(): Promise<IConversationHistoryMessage[]> {\n    try {\n      await this.acquireLogLock();\n      const historyData = fs.readFileSync(this.conversationHistoryPath, \"utf8\");\n      return JSON.parse(historyData).messages;\n    } catch (error) {\n      this.debugLogger.log(\n        \"MessageLogger\",\n        \"Error reading conversation history\",\n        { error, logDirectory: this.logDirectory },\n      );\n      return [];\n    } finally {\n      this.releaseLogLock();\n    }\n  }\n}\n","import { IConversationHistoryMessage } from \"@services/LLM/ILLMProvider\";\nimport { delay, inject, singleton } from \"tsyringe\";\nimport { MessageContextTokenCount } from \"./MessageContextTokenCount\";\n\nexport interface BaseOperation {\n  timestamp: number;\n  success?: boolean;\n  error?: string;\n}\n\nexport interface MessageFileOperation extends BaseOperation {\n  type: \"read_file\" | \"write_file\";\n  path: string;\n  content?: string;\n}\n\nexport interface MessageCommandOperation extends BaseOperation {\n  type: \"execute_command\";\n  command: string;\n  output?: string;\n}\n\nexport interface MessagePhaseInstruction {\n  phase: string;\n  content: string;\n  timestamp: number;\n}\n\nexport interface IMessageContextData {\n  phaseInstructions: Map<string, MessagePhaseInstruction>;\n  fileOperations: Map<string, MessageFileOperation>;\n  commandOperations: Map<string, MessageCommandOperation>;\n  conversationHistory: IConversationHistoryMessage[];\n  systemInstructions: string | null;\n}\n\n@singleton()\nexport class MessageContextStore {\n  private contextData: IMessageContextData = {\n    phaseInstructions: new Map(),\n    fileOperations: new Map(),\n    commandOperations: new Map(),\n    conversationHistory: [],\n    systemInstructions: null,\n  };\n\n  constructor(\n    @inject(delay(() => MessageContextTokenCount))\n    private messageContextTokenCount: MessageContextTokenCount,\n  ) {}\n\n  public getContextData(): IMessageContextData {\n    return this.contextData;\n  }\n\n  public setContextData(data: Partial<IMessageContextData>): void {\n    this.contextData = {\n      phaseInstructions: this.getUpdatedPhaseInstructions(data),\n      fileOperations: this.getUpdatedOperations(\n        data.fileOperations,\n        this.contextData.fileOperations,\n      ),\n      commandOperations: this.getUpdatedOperations(\n        data.commandOperations,\n        this.contextData.commandOperations,\n      ),\n      conversationHistory: this.getUpdatedValue(\n        data.conversationHistory,\n        this.contextData.conversationHistory,\n      ),\n      systemInstructions: this.getUpdatedValue(\n        data.systemInstructions,\n        this.contextData.systemInstructions,\n      ),\n    };\n  }\n\n  public clear(): void {\n    this.contextData = {\n      phaseInstructions: new Map(),\n      fileOperations: new Map(),\n      commandOperations: new Map(),\n      conversationHistory: [],\n      systemInstructions: null,\n    };\n  }\n\n  public getTotalTokenCount(): number {\n    return this.messageContextTokenCount.getTotalTokenCount();\n  }\n\n  private getUpdatedPhaseInstructions(\n    data: Partial<IMessageContextData>,\n  ): Map<string, any> {\n    if (data.phaseInstructions === undefined) {\n      return this.contextData.phaseInstructions;\n    }\n\n    const instructions = Array.from(data.phaseInstructions.values())\n      .sort((a, b) => b.timestamp - a.timestamp)\n      .slice(0, 1); // Keep only the latest instruction\n\n    return new Map(instructions.map((i) => [i.phase, i]));\n  }\n\n  private getUpdatedOperations<T>(\n    newOperations: Map<string, T> | undefined,\n    existingOperations: Map<string, T>,\n  ): Map<string, T> {\n    if (newOperations === undefined) {\n      return existingOperations;\n    }\n    return new Map([...newOperations]);\n  }\n\n  private getUpdatedValue<T>(newValue: T | undefined, existingValue: T): T {\n    return newValue !== undefined ? newValue : existingValue;\n  }\n}\n","import { IConversationHistoryMessage } from \"@services/LLM/ILLMProvider\";\nimport { encode } from \"gpt-tokenizer\";\nimport { delay, inject, singleton } from \"tsyringe\";\nimport { MessageContextStore } from \"./MessageContextStore\";\n\n@singleton()\nexport class MessageContextTokenCount {\n  constructor(\n    @inject(delay(() => MessageContextStore))\n    private messageContextStore: MessageContextStore,\n  ) {}\n\n  public estimateTokenCount(messages: IConversationHistoryMessage[]): number {\n    return messages.reduce((total, message) => {\n      // Add 4 tokens for message format overhead\n      return total + 4 + encode(message.content).length;\n    }, 0);\n  }\n\n  public estimateTokenCountForMessage(\n    message: IConversationHistoryMessage,\n  ): number {\n    // Add 4 tokens for message format overhead\n    return 4 + encode(message.content).length;\n  }\n\n  public estimateTokenCountForText(text: string): number {\n    return encode(text).length;\n  }\n\n  public getTotalTokenCount(): number {\n    const contextData = this.messageContextStore.getContextData();\n    let total = 0;\n    if (contextData.systemInstructions) {\n      total += this.estimateTokenCountForText(contextData.systemInstructions);\n    }\n    total += this.estimateTokenCount(contextData.conversationHistory);\n    return total;\n  }\n\n  // Alias for getTotalTokenCount for backward compatibility\n  public getTokenCount(): number {\n    return this.getTotalTokenCount();\n  }\n}\n","import { autoInjectable } from \"tsyringe\";\nimport { ActionTagsExtractor } from \"./ActionTagsExtractor\";\nimport { actionExplainerBlueprint } from \"./blueprints/actionExplainerBlueprint\";\nimport { ActionExplainer } from \"./core/ActionExplainer\";\nimport { BaseAction } from \"./core/BaseAction\";\nimport { IActionBlueprint } from \"./core/IAction\";\nimport { IActionResult } from \"./types/ActionTypes\";\n\n@autoInjectable()\nexport class ActionExplainerAction extends BaseAction {\n  constructor(\n    protected actionTagsExtractor: ActionTagsExtractor,\n    private actionExplainer: ActionExplainer,\n  ) {\n    super(actionTagsExtractor);\n  }\n\n  protected getBlueprint(): IActionBlueprint {\n    return actionExplainerBlueprint;\n  }\n\n  protected validateParams(params: Record<string, any>): string | null {\n    if (!params.action) {\n      return \"Missing required parameter: action\";\n    }\n    return null;\n  }\n\n  protected parseParams(content: string): Record<string, any> {\n    // Extract only the action name from inside the action tag\n    const actionMatch = content.match(/<action>(.*?)<\\/action>/s);\n    if (!actionMatch) {\n      return { action: null };\n    }\n    return { action: actionMatch[1].trim() };\n  }\n\n  protected async executeInternal(\n    params: Record<string, any>,\n  ): Promise<IActionResult> {\n    try {\n      const explanation = this.actionExplainer.explainAction(params.action);\n      return {\n        success: true,\n        data: explanation,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error as Error,\n      };\n    }\n  }\n}\n","import { autoInjectable } from \"tsyringe\";\nimport { actionsBlueprints } from \"./blueprints\";\n\n@autoInjectable()\nexport class ActionTagsExtractor {\n  private getParameterTags(): string[] {\n    // Get all parameter names from all action blueprints\n    const paramSet = new Set<string>();\n    const blueprints = Object.values(actionsBlueprints);\n\n    for (const blueprint of blueprints) {\n      blueprint.parameters?.forEach((param) => {\n        paramSet.add(param.name);\n      });\n    }\n\n    return Array.from(paramSet);\n  }\n\n  /**\n   * Validates if a tag has proper XML structure\n   * @param content Full text content to validate\n   * @returns Message indicating if structure is valid or what's wrong\n   */\n  validateStructure(content: string): string {\n    // Get implemented action tags dynamically\n    const actionTags = Object.keys(actionsBlueprints);\n\n    // First validate the outer action tags\n    for (const tag of actionTags) {\n      const openCount = (content.match(new RegExp(`<${tag}>`, \"g\")) || [])\n        .length;\n      const closeCount = (content.match(new RegExp(`</${tag}>`, \"g\")) || [])\n        .length;\n\n      if (openCount !== closeCount) {\n        return `We need to use proper tag structure, try again. Missing ${openCount > closeCount ? \"closing\" : \"opening\"} tag for <${tag}>.`;\n      }\n    }\n\n    // Then validate inner parameter tags\n    const parameterTags = this.getParameterTags();\n\n    for (const tag of parameterTags) {\n      const openCount = (content.match(new RegExp(`<${tag}>`, \"g\")) || [])\n        .length;\n      const closeCount = (content.match(new RegExp(`</${tag}>`, \"g\")) || [])\n        .length;\n\n      if (openCount !== closeCount) {\n        return `We need to use proper tag structure, try again. Missing ${openCount > closeCount ? \"closing\" : \"opening\"} tag for <${tag}>.`;\n      }\n    }\n\n    return \"\";\n  }\n\n  /**\n   * Extracts content from a single tag\n   * @param content Full text content\n   * @param tagName Name of the tag to extract\n   * @returns The content within the tag or null if not found\n   */\n  extractTag(content: string, tagName: string): string | string[] | null {\n    const regex = new RegExp(`<${tagName}>([\\\\s\\\\S]*?)</${tagName}>`, \"g\");\n    const matches = Array.from(content.matchAll(regex));\n\n    if (matches.length === 0) return null;\n    if (matches.length === 1) return matches[0][1].trim();\n    return matches.map((match) => match[1].trim());\n  }\n\n  /**\n   * Extracts content from multiple instances of the same tag\n   * @param content Full text content\n   * @param tagName Name of the tag to extract\n   * @returns Array of content within each instance of the tag\n   */\n  extractTags(content: string, tagName: string): string[] {\n    const regex = new RegExp(`<${tagName}>([\\\\s\\\\S]*?)</${tagName}>`, \"g\");\n    const matches = content.matchAll(regex);\n    return Array.from(matches).map((match) => match[1].trim());\n  }\n\n  /**\n   * Extracts content from a tag and splits it into lines\n   * @param content Full text content\n   * @param tagName Name of the tag to extract\n   * @returns Array of non-empty trimmed lines from the tag content\n   */\n  extractTagLines(content: string, tagName: string): string[] {\n    const tagContent = this.extractTag(content, tagName);\n    if (!tagContent || Array.isArray(tagContent)) return [];\n\n    return tagContent\n      .split(\"\\n\")\n      .map((line) => line.trim())\n      .filter(Boolean);\n  }\n\n  /**\n   * Extracts nested tags from within a parent tag\n   * @param content Full text content\n   * @param parentTag Parent tag name\n   * @param childTag string\n   * @returns Array of content within child tags, found within the parent tag\n   */\n  extractNestedTags(\n    content: string,\n    parentTag: string,\n    childTag: string,\n  ): string[] {\n    const parentContent = this.extractTag(content, parentTag);\n    if (!parentContent || Array.isArray(parentContent)) return [];\n\n    return this.extractTags(parentContent, childTag);\n  }\n\n  /**\n   * Extracts all instances of a tag with their complete content\n   * @param content Full text content\n   * @param tagName Name of the tag to extract\n   * @returns Array of complete tag contents including nested tags\n   */\n  extractAllTagsWithContent(content: string, tagName: string): string[] {\n    const regex = new RegExp(`<${tagName}>[\\\\s\\\\S]*?</${tagName}>`, \"g\");\n    const matches = content.match(regex);\n    return matches ? matches.map((match) => match.trim()) : [];\n  }\n}\n","import { autoInjectable } from \"tsyringe\";\nimport { ActionFactory } from \"./ActionFactory\";\nimport { IActionBlueprint, IActionParameter } from \"./IAction\";\n\n@autoInjectable()\nexport class ActionExplainer {\n  constructor(private actionFactory: ActionFactory) {}\n\n  explainAction(actionTag: string): string {\n    const blueprint = this.actionFactory.getBlueprint(actionTag);\n    if (!blueprint) {\n      return `Action ${actionTag} not found.`;\n    }\n\n    return this.formatActionExplanation(blueprint);\n  }\n\n  explainAllActions(): string {\n    const blueprints = this.actionFactory.getAllBlueprints();\n    return blueprints\n      .map((blueprint) => this.formatActionExplanation(blueprint))\n      .join(\"\\n\\n\");\n  }\n\n  private formatActionExplanation(blueprint: IActionBlueprint): string {\n    let explanation = `<${blueprint.tag}> ${blueprint.description}\\n`;\n\n    if (blueprint.parameters && blueprint.parameters.length > 0) {\n      explanation += \"\\nParameters:\\n\";\n      explanation += this.formatParameters(blueprint.parameters);\n    }\n\n    explanation += \"\\nUsage:\\n\";\n    explanation += blueprint.usageExplanation;\n\n    return explanation;\n  }\n\n  private formatParameters(parameters: IActionParameter[]): string {\n    return parameters\n      .map(\n        (param) =>\n          `- ${param.name}${param.required ? \" (required)\" : \" (optional)\"}: ${\n            param.description\n          }`,\n      )\n      .join(\"\\n\");\n  }\n}\n","import { autoInjectable, container } from \"tsyringe\";\nimport {\n  actionsBlueprints,\n  ActionTag,\n  getImplementedActions,\n} from \"../blueprints\";\nimport { IAction, IActionBlueprint } from \"./IAction\";\n\n@autoInjectable()\nexport class ActionFactory {\n  private blueprintCache: Map<string, IActionBlueprint> = new Map();\n  private instanceCache: Map<string, IAction> = new Map();\n\n  constructor() {\n    // Initialize blueprint cache with only implemented actions\n    const implementedActions = getImplementedActions();\n    implementedActions.forEach((tag) => {\n      const blueprint = actionsBlueprints[tag];\n      if (blueprint) {\n        this.blueprintCache.set(tag, blueprint);\n      }\n    });\n  }\n\n  getBlueprint(tag: string): IActionBlueprint | undefined {\n    return this.blueprintCache.get(tag);\n  }\n\n  getAllBlueprints(): IActionBlueprint[] {\n    return Array.from(this.blueprintCache.values());\n  }\n\n  createAction(tag: ActionTag): IAction | undefined {\n    // Check instance cache first\n    if (this.instanceCache.has(tag)) {\n      return this.instanceCache.get(tag);\n    }\n\n    const blueprint = this.getBlueprint(tag);\n    if (!blueprint || !blueprint.class) {\n      return undefined;\n    }\n\n    try {\n      // Create new instance using tsyringe container\n      const instance = container.resolve(blueprint.class) as IAction;\n      this.instanceCache.set(tag, instance);\n      return instance;\n    } catch (error) {\n      console.error(`Failed to create action instance for ${tag}:`, error);\n      return undefined;\n    }\n  }\n\n  validateParameters(tag: string, params: Record<string, any>): string | null {\n    const blueprint = this.getBlueprint(tag);\n    if (!blueprint) {\n      return `Unknown action type: ${tag}`;\n    }\n\n    if (!blueprint.parameters) {\n      return null;\n    }\n\n    for (const param of blueprint.parameters) {\n      if (param.required && !(param.name in params)) {\n        return `Missing required parameter: ${param.name}`;\n      }\n\n      if (param.validator && params[param.name] !== undefined) {\n        const isValid = param.validator(params[param.name]);\n        if (!isValid) {\n          return `Invalid value for parameter: ${param.name}`;\n        }\n      }\n    }\n\n    return null;\n  }\n}\n","import { ActionTagsExtractor } from \"../ActionTagsExtractor\";\nimport { IActionResult } from \"../types/ActionTypes\";\nimport { IAction, IActionBlueprint, IActionParameter } from \"./IAction\";\n\nexport abstract class BaseAction implements IAction {\n  constructor(protected actionTagsExtractor: ActionTagsExtractor) {}\n\n  protected abstract executeInternal(\n    params: Record<string, any>,\n  ): Promise<IActionResult>;\n  protected abstract validateParams(params: Record<string, any>): string | null;\n  protected abstract getBlueprint(): IActionBlueprint;\n\n  protected parseParams(content: string): Record<string, any> {\n    const blueprint = this.getBlueprint();\n    const paramNames =\n      blueprint.parameters?.map((p: IActionParameter) => p.name) || [];\n\n    const params: Record<string, any> = {};\n    for (const paramName of paramNames) {\n      const value = this.extractParamValue(content, paramName);\n      if (value !== null) {\n        params[paramName] = value;\n      }\n    }\n\n    return params;\n  }\n\n  // Allow actions to override this method for custom parameter extraction\n  protected extractParamValue(\n    content: string,\n    paramName: string,\n  ): string | string[] | null {\n    return this.actionTagsExtractor.extractTag(content, paramName);\n  }\n\n  async execute(content: string): Promise<IActionResult> {\n    try {\n      // Get blueprint for validation\n      const blueprint = this.getBlueprint();\n      if (!blueprint) {\n        return this.createErrorResult(\"Action blueprint not found\");\n      }\n\n      // Parse parameters from content\n      const params = this.parseParams(content);\n\n      // Validate parameters\n      const validationError = this.validateParams(params);\n      if (validationError) {\n        this.logError(validationError);\n        return this.createErrorResult(validationError);\n      }\n\n      // Execute action-specific logic\n      const result = await this.executeInternal(params);\n\n      // Log result for debugging\n      if (result.success) {\n        this.logSuccess(`Action executed successfully`);\n      } else {\n        this.logError(`Action execution failed: ${result.error?.message}`);\n      }\n\n      return result;\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      this.logError(errorMessage);\n      return this.createErrorResult(error as Error);\n    }\n  }\n\n  protected logError(message: string): void {\n    console.error(`🚫 ${this.getBlueprint().tag}: ${message}`);\n  }\n\n  protected logInfo(message: string): void {\n    console.log(`ℹ️ ${this.getBlueprint().tag}: ${message}`);\n  }\n\n  protected logSuccess(message: string): void {\n    console.log(`✅ ${this.getBlueprint().tag}: ${message}`);\n  }\n\n  protected createSuccessResult(data?: any): IActionResult {\n    return {\n      success: true,\n      data,\n    };\n  }\n\n  protected createErrorResult(error: string | Error): IActionResult {\n    const errorObj = typeof error === \"string\" ? new Error(error) : error;\n    return {\n      success: false,\n      error: errorObj,\n    };\n  }\n}\n","export enum ActionPriority {\n  /**\n   * Critical priority for actions that must be executed first\n   * Example: read_file when mixed with other actions\n   */\n  CRITICAL = 1,\n\n  /**\n   * High priority for actions that should be executed early\n   * Example: search operations, path lookups\n   */\n  HIGH = 2,\n\n  /**\n   * Medium priority for standard file operations\n   * Example: write_file, move_file, copy_file\n   */\n  MEDIUM = 3,\n\n  /**\n   * Low priority for actions that should be executed later\n   * Example: fetch_url, execute_command\n   */\n  LOW = 4,\n\n  /**\n   * Lowest priority for actions that should be executed last\n   * Example: end_task\n   */\n  LOWEST = 5,\n}\n","import { ActionExplainerAction } from \"../ActionExplainerAction\";\nimport { IActionBlueprint } from \"../core/IAction\";\nimport { ActionPriority } from \"../types/ActionPriority\";\n\nexport const actionExplainerBlueprint: IActionBlueprint = {\n  tag: \"action_explainer\",\n  class: ActionExplainerAction,\n  description: \"Get detailed explanation of how to use an action\",\n  usageExplanation: `The action_explainer helps you understand how to use other actions. Here are common use cases:\n\n1. Get help with a specific action:\n<action_explainer>\n  <action>write_file</action>\n</action_explainer>\n\n2. Learn about a new action:\n<action_explainer>\n  <action>git_diff</action>\n</action_explainer>\n\nNote:\n- Use when unsure about action syntax\n- Shows parameters and examples\n- Provides usage tips and notes\n- Available for all actions\n- Returns formatted explanation`,\n  priority: ActionPriority.HIGH,\n  canRunInParallel: true,\n  requiresProcessing: false,\n  parameters: [\n    {\n      name: \"action\",\n      required: true,\n      description:\n        \"The action tag to get explanation for (e.g. read_file, write_file)\",\n      validator: (value: unknown): value is string =>\n        typeof value === \"string\" && value.length > 0,\n    },\n  ],\n};\n","/* eslint-disable no-control-regex */\n\nimport { autoInjectable } from \"tsyringe\";\n\n/**\n * AnsiStripper Class\n *\n * This class provides functionality to remove ANSI escape codes from strings.\n */\n@autoInjectable()\nexport class AnsiStripper {\n  // Regular expression to match ANSI escape codes\n  private static readonly ansiRegex: RegExp = /\\x1B\\[[0-?]*[ -/]*[@-~]/g;\n\n  /**\n   * Strips ANSI escape codes from the input string.\n   *\n   * @param input - The string potentially containing ANSI escape codes.\n   * @returns The cleaned string without ANSI codes.\n   */\n  public strip(input: string): string {\n    if (typeof input !== \"string\") {\n      throw new TypeError(\"Input must be a string\");\n    }\n    return input.replace(AnsiStripper.ansiRegex, \"\");\n  }\n}\n","import { IActionResult } from \"@services/LLM/actions/types/ActionTypes\";\nimport { DebugLogger } from \"@services/logging/DebugLogger\";\nimport { AnsiStripper } from \"@services/text/AnsiStripper\";\nimport chalk from \"chalk\";\nimport { spawn, SpawnOptionsWithoutStdio } from \"child_process\";\nimport { autoInjectable } from \"tsyringe\";\nimport { ActionTagsExtractor } from \"./ActionTagsExtractor\";\nimport { commandActionBlueprint as blueprint } from \"./blueprints/commandActionBlueprint\";\nimport { BaseAction } from \"./core/BaseAction\";\nimport { IActionBlueprint } from \"./core/IAction\";\n\ninterface CommandParams {\n  command: string;\n}\n\n@autoInjectable()\nexport class CommandAction extends BaseAction {\n  constructor(\n    protected actionTagsExtractor: ActionTagsExtractor,\n    private debugLogger: DebugLogger,\n    private ansiStripper: AnsiStripper,\n  ) {\n    super(actionTagsExtractor);\n  }\n\n  protected getBlueprint(): IActionBlueprint {\n    return blueprint;\n  }\n\n  protected parseParams(content: string): Record<string, any> {\n    const tag = this.getBlueprint().tag;\n    const match = content.match(new RegExp(`<${tag}>[\\\\s\\\\S]*?<\\\\/${tag}>`));\n    if (!match) {\n      this.logError(\"Failed to parse command from content\");\n      return { command: \"\" };\n    }\n\n    // Extract the command from between the tags and trim whitespace\n    const command = match[0]\n      .replace(new RegExp(`^<${tag}>`), \"\")\n      .replace(new RegExp(`<\\\\/${tag}>$`), \"\")\n      .trim();\n\n    this.logInfo(`Parsed command: ${command}`);\n    return { command };\n  }\n\n  protected validateParams(params: Record<string, any>): string | null {\n    const { command } = params as CommandParams;\n\n    if (!command || command.trim().length === 0) {\n      return \"No valid command to execute\";\n    }\n\n    return null;\n  }\n\n  protected async executeInternal(\n    params: Record<string, any>,\n  ): Promise<IActionResult> {\n    try {\n      const { command } = params as CommandParams;\n      this.logInfo(`Executing command: ${command}`);\n      return this.executeCommand(command);\n    } catch (error) {\n      // Even on error, return success with the error message as output\n      return this.createSuccessResult((error as Error).message);\n    }\n  }\n\n  private isTestEnvironment(): boolean {\n    return (\n      process.env.NODE_ENV === \"test\" ||\n      process.env.JEST_WORKER_ID !== undefined\n    );\n  }\n\n  private async executeCommand(\n    command: string,\n    options?: SpawnOptionsWithoutStdio,\n  ): Promise<IActionResult> {\n    return new Promise((resolve) => {\n      const [cmd, ...args] = command.split(\" \");\n      const child = spawn(cmd, args, { ...options, shell: true });\n\n      let stdoutData = \"\";\n      let stderrData = \"\";\n      let isResolved = false;\n\n      // Buffers to handle partial ANSI codes\n      let stdoutBuffer = \"\";\n      let stderrBuffer = \"\";\n\n      // Handle standard output data\n      child.stdout.on(\"data\", (data: Buffer) => {\n        const chunk = data.toString();\n        stdoutBuffer += chunk;\n        const strippedChunk = this.ansiStripper.strip(stdoutBuffer);\n        stdoutData += strippedChunk;\n        stdoutBuffer = \"\"; // Reset buffer after processing\n\n        // Only stream to console if not in test environment\n        if (!this.isTestEnvironment()) {\n          process.stdout.write(chalk.green(chunk));\n        }\n      });\n\n      // Handle standard error data\n      child.stderr.on(\"data\", (data: Buffer) => {\n        const chunk = data.toString();\n        stderrBuffer += chunk;\n        const strippedChunk = this.ansiStripper.strip(stderrBuffer);\n        stderrData += strippedChunk;\n        stderrBuffer = \"\"; // Reset buffer after processing\n\n        // Only stream to console if not in test environment\n        if (!this.isTestEnvironment()) {\n          process.stderr.write(chalk.red(chunk));\n        }\n      });\n\n      const finalizeAndResolve = (exitCode: number | null = null) => {\n        if (!isResolved) {\n          isResolved = true;\n          // Process any remaining buffered data\n          if (stdoutBuffer) {\n            stdoutData += this.ansiStripper.strip(stdoutBuffer);\n          }\n          if (stderrBuffer) {\n            stderrData += this.ansiStripper.strip(stderrBuffer);\n          }\n\n          const extra = `CRITICAL: If you're unsure why the command failed prioritize read_file to get more context from files related to the failure and a better understanding of the problem, instead of jumping to write_file right away with a solution\n            \\n\\n If you're stuck with the same problem over and over TRY DIFFERENT SOLUTIONS, don't keep trying the same thing over and over again`;\n\n          // Add the exit code message if there's no output\n          const output = stdoutData + stderrData;\n          const combinedOutput =\n            (output || `Command completed with exit code ${exitCode}`) +\n            (exitCode === 1 ? extra : \"\");\n\n          this.debugLogger.log(\"CommandAction\", \"Command execution completed\", {\n            command,\n            exitCode,\n            output: combinedOutput,\n          });\n\n          resolve(this.createSuccessResult(combinedOutput));\n        }\n      };\n\n      child.on(\"close\", (code) => {\n        finalizeAndResolve(code);\n      });\n\n      child.on(\"error\", (error) => {\n        this.debugLogger.log(\"CommandAction\", \"Command execution error\", {\n          command,\n          error: error.message,\n        });\n        // Return success with error message as output\n        resolve(\n          this.createSuccessResult(`${error.message}: command not found`),\n        );\n      });\n    });\n  }\n}\n","import { CommandAction } from \"../CommandAction\";\nimport { IActionBlueprint } from \"../core/IAction\";\nimport { ActionPriority } from \"../types/ActionPriority\";\n\nexport const commandActionBlueprint: IActionBlueprint = {\n  tag: \"execute_command\",\n  class: CommandAction,\n  description: \"Executes a system command with output streaming\",\n  usageExplanation: `The execute_command action allows you to run system commands. Here are common use cases:\n\n1. Run tests:\n<execute_command>\nyarn test src/services/__tests__/MyService.test.ts\n</execute_command>\n\n2. Check types:\n<execute_command>\nyarn tsc\n</execute_command>\n\n3. List directory contents:\n<execute_command>\nls -la src/services\n</execute_command>\n\nNote:\n- Use project's package manager (yarn/npm)\n- Avoid installing packages without permission\n- Avoid destructive commands (rm -rf, etc)\n- Commands run in workspace root\n- Output is streamed back to you`,\n  priority: ActionPriority.LOW,\n  canRunInParallel: false,\n  requiresProcessing: true,\n  parameters: [], // No parameters since we extract command from tag content\n};\n","import {\n  IFileSearch,\n  IFileSearchResult,\n} from \"@services/FileManagement/types/FileManagementTypes\";\nimport fg from \"fast-glob\";\nimport fs from \"fs-extra\";\nimport Fuse from \"fuse.js\";\nimport path from \"path\";\nimport { autoInjectable } from \"tsyringe\";\nimport { DebugLogger } from \"../logging/DebugLogger\";\n\ninterface FileEntry {\n  fullPath: string;\n  name: string;\n  dir: string;\n}\n\n@autoInjectable()\nexport class FileSearch implements IFileSearch {\n  constructor(private debugLogger: DebugLogger) {}\n\n  private findAllMatches(text: string, searchStr: string): number[] {\n    const positions: number[] = [];\n    let pos = text.indexOf(searchStr);\n    while (pos !== -1) {\n      positions.push(pos);\n      pos = text.indexOf(searchStr, pos + 1);\n    }\n    return positions;\n  }\n\n  async findByPattern(\n    pattern: string,\n    directory: string,\n  ): Promise<IFileSearchResult[]> {\n    try {\n      const entries = await fg(pattern, {\n        cwd: directory,\n        dot: true,\n        absolute: true,\n      });\n\n      const results: IFileSearchResult[] = [];\n\n      for (const entry of entries) {\n        const content = await fs.readFile(entry, \"utf-8\");\n        const lines = content.split(\"\\n\");\n\n        results.push({\n          path: entry,\n          matches: lines.map((line, index) => ({\n            line: index + 1,\n            content: line,\n          })),\n        });\n      }\n\n      return results;\n    } catch (error) {\n      console.error(\"Error in findByPattern:\", error);\n      return [];\n    }\n  }\n\n  async findByContent(\n    searchContent: string,\n    directory: string,\n  ): Promise<IFileSearchResult[]> {\n    try {\n      const entries = await fg(\"**/*\", {\n        cwd: directory,\n        dot: true,\n        absolute: true,\n      });\n\n      const results: IFileSearchResult[] = [];\n      const searchTarget = searchContent.toLowerCase();\n\n      for (const entry of entries) {\n        try {\n          const stats = await fs.stat(entry);\n          if (!stats.isFile()) continue;\n\n          const content = await fs.readFile(entry, \"utf-8\");\n          const lines = content.split(\"\\n\");\n          const matches = [];\n\n          for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n            const lineToSearch = line.toLowerCase();\n\n            const positions = this.findAllMatches(lineToSearch, searchTarget);\n\n            for (const pos of positions) {\n              matches.push({\n                line: i + 1,\n                content: line,\n                position: pos,\n              });\n            }\n          }\n\n          if (matches.length > 0) {\n            results.push({\n              path: entry,\n              matches,\n            });\n          }\n        } catch (error) {\n          console.error(`Error processing file ${entry}:`, error);\n        }\n      }\n\n      return results;\n    } catch (error) {\n      console.error(\"Error in findByContent:\", error);\n      return [];\n    }\n  }\n\n  async findByName(name: string, directory: string): Promise<string[]> {\n    try {\n      const targetName = path.basename(name);\n      const targetDir = path.dirname(name);\n\n      this.debugLogger.log(\"FileSearch\", \"findByName input\", {\n        name,\n        targetName,\n        targetDir,\n        directory,\n      });\n\n      const entries = await fg(\"**/*\", {\n        cwd: directory,\n        dot: true,\n        absolute: true,\n        onlyFiles: true,\n      });\n\n      if (!entries.length) {\n        this.debugLogger.log(\"FileSearch\", \"No files found in directory\", {\n          directory,\n        });\n        return [];\n      }\n\n      const fileEntries: FileEntry[] = entries.map((entry) => ({\n        fullPath: entry,\n        name: path.basename(entry).toLowerCase(),\n        dir: path.dirname(entry),\n      }));\n\n      const searchName = targetName.toLowerCase();\n\n      // First try exact matches (case insensitive)\n      const exactMatches = fileEntries.filter((entry) => {\n        const entryName = entry.name;\n        return (\n          entryName === searchName ||\n          entryName === `${searchName}.txt` ||\n          entryName.startsWith(`${searchName}.`)\n        );\n      });\n\n      this.debugLogger.log(\"FileSearch\", \"exact matches\", exactMatches);\n\n      if (exactMatches.length > 0) {\n        return exactMatches\n          .sort((a, b) => {\n            // Prioritize exact matches\n            const aExact =\n              a.name === searchName || a.name === `${searchName}.txt`;\n            const bExact =\n              b.name === searchName || b.name === `${searchName}.txt`;\n            if (aExact !== bExact) return aExact ? -1 : 1;\n            return a.fullPath.length - b.fullPath.length;\n          })\n          .map((entry) => entry.fullPath);\n      }\n\n      // For fuzzy matching\n      const fuse = new Fuse<FileEntry>(fileEntries, {\n        includeScore: true,\n        threshold: 0.3, // Stricter threshold\n        minMatchCharLength: Math.min(3, searchName.length),\n        keys: [\n          { name: \"name\", weight: 1 }, // Only match on name\n        ],\n      });\n\n      const results = fuse.search(searchName);\n      this.debugLogger.log(\"FileSearch\", \"fuzzy search results\", results);\n\n      // Filter and sort results\n      return results\n        .filter((result) => {\n          if (!result.score) return false;\n          // Only accept very close matches\n          return result.score < 0.2 || result.item.name.includes(searchName);\n        })\n        .slice(0, 5) // Limit results\n        .map((result) => result.item.fullPath);\n    } catch (error) {\n      this.debugLogger.log(\"FileSearch\", \"Error in findByName\", { error });\n      return [];\n    }\n  }\n}\n","import fg from \"fast-glob\";\nimport fsExtra from \"fs-extra\";\nimport * as Fuse from \"fuse.js\";\nimport path from \"path\";\nimport { autoInjectable } from \"tsyringe\";\n\n/**\n * PathAdjuster Class\n *\n * This class is responsible for adjusting incorrect file paths by finding the closest matching existing path.\n * It uses fast-glob for efficient file discovery, Fuse.js for fuzzy matching, and fs-extra for file system operations.\n */\n@autoInjectable()\nexport class PathAdjuster {\n  private allFiles: string[] = [];\n  private fuse: Fuse.default<string>;\n  private initialized: boolean = false;\n  private initializationError: Error | null = null;\n  private baseDirectory: string = process.cwd();\n\n  constructor() {\n    const defaultFuzzyOptions: Fuse.IFuseOptions<string> = {\n      includeScore: true,\n      threshold: 0.4,\n    };\n\n    this.fuse = new Fuse.default([], defaultFuzzyOptions);\n\n    this.initialize().catch((error) => {\n      this.initializationError = error;\n      console.error(\"Failed to initialize PathAdjuster:\", error);\n    });\n  }\n\n  public async cleanup(): Promise<void> {\n    // No cleanup needed\n  }\n\n  public isInitialized(): boolean {\n    return this.initialized;\n  }\n\n  public getInitializationError(): Error | null {\n    return this.initializationError;\n  }\n\n  private async initialize(): Promise<void> {\n    try {\n      this.allFiles = await this.getAllFiles(this.baseDirectory);\n      this.fuse.setCollection(this.allFiles);\n      this.initialized = true;\n      this.initializationError = null;\n    } catch (error) {\n      this.initialized = false;\n      this.initializationError =\n        error instanceof Error ? error : new Error(String(error));\n      throw this.initializationError;\n    }\n  }\n\n  private async getAllFiles(dir: string): Promise<string[]> {\n    try {\n      const entries = await fg.sync(\"**/*\", {\n        cwd: dir,\n        absolute: true,\n        onlyFiles: true,\n        followSymbolicLinks: true,\n      });\n      return entries.map((filePath) => path.resolve(filePath));\n    } catch (error) {\n      throw new Error(\n        `Failed to fetch files: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  public findClosestMatch(\n    wrongPath: string,\n    threshold: number = 0.6,\n  ): string | null {\n    if (!this.initialized) {\n      throw new Error(\n        \"PathAdjuster not initialized. Check initialization status with isInitialized()\",\n      );\n    }\n\n    const absoluteWrongPath = path.resolve(this.baseDirectory, wrongPath);\n\n    const results = this.fuse.search(absoluteWrongPath, { limit: 1 });\n\n    if (results.length > 0) {\n      const bestMatch = results[0];\n      if (bestMatch.score !== undefined && bestMatch.score <= 1 - threshold) {\n        return bestMatch.item;\n      }\n    }\n\n    return null;\n  }\n\n  public validatePath(filePath: string): boolean {\n    try {\n      const exists = fsExtra.pathExistsSync(filePath);\n      if (!exists) return false;\n      \n      const stats = fsExtra.lstatSync(filePath);\n      return stats.isFile();\n    } catch (error) {\n      return false;\n    }\n  }\n\n  public async adjustPath(\n    wrongPath: string,\n    threshold: number = 0.6,\n  ): Promise<string | null> {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    const closestMatch = this.findClosestMatch(wrongPath, threshold);\n    if (closestMatch && this.validatePath(closestMatch)) {\n      return closestMatch;\n    }\n\n    return null;\n  }\n\n  public toRelativePath(absolutePath: string): string {\n    if (!path.isAbsolute(absolutePath)) {\n      const possiblePath = path.join(this.baseDirectory, absolutePath);\n      if (this.validatePath(possiblePath)) {\n        return absolutePath;\n      }\n    }\n\n    const normalizedPath = path.resolve(absolutePath);\n\n    if (!normalizedPath.startsWith(this.baseDirectory)) {\n      throw new Error(\"Path is outside the base directory\");\n    }\n\n    return path.relative(this.baseDirectory, normalizedPath);\n  }\n\n  public async refreshFilePaths(): Promise<void> {\n    try {\n      this.allFiles = await this.getAllFiles(this.baseDirectory);\n      this.fuse.setCollection(this.allFiles);\n    } catch (error) {\n      console.error(\"Error refreshing file paths:\", error);\n      throw error;\n    }\n  }\n}","import { FileSearch } from \"@services/FileManagement/FileSearch\";\nimport { PathAdjuster } from \"@services/FileManagement/PathAdjuster\";\nimport {\n  IFileOperationResult,\n  IFileOperations,\n  IFileStats,\n} from \"@services/FileManagement/types/FileManagementTypes\";\nimport { DebugLogger } from \"@services/logging/DebugLogger\";\nimport fs from \"fs-extra\";\nimport path from \"path\";\nimport { autoInjectable } from \"tsyringe\";\n\n@autoInjectable()\nexport class FileOperations implements IFileOperations {\n  constructor(\n    private pathAdjuster: PathAdjuster,\n    private fileSearch: FileSearch,\n    private debugLogger: DebugLogger,\n  ) {}\n\n  private async ensureInitialized(timeout: number = 5000): Promise<void> {\n    const startTime = Date.now();\n\n    // Wait for initialization if not already initialized\n    if (!this.pathAdjuster.isInitialized()) {\n      await new Promise<void>((resolve, reject) => {\n        const checkInit = () => {\n          if (this.pathAdjuster.isInitialized()) {\n            resolve();\n          } else if (Date.now() - startTime > timeout) {\n            reject(new Error(\"PathAdjuster initialization timed out\"));\n          } else {\n            setTimeout(checkInit, 10);\n          }\n        };\n        checkInit();\n      });\n    }\n\n    // Check for initialization errors\n    const error = this.pathAdjuster.getInitializationError();\n    if (error) {\n      throw error;\n    }\n  }\n\n  async getAdjustedPath(filePath: string): Promise<string> {\n    await this.ensureInitialized();\n    const adjustedPath = await this.pathAdjuster.adjustPath(filePath);\n    return adjustedPath || filePath;\n  }\n\n  private async adjustPath(\n    filePath: string,\n    isRead: boolean = false,\n  ): Promise<string> {\n    await this.ensureInitialized();\n\n    // If path exists, return as is\n    if (await fs.pathExists(filePath)) {\n      return filePath;\n    }\n\n    // Only perform fuzzy search for read operations\n    if (isRead) {\n      const similarFiles = await this.fileSearch.findByName(\n        path.basename(filePath),\n        process.cwd(),\n      );\n\n      if (similarFiles.length > 0) {\n        const bestMatch = similarFiles[0];\n        // Additional validation for the best match\n        if (await fs.pathExists(bestMatch)) {\n          const stats = await fs.stat(bestMatch);\n          if (stats.isFile()) {\n            this.debugLogger.log(\n              \"FileOperations\",\n              `Found similar file: ${bestMatch} for ${filePath}`,\n              { confidence: \"high\", originalPath: filePath },\n            );\n            return bestMatch;\n          }\n        }\n      }\n    }\n\n    // If no similar files found or not a read operation, try PathAdjuster\n    const adjustedPath = await this.pathAdjuster.adjustPath(filePath);\n    if (adjustedPath && (await fs.pathExists(adjustedPath))) {\n      this.debugLogger.log(\n        \"FileOperations > PathAdjuster\",\n        `Adjusted path: ${adjustedPath}`,\n      );\n      return adjustedPath;\n    }\n\n    return filePath;\n  }\n\n  async read(filePath: string): Promise<IFileOperationResult> {\n    try {\n      const adjustedPath = await this.adjustPath(filePath, true);\n      if (!(await fs.pathExists(adjustedPath))) {\n        return {\n          success: false,\n          error: new Error(`File does not exist: ${filePath}`),\n        };\n      }\n      const content = await fs.readFile(adjustedPath, \"utf-8\");\n      return { success: true, data: content };\n    } catch (error) {\n      return { success: false, error: error as Error };\n    }\n  }\n\n  async readMultiple(filePaths: string[]): Promise<IFileOperationResult> {\n    try {\n      if (!filePaths?.length) {\n        return { success: false, error: new Error(\"No files provided\") };\n      }\n\n      const fileContents: string[] = [];\n      const errors: string[] = [];\n\n      for (const filePath of filePaths) {\n        try {\n          const adjustedPath = await this.adjustPath(filePath);\n          if (!(await fs.pathExists(adjustedPath))) {\n            errors.push(`${filePath}: File does not exist`);\n            continue;\n          }\n          const content = await fs.readFile(adjustedPath, \"utf-8\");\n          if (content) {\n            fileContents.push(`[File: ${adjustedPath}]\\n${content}`);\n          } else {\n            errors.push(`${adjustedPath}: Empty content`);\n          }\n        } catch (error) {\n          errors.push(`${filePath}: ${(error as Error).message}`);\n        }\n      }\n\n      if (errors.length > 0) {\n        return {\n          success: false,\n          error: new Error(\n            `Failed to read files: ${errors.join(\", \")}. Try using search_file action to find the proper path.`,\n          ),\n        };\n      }\n\n      return { success: true, data: fileContents.join(\"\\n\\n\") };\n    } catch (error) {\n      return { success: false, error: error as Error };\n    }\n  }\n\n  private async validateAndAdjustWritePath(filePath: string): Promise<{\n    adjustedPath: string;\n    isNewFile: boolean;\n  }> {\n    // For write operations, we want to be very strict\n    // Only use the exact path or create a new file\n    const absolutePath = path.resolve(process.cwd(), filePath);\n\n    // First check if file exists at exact path\n    if (await fs.pathExists(filePath)) {\n      return { adjustedPath: filePath, isNewFile: false };\n    }\n\n    // For new files, just ensure the path is within the project\n    const projectRoot = process.cwd();\n    if (!absolutePath.startsWith(projectRoot)) {\n      throw new Error(`File path must be within project root: ${projectRoot}`);\n    }\n\n    // This is a new file\n    return { adjustedPath: filePath, isNewFile: true };\n  }\n\n  async write(\n    filePath: string,\n    content: string | Buffer,\n  ): Promise<IFileOperationResult> {\n    try {\n      const { adjustedPath, isNewFile } =\n        await this.validateAndAdjustWritePath(filePath);\n\n      if (!isNewFile) {\n        this.debugLogger.log(\n          \"FileOperations\",\n          `Writing to existing file at: ${adjustedPath}`,\n        );\n      } else {\n        this.debugLogger.log(\n          \"FileOperations\",\n          `Creating new file at: ${adjustedPath}`,\n        );\n      }\n\n      await fs.ensureDir(path.dirname(adjustedPath));\n      await fs.writeFile(adjustedPath, content);\n      return { success: true };\n    } catch (error) {\n      return { success: false, error: error as Error };\n    }\n  }\n\n  async delete(filePath: string): Promise<IFileOperationResult> {\n    try {\n      const adjustedPath = await this.adjustPath(filePath);\n      if (!(await fs.pathExists(adjustedPath))) {\n        return {\n          success: false,\n          error: new Error(`File does not exist: ${filePath}`),\n        };\n      }\n      await fs.remove(adjustedPath);\n      return { success: true };\n    } catch (error) {\n      return { success: false, error: error as Error };\n    }\n  }\n\n  async copy(\n    source: string,\n    destination: string,\n  ): Promise<IFileOperationResult> {\n    try {\n      const adjustedSource = await this.adjustPath(source);\n      if (!(await fs.pathExists(adjustedSource))) {\n        return {\n          success: false,\n          error: new Error(`Source file does not exist: ${source}`),\n        };\n      }\n      await fs.ensureDir(path.dirname(destination));\n      await fs.copy(adjustedSource, destination);\n      return { success: true };\n    } catch (error) {\n      return { success: false, error: error as Error };\n    }\n  }\n\n  async move(\n    source: string,\n    destination: string,\n  ): Promise<IFileOperationResult> {\n    try {\n      const adjustedSource = await this.adjustPath(source);\n      if (!(await fs.pathExists(adjustedSource))) {\n        return {\n          success: false,\n          error: new Error(`Source file does not exist: ${source}`),\n        };\n      }\n      await fs.ensureDir(path.dirname(destination));\n      await fs.move(adjustedSource, destination, { overwrite: true });\n      return { success: true };\n    } catch (error) {\n      return { success: false, error: error as Error };\n    }\n  }\n\n  async exists(filePath: string): Promise<boolean> {\n    const adjustedPath = await this.adjustPath(filePath);\n    return fs.pathExists(adjustedPath);\n  }\n\n  async stats(filePath: string): Promise<IFileOperationResult> {\n    try {\n      const adjustedPath = await this.adjustPath(filePath);\n      if (!(await fs.pathExists(adjustedPath))) {\n        return {\n          success: false,\n          error: new Error(`File does not exist: ${filePath}`),\n        };\n      }\n      const stats = await fs.stat(adjustedPath);\n      const fileStats: IFileStats = {\n        size: stats.size,\n        createdAt: stats.birthtime,\n        modifiedAt: stats.mtime,\n        isDirectory: stats.isDirectory(),\n        path: adjustedPath,\n      };\n      return { success: true, data: fileStats };\n    } catch (error) {\n      return { success: false, error: error as Error };\n    }\n  }\n\n  async findSimilarFiles(filePath: string): Promise<string[]> {\n    return this.fileSearch.findByName(filePath, process.cwd());\n  }\n}\n","import { FileOperations } from \"@services/FileManagement/FileOperations\";\nimport { autoInjectable } from \"tsyringe\";\nimport { ActionTagsExtractor } from \"./ActionTagsExtractor\";\nimport { copyFileActionBlueprint as blueprint } from \"./blueprints/copyFileActionBlueprint\";\nimport { BaseAction } from \"./core/BaseAction\";\nimport { IActionBlueprint } from \"./core/IAction\";\nimport { IActionResult } from \"./types/ActionTypes\";\n\ninterface CopyFileParams {\n  source_path: string;\n  destination_path: string;\n}\n\n@autoInjectable()\nexport class CopyFileAction extends BaseAction {\n  constructor(\n    protected actionTagsExtractor: ActionTagsExtractor,\n    private fileOperations: FileOperations,\n  ) {\n    super(actionTagsExtractor);\n  }\n\n  protected getBlueprint(): IActionBlueprint {\n    return blueprint;\n  }\n\n  protected validateParams(params: Record<string, any>): string | null {\n    const { source_path, destination_path } = params as CopyFileParams;\n\n    if (!source_path) {\n      return \"No source path provided\";\n    }\n    if (!destination_path) {\n      return \"No destination path provided\";\n    }\n\n    return null;\n  }\n\n  async execute(content: string): Promise<IActionResult> {\n    // Validate XML structure first\n    const structureError = this.actionTagsExtractor.validateStructure(content);\n    if (structureError) {\n      return this.createErrorResult(structureError);\n    }\n\n    return super.execute(content);\n  }\n\n  protected async executeInternal(\n    params: Record<string, any>,\n  ): Promise<IActionResult> {\n    try {\n      const { source_path, destination_path } = params as CopyFileParams;\n\n      this.logInfo(`Source path: ${source_path}`);\n      this.logInfo(`Destination path: ${destination_path}`);\n\n      const result = await this.fileOperations.copy(\n        source_path,\n        destination_path,\n      );\n\n      if (!result.success) {\n        return this.createErrorResult(result.error!);\n      }\n\n      return this.createSuccessResult(result.data);\n    } catch (error) {\n      return this.createErrorResult(error as Error);\n    }\n  }\n}\n","import { CopyFileAction } from \"../CopyFileAction\";\nimport { IActionBlueprint } from \"../core/IAction\";\nimport { ActionPriority } from \"../types/ActionPriority\";\n\nexport const copyFileActionBlueprint: IActionBlueprint = {\n  tag: \"copy_file\",\n  class: CopyFileAction,\n  description: \"Copy a file from source to destination path\",\n  usageExplanation: `The copy_file action creates a copy of a file in a new location. Here are common use cases:\n\n1. Copy a file to a new location:\n<copy_file>\n  <source_path>src/services/OldService.ts</source_path>\n  <destination_path>src/services/NewService.ts</destination_path>\n</copy_file>\n\n2. Create a backup before modifying:\n<copy_file>\n  <source_path>src/config.ts</source_path>\n  <destination_path>src/config.backup.ts</destination_path>\n</copy_file>\n\nNote:\n- Use relative paths from workspace root\n- Destination directory must exist\n- Will overwrite destination if it exists\n- Preserves file permissions`,\n  priority: ActionPriority.MEDIUM,\n  canRunInParallel: true,\n  requiresProcessing: false,\n  parameters: [\n    {\n      name: \"source_path\",\n      required: true,\n      description: \"The source path of the file to copy\",\n      validator: (value: any) => typeof value === \"string\" && value.length > 0,\n    },\n    {\n      name: \"destination_path\",\n      required: true,\n      description: \"The destination path for the file copy\",\n      validator: (value: any) => typeof value === \"string\" && value.length > 0,\n    },\n  ],\n};\n","import { FileOperations } from \"@services/FileManagement/FileOperations\";\nimport { autoInjectable } from \"tsyringe\";\nimport { ActionTagsExtractor } from \"./ActionTagsExtractor\";\nimport { deleteFileActionBlueprint as blueprint } from \"./blueprints/deleteFileActionBlueprint\";\nimport { BaseAction } from \"./core/BaseAction\";\nimport { IActionBlueprint } from \"./core/IAction\";\nimport { IActionResult } from \"./types/ActionTypes\";\n\ninterface DeleteFileParams {\n  path: string;\n}\n\n@autoInjectable()\nexport class DeleteFileAction extends BaseAction {\n  constructor(\n    protected actionTagsExtractor: ActionTagsExtractor,\n    private fileOperations: FileOperations,\n  ) {\n    super(actionTagsExtractor);\n  }\n\n  protected getBlueprint(): IActionBlueprint {\n    return blueprint;\n  }\n\n  protected validateParams(params: Record<string, any>): string | null {\n    const { path } = params as DeleteFileParams;\n\n    if (typeof path !== \"string\" || !path.trim()) {\n      return \"Invalid or no file path provided\";\n    }\n\n    return null;\n  }\n\n  protected async executeInternal(\n    params: Record<string, any>,\n  ): Promise<IActionResult> {\n    try {\n      const { path: filePath } = params as DeleteFileParams;\n\n      this.logInfo(`Attempting to delete file at path: ${filePath}`);\n      const result = await this.fileOperations.delete(filePath);\n\n      if (!result.success) {\n        this.logError(`Failed to delete file at path: ${filePath}. Error: ${result.error}`);\n        return this.createErrorResult(result.error!);\n      }\n\n      this.logInfo(`Successfully deleted file at path: ${filePath}`);\n      return this.createSuccessResult(result.data);\n    } catch (error) {\n      const { path: filePath } = params as DeleteFileParams;\n      this.logError(`An unexpected error occurred while deleting file at path: ${filePath}. Error: ${error}`);\n      return this.createErrorResult(error as Error);\n    }\n  }\n\n  async execute(content: string): Promise<IActionResult> {\n    let params: DeleteFileParams;\n    try {\n      params = JSON.parse(content) as DeleteFileParams;\n    } catch (error) {\n      return this.createErrorResult(new Error(\"Invalid JSON content\"));\n    }\n\n    const validationError = this.validateParams(params);\n    if (validationError) {\n      return this.createErrorResult(new Error(validationError));\n    }\n\n    return this.executeInternal(params);\n  }\n}","import { IActionBlueprint } from \"../core/IAction\";\nimport { DeleteFileAction } from \"../DeleteFileAction\";\nimport { ActionPriority } from \"../types/ActionPriority\";\n\nexport const deleteFileActionBlueprint: IActionBlueprint = {\n  tag: \"delete_file\",\n  class: DeleteFileAction,\n  description: \"Delete a file at the specified path\",\n  usageExplanation: `The delete_file action permanently removes a file. Here are common use cases:\n\n1. Delete a specific file:\n<delete_file>\n  <path>src/services/OldService.ts</path>\n</delete_file>\n\n2. Delete a temporary file:\n<delete_file>\n  <path>src/config.backup.ts</path>\n</delete_file>\n\nNote:\n- Use relative paths from workspace root\n- Action is irreversible\n- File must exist\n- Consider backing up before deleting\n- Remove imports to deleted file`,\n  priority: ActionPriority.MEDIUM,\n  canRunInParallel: false,\n  requiresProcessing: false,\n  parameters: [\n    {\n      name: \"path\",\n      required: true,\n      description: \"The path of the file to delete\",\n      validator: (value: any) => typeof value === \"string\" && value.length > 0,\n    },\n  ],\n};\n","import { autoInjectable } from \"tsyringe\";\nimport { PhaseTransitionService } from \"../PhaseTransitionService\";\nimport { ActionTagsExtractor } from \"./ActionTagsExtractor\";\nimport { endPhaseActionBlueprint } from \"./blueprints/endPhaseActionBlueprint\";\nimport { BaseAction } from \"./core/BaseAction\";\nimport { IActionBlueprint } from \"./core/IAction\";\nimport { IActionResult } from \"./types/ActionTypes\";\n\n@autoInjectable()\nexport class EndPhaseAction extends BaseAction {\n  constructor(\n    actionTagsExtractor: ActionTagsExtractor,\n    private phaseTransitionService: PhaseTransitionService,\n  ) {\n    super(actionTagsExtractor);\n  }\n\n  protected async executeInternal(\n    params: Record<string, any>,\n  ): Promise<IActionResult> {\n    try {\n      const data = await this.phaseTransitionService.transitionToNextPhase();\n      return this.createSuccessResult(data);\n    } catch (error) {\n      return this.createErrorResult(error);\n    }\n  }\n\n  protected validateParams(params: Record<string, any>): string | null {\n    // No params to validate\n    return null;\n  }\n\n  protected getBlueprint(): IActionBlueprint {\n    return endPhaseActionBlueprint;\n  }\n}\n","import { injectable } from \"tsyringe\";\nimport { WriteActionData } from \"./actions/types/ActionTypes\";\nimport { MessageContextHistory } from \"./context/MessageContextHistory\";\nimport { MessageContextPhase } from \"./context/MessageContextPhase\";\nimport { ModelManager } from \"./ModelManager\";\nimport { PhaseManager } from \"./PhaseManager\";\nimport { Phase } from \"./types/PhaseTypes\";\n\n@injectable()\nexport class PhaseTransitionService {\n  constructor(\n    private phaseManager: PhaseManager,\n    private modelManager: ModelManager,\n    private messageContextPhase: MessageContextPhase,\n    private messageContextHistory: MessageContextHistory,\n  ) {}\n\n  async transitionToNextPhase(): Promise<WriteActionData> {\n    const currentPhase = this.phaseManager.getCurrentPhase();\n    const nextPhase = this.getNextPhase(currentPhase);\n\n    this.messageContextPhase.cleanupPhaseContent();\n\n    // Log phase transition with emojis\n    console.log(\n      `🔄 Phase Transition: ${this.getPhaseEmoji(currentPhase)}${currentPhase} ➡️ ${this.getPhaseEmoji(nextPhase)}${nextPhase}`,\n    );\n\n    // Move to next phase\n    this.phaseManager.nextPhase();\n\n    // Get the new phase's config\n    const nextPhaseConfig = this.phaseManager.getCurrentPhaseConfig();\n\n    // Update model for the new phase\n    await this.modelManager.setCurrentModel(nextPhaseConfig.model);\n\n    // Generate prompt but don't include it in the response\n    nextPhaseConfig.generatePrompt({\n      message: \"Continue with the next phase based on previous findings.\",\n    });\n\n    this.messageContextHistory.addMessage(\n      \"system\",\n      `Current phase is ${nextPhase}`,\n    );\n\n    return {\n      regenerate: true,\n      selectedModel: nextPhaseConfig.model,\n    };\n  }\n\n  private getNextPhase(currentPhase: Phase): Phase {\n    switch (currentPhase) {\n      case Phase.Discovery:\n        return Phase.Strategy;\n      case Phase.Strategy:\n        return Phase.Execute;\n      case Phase.Execute:\n        return Phase.Discovery;\n      default:\n        return Phase.Discovery;\n    }\n  }\n\n  private getPhaseEmoji(phase: Phase): string {\n    switch (phase) {\n      case Phase.Discovery:\n        return \"🔍 \";\n      case Phase.Strategy:\n        return \"🎯 \";\n      case Phase.Execute:\n        return \"⚡ \";\n      default:\n        return \"❓ \";\n    }\n  }\n}\n","// services/messageContext/MessageContextPhase.ts\nimport { autoInjectable, singleton } from \"tsyringe\";\nimport { MessageContextStore } from \"./MessageContextStore\";\n\nimport { MessageContextHistory } from \"./MessageContextHistory\";\n\n@singleton()\n@autoInjectable()\nexport class MessageContextPhase {\n  constructor(\n    private messageContextStore: MessageContextStore,\n    private messageContextHistory: MessageContextHistory,\n  ) {}\n\n  public cleanupPhaseContent(): void {\n    const currentData = this.messageContextStore.getContextData();\n\n    // Clear all previous phase instructions when transitioning\n    this.messageContextStore.setContextData({\n      phaseInstructions: new Map(),\n      fileOperations: new Map(currentData.fileOperations),\n      commandOperations: new Map(currentData.commandOperations),\n      conversationHistory: [...currentData.conversationHistory],\n      systemInstructions: currentData.systemInstructions,\n    });\n\n    this.messageContextHistory.updateLogFile();\n  }\n}\n","import { IActionBlueprint } from \"../core/IAction\";\nimport { EndPhaseAction } from \"../EndPhaseAction\";\nimport { ActionPriority } from \"../types/ActionPriority\";\n\nexport const endPhaseActionBlueprint: IActionBlueprint = {\n  tag: \"end_phase\",\n  class: EndPhaseAction,\n  description: \"Ends the current phase and transitions to the next phase\",\n  usageExplanation: `The end_phase action transitions to the next phase in the workflow. Here are common use cases:\n\n1. Move to strategy phase after discovery:\n<end_phase>\n  strategy_phase\n</end_phase>\n\n2. Move to execution phase after strategy:\n<end_phase>\n  execution_phase\n</end_phase>\n\nNote:\n- Use after gathering sufficient context\n- Only use when ready to move forward\n- Cannot go back to previous phase\n- Must be the last action in current phase\n- Valid phases: discovery_phase, strategy_phase, execution_phase`,\n  parameters: [],\n  requiresProcessing: true,\n  priority: ActionPriority.CRITICAL, // High priority to ensure phase transition happens before other actions\n};\n","import { autoInjectable } from \"tsyringe\";\nimport { ActionTagsExtractor } from \"./ActionTagsExtractor\";\nimport { endTaskActionBlueprint as blueprint } from \"./blueprints/endTaskActionBlueprint\";\nimport { BaseAction } from \"./core/BaseAction\";\nimport { IActionBlueprint } from \"./core/IAction\";\nimport { IActionResult } from \"./types/ActionTypes\";\n\n@autoInjectable()\nexport class EndTaskAction extends BaseAction {\n  constructor(protected actionTagsExtractor: ActionTagsExtractor) {\n    super(actionTagsExtractor);\n  }\n\n  protected getBlueprint(): IActionBlueprint {\n    return blueprint;\n  }\n\n  protected validateParams(params: Record<string, any>): string | null {\n    const content = params.content as string;\n\n    if (!content?.trim()) {\n      return \"No message provided\";\n    }\n\n    return null;\n  }\n\n  protected async executeInternal(\n    params: Record<string, any>,\n  ): Promise<IActionResult> {\n    const message = params.content as string;\n\n    this.logInfo(`End task message: ${message}`);\n    return this.createSuccessResult(message);\n  }\n\n  protected parseParams(content: string): Record<string, any> {\n    // Extract the content between the end_task tags\n    const match = content.match(/<end_task>([\\s\\S]*?)<\\/end_task>/);\n    return { content: match?.[1]?.trim() };\n  }\n}\n","import { IActionBlueprint } from \"../core/IAction\";\nimport { EndTaskAction } from \"../EndTaskAction\";\nimport { ActionPriority } from \"../types/ActionPriority\";\n\nexport const endTaskActionBlueprint: IActionBlueprint = {\n  tag: \"end_task\",\n  class: EndTaskAction,\n  description: \"Mark a task as complete with a message\",\n  usageExplanation: `The end_task action marks the current task as complete. Here are common use cases:\n\n1. Complete task with success message:\n<end_task>\nSuccessfully implemented new feature\n</end_task>\n\n2. Complete task with summary:\n<end_task>\nCreated UserService with authentication methods:\n- login()\n- logout()\n- validateToken()\nAll tests passing.\n</end_task>\n\nNote:\n- Use clear, concise messages\n- Include key accomplishments\n- Mention any follow-up tasks\n- Must be the last action\n- Task cannot be resumed after ending`,\n  priority: ActionPriority.LOWEST,\n  canRunInParallel: false,\n  requiresProcessing: false,\n  parameters: [],\n};\n","import axios, { AxiosResponse } from \"axios\";\nimport { autoInjectable } from \"tsyringe\";\nimport { ActionTagsExtractor } from \"./ActionTagsExtractor\";\nimport { fetchUrlActionBlueprint as blueprint } from \"./blueprints/fetchUrlActionBlueprint\";\nimport { BaseAction } from \"./core/BaseAction\";\nimport { IActionBlueprint } from \"./core/IAction\";\nimport { IActionResult } from \"./types/ActionTypes\";\n\ninterface FetchUrlParams {\n  url: string;\n}\n\n@autoInjectable()\nexport class FetchUrlAction extends BaseAction {\n  constructor(protected actionTagsExtractor: ActionTagsExtractor) {\n    super(actionTagsExtractor);\n  }\n\n  protected getBlueprint(): IActionBlueprint {\n    return blueprint;\n  }\n\n  protected validateParams(params: Record<string, any>): string | null {\n    const { url } = params as FetchUrlParams;\n\n    if (!url) {\n      return \"No URL provided\";\n    }\n\n    try {\n      new URL(url); // Validate URL format\n      return null;\n    } catch {\n      return \"Invalid URL format. Must be a valid URL with protocol (http:// or https://)\";\n    }\n  }\n\n  protected async executeInternal(\n    params: Record<string, any>,\n  ): Promise<IActionResult> {\n    try {\n      const { url } = params as FetchUrlParams;\n\n      this.logInfo(`Fetching URL: ${url}`);\n\n      const data = await this.fetchUrl(url);\n      return this.createSuccessResult(data);\n    } catch (error) {\n      return this.createErrorResult(\n        error instanceof Error ? error : new Error(\"Failed to fetch URL\"),\n      );\n    }\n  }\n\n  private async fetchUrl<T = any>(url: string): Promise<T> {\n    try {\n      const response: AxiosResponse<T> = await axios.get(url);\n      return response.data;\n    } catch (error: any) {\n      if (axios.isAxiosError(error)) {\n        throw new Error(`Network error: ${error.message}`);\n      }\n      throw new Error(`Error fetching URL: ${error.message}`);\n    }\n  }\n}\n","import { IActionBlueprint } from \"../core/IAction\";\nimport { FetchUrlAction } from \"../FetchUrlAction\";\nimport { ActionPriority } from \"../types/ActionPriority\";\n\nexport const fetchUrlActionBlueprint: IActionBlueprint = {\n  tag: \"fetch_url\",\n  class: FetchUrlAction,\n  description: \"Fetch content from a URL\",\n  usageExplanation: `The fetch_url action allows you to retrieve content from URLs. Here are common use cases:\n\n1. Fetch JSON data:\n<fetch_url>\n  <url>https://api.example.com/data.json</url>\n</fetch_url>\n\n2. Fetch documentation:\n<fetch_url>\n  <url>https://docs.example.com/guide</url>\n</fetch_url>\n\nNote:\n- URL must start with http:// or https://\n- Only use trusted domains\n- Response is returned as text\n- Large responses may be truncated\n- Handle errors appropriately`,\n  priority: ActionPriority.LOW,\n  canRunInParallel: true,\n  requiresProcessing: true,\n  parameters: [\n    {\n      name: \"url\",\n      required: true,\n      description: \"The URL to fetch content from\",\n      validator: (value: any) =>\n        typeof value === \"string\" &&\n        value.length > 0 &&\n        (value.startsWith(\"http://\") || value.startsWith(\"https://\")),\n    },\n  ],\n};\n","import simpleGit, {\n  DefaultLogFields,\n  LogResult,\n  SimpleGit,\n  StatusResult,\n} from \"simple-git\";\nimport { autoInjectable } from \"tsyringe\";\n\n@autoInjectable()\nexport class GitService {\n  private git: SimpleGit;\n\n  constructor() {\n    this.git = simpleGit();\n  }\n\n  async getDiff(\n    fromCommit: string,\n    toCommit: string,\n    excludePattern?: string,\n  ): Promise<string> {\n    const args = [];\n\n    // Add the commit range\n    args.push(fromCommit);\n    args.push(toCommit);\n\n    // Add exclude patterns if any\n    if (excludePattern) {\n      args.push(...excludePattern.split(\" \"));\n    }\n\n    return await this.git.diff(args);\n  }\n\n  async getStatus(): Promise<StatusResult> {\n    return await this.git.status();\n  }\n\n  async getPRDiff(\n    baseBranch: string,\n    compareBranch: string,\n    excludePattern?: string,\n  ): Promise<string> {\n    const args = [];\n\n    // Add the branch range\n    args.push(baseBranch);\n    args.push(compareBranch);\n\n    // Add exclude patterns if any\n    if (excludePattern) {\n      args.push(...excludePattern.split(\" \"));\n    }\n\n    return await this.git.diff(args);\n  }\n\n  async getFileHistory(filepath: string): Promise<string> {\n    const logResult: LogResult<DefaultLogFields> = await this.git.log([\n      \"--follow\",\n      \"--\",\n      filepath,\n    ]);\n    return JSON.stringify(logResult, null, 2);\n  }\n\n  async getCurrentBranch(): Promise<string> {\n    return (await this.git.branch()).current;\n  }\n}\n","import { ConfigService } from \"@/services/ConfigService\";\nimport { GitService } from \"@/services/GitManagement/GitService\";\nimport { ActionTagsExtractor } from \"@/services/LLM/actions/ActionTagsExtractor\";\nimport { BaseAction } from \"@/services/LLM/actions/core/BaseAction\";\nimport { IActionBlueprint } from \"@/services/LLM/actions/core/IAction\";\nimport { IActionResult } from \"@/services/LLM/actions/types/ActionTypes\";\nimport { autoInjectable } from \"tsyringe\";\nimport { gitDiffActionBlueprint as blueprint } from \"./blueprints/gitDiffActionBlueprint\";\n\ninterface IGitDiffParams {\n  fromCommit: string;\n  toCommit: string;\n}\n\n@autoInjectable()\nexport class GitDiffAction extends BaseAction {\n  constructor(\n    protected actionTagsExtractor: ActionTagsExtractor,\n    private gitService: GitService,\n    private configService: ConfigService,\n  ) {\n    super(actionTagsExtractor);\n  }\n\n  protected getBlueprint(): IActionBlueprint {\n    return blueprint;\n  }\n\n  protected parseParams(content: string): Record<string, any> {\n    const tag = this.getBlueprint().tag;\n    const match = content.match(new RegExp(`<${tag}>[\\\\s\\\\S]*?<\\\\/${tag}>`));\n    if (!match) {\n      throw new Error(\"Failed to parse git diff content\");\n    }\n\n    const tagContent = match[0];\n    const fromCommit = this.actionTagsExtractor.extractTag(\n      tagContent,\n      \"fromCommit\",\n    );\n    const toCommit = this.actionTagsExtractor.extractTag(\n      tagContent,\n      \"toCommit\",\n    );\n\n    const getValue = (value: string | string[] | null): string => {\n      if (!value) return \"\";\n      return Array.isArray(value) ? value[0]?.trim() || \"\" : value.trim();\n    };\n\n    return {\n      fromCommit: getValue(fromCommit),\n      toCommit: getValue(toCommit),\n    };\n  }\n\n  protected validateParams(params: Record<string, any>): string | null {\n    const { fromCommit, toCommit } = params as IGitDiffParams;\n\n    if (!fromCommit || typeof fromCommit !== \"string\") {\n      return \"fromCommit is required and must be a non-empty string\";\n    }\n\n    if (!toCommit || typeof toCommit !== \"string\") {\n      return \"toCommit is required and must be a non-empty string\";\n    }\n\n    return null;\n  }\n\n  protected async executeInternal(\n    params: IGitDiffParams,\n  ): Promise<IActionResult> {\n    try {\n      const config = this.configService.getConfig();\n      const { excludeLockFiles, lockFiles } = config.gitDiff;\n\n      const excludePattern = excludeLockFiles\n        ? lockFiles.map((file) => `:!${file}`).join(\" \")\n        : \"\";\n\n      const diff = await this.gitService.getDiff(\n        params.fromCommit,\n        params.toCommit,\n        excludePattern,\n      );\n      return this.createSuccessResult(diff);\n    } catch (error) {\n      return this.createErrorResult(error);\n    }\n  }\n}\n","import { IActionBlueprint } from \"@/services/LLM/actions/core/IAction\";\nimport { ActionPriority } from \"@/services/LLM/actions/types/ActionPriority\";\nimport { GitDiffAction } from \"../GitDiffAction\";\n\nexport const gitDiffActionBlueprint: IActionBlueprint = {\n  tag: \"git_diff\",\n  class: GitDiffAction,\n  description: \"Shows git diff between two commits\",\n  usageExplanation: `The git_diff action compares changes between two commits. Here are common use cases:\n\n1. Compare with previous commit:\n<git_diff>\n  <fromCommit>HEAD^</fromCommit>\n  <toCommit>HEAD</toCommit>\n</git_diff>\n\n2. Compare specific commits:\n<git_diff>\n  <fromCommit>abc123</fromCommit>\n  <toCommit>def456</toCommit>\n</git_diff>\n\nNote: \n- Use HEAD for current state\n- Use HEAD^ for previous commit\n- Use commit hashes for specific commits\n- The diff shows: added (+), removed (-), and modified lines`,\n  priority: ActionPriority.HIGH,\n  canRunInParallel: true,\n  requiresProcessing: false,\n  parameters: [\n    {\n      name: \"fromCommit\",\n      required: true,\n      description: \"Starting commit for comparison (e.g. HEAD^)\",\n      validator: (value: unknown): value is string =>\n        typeof value === \"string\" && value.length > 0,\n    },\n    {\n      name: \"toCommit\",\n      required: true,\n      description: \"Ending commit for comparison (e.g. HEAD)\",\n      validator: (value: unknown): value is string =>\n        typeof value === \"string\" && value.length > 0,\n    },\n  ],\n};\n","import { ConfigService } from \"@/services/ConfigService\";\nimport { GitService } from \"@/services/GitManagement/GitService\";\nimport { ActionTagsExtractor } from \"@/services/LLM/actions/ActionTagsExtractor\";\nimport { BaseAction } from \"@/services/LLM/actions/core/BaseAction\";\nimport { IActionBlueprint } from \"@/services/LLM/actions/core/IAction\";\nimport { IActionResult } from \"@/services/LLM/actions/types/ActionTypes\";\nimport { DebugLogger } from \"@/services/logging/DebugLogger\";\nimport { autoInjectable } from \"tsyringe\";\nimport { gitPRDiffActionBlueprint as blueprint } from \"./blueprints/gitPRDiffActionBlueprint\";\n\ninterface IGitPRDiffParams {\n  baseBranch: string;\n  compareBranch: string;\n}\n\n@autoInjectable()\nexport class GitPRDiffAction extends BaseAction {\n  constructor(\n    protected actionTagsExtractor: ActionTagsExtractor,\n    private gitService: GitService,\n    private debugLogger: DebugLogger,\n    private configService: ConfigService,\n  ) {\n    super(actionTagsExtractor);\n  }\n\n  protected getBlueprint(): IActionBlueprint {\n    return blueprint;\n  }\n\n  protected parseParams(content: string): Record<string, any> {\n    // First extract the content from the outer tag\n    const tag = this.getBlueprint().tag;\n    const match = content.match(new RegExp(`<${tag}>[\\\\s\\\\S]*?<\\\\/${tag}>`));\n    if (!match) {\n      throw new Error(\"Failed to parse git PR diff content\");\n    }\n\n    const tagContent = match[0];\n    const baseBranch = this.actionTagsExtractor.extractTag(\n      tagContent,\n      \"baseBranch\",\n    );\n    const compareBranch = this.actionTagsExtractor.extractTag(\n      tagContent,\n      \"compareBranch\",\n    );\n\n    const getValue = (value: string | string[] | null): string => {\n      if (!value) return \"\";\n      return Array.isArray(value) ? value[0]?.trim() || \"\" : value.trim();\n    };\n\n    return {\n      baseBranch: getValue(baseBranch),\n      compareBranch: getValue(compareBranch),\n    };\n  }\n\n  protected validateParams(params: Record<string, any>): string | null {\n    if (typeof params.baseBranch !== \"string\" || !params.baseBranch.trim()) {\n      return \"baseBranch is required and must be a non-empty string\";\n    }\n    if (\n      typeof params.compareBranch !== \"string\" ||\n      !params.compareBranch.trim()\n    ) {\n      return \"compareBranch is required and must be a non-empty string\";\n    }\n    return null;\n  }\n\n  protected async executeInternal(\n    params: IGitPRDiffParams,\n  ): Promise<IActionResult> {\n    try {\n      const config = this.configService.getConfig();\n      const { excludeLockFiles, lockFiles } = config.gitDiff;\n\n      // Only create exclude pattern if excludeLockFiles is true\n      const excludePattern = excludeLockFiles\n        ? lockFiles.map((file) => `:!${file}`).join(\" \")\n        : \"\";\n\n      // Warn if we're trying to use exclude patterns\n      if (excludePattern) {\n        console.warn(\n          \"Warning: File exclusion patterns are not supported for PR diffs. The pattern will be ignored.\",\n        );\n      }\n\n      const diff = await this.gitService.getPRDiff(\n        params.baseBranch,\n        params.compareBranch,\n        excludePattern,\n      );\n      return this.createSuccessResult(diff);\n    } catch (error) {\n      return this.createErrorResult(error);\n    }\n  }\n}\n","import { IActionBlueprint } from \"@/services/LLM/actions/core/IAction\";\nimport { ActionPriority } from \"@/services/LLM/actions/types/ActionPriority\";\nimport { GitPRDiffAction } from \"../GitPRDiffAction\";\n\nexport const gitPRDiffActionBlueprint: IActionBlueprint = {\n  tag: \"git_pr_diff\",\n  class: GitPRDiffAction,\n  description: \"Shows diff between two branches (PR comparison)\",\n  usageExplanation: `The git_pr_diff action compares changes between two branches, useful for PR reviews. Here are common use cases:\n\n1. Compare feature branch with main:\n<git_pr_diff>\n  <baseBranch>main</baseBranch>\n  <compareBranch>feature-branch</compareBranch>\n</git_pr_diff>\n\n2. Compare current branch with main:\n<git_pr_diff>\n  <baseBranch>main</baseBranch>\n  <compareBranch>HEAD</compareBranch>\n</git_pr_diff>\n\nNote:\n- baseBranch is the target branch (e.g. main, master)\n- compareBranch is the source branch (your changes)\n- Use HEAD to reference current branch\n- The diff shows: added (+), removed (-), and modified lines`,\n  priority: ActionPriority.HIGH,\n  canRunInParallel: true,\n  requiresProcessing: false,\n  parameters: [\n    {\n      name: \"baseBranch\",\n      required: true,\n      description: \"Base branch for comparison\",\n      validator: (value: unknown): value is string =>\n        typeof value === \"string\" && value.length > 0,\n    },\n    {\n      name: \"compareBranch\",\n      required: true,\n      description: \"Branch to compare against base\",\n      validator: (value: unknown): value is string =>\n        typeof value === \"string\" && value.length > 0,\n    },\n  ],\n};\n","import { FileOperations } from \"@services/FileManagement/FileOperations\";\nimport { autoInjectable } from \"tsyringe\";\nimport { ActionTagsExtractor } from \"./ActionTagsExtractor\";\nimport { moveFileActionBlueprint as blueprint } from \"./blueprints/moveFileActionBlueprint\";\nimport { BaseAction } from \"./core/BaseAction\";\nimport { IActionBlueprint } from \"./core/IAction\";\nimport { IActionResult } from \"./types/ActionTypes\";\n\ninterface MoveFileParams {\n  source_path: string;\n  destination_path: string;\n}\n\n@autoInjectable()\nexport class MoveFileAction extends BaseAction {\n  constructor(\n    protected actionTagsExtractor: ActionTagsExtractor,\n    private fileOperations: FileOperations,\n  ) {\n    super(actionTagsExtractor);\n  }\n\n  protected getBlueprint(): IActionBlueprint {\n    return blueprint;\n  }\n\n  protected parseParams(content: string): Record<string, any> {\n    // First extract the content from the outer tag\n    const tag = this.getBlueprint().tag;\n    const match = content.match(new RegExp(`<${tag}>[\\\\s\\\\S]*?<\\\\/${tag}>`));\n    if (!match) {\n      this.logError(\"Failed to parse move file content\");\n      return { source_path: \"\", destination_path: \"\" };\n    }\n\n    const tagContent = match[0];\n    const source_path = this.actionTagsExtractor.extractTag(\n      tagContent,\n      \"source_path\",\n    );\n    const destination_path = this.actionTagsExtractor.extractTag(\n      tagContent,\n      \"destination_path\",\n    );\n\n    const getValue = (value: string | string[] | null): string => {\n      if (!value) return \"\";\n      return Array.isArray(value) ? value[0]?.trim() || \"\" : value.trim();\n    };\n\n    return {\n      source_path: getValue(source_path),\n      destination_path: getValue(destination_path),\n    };\n  }\n\n  protected validateParams(params: Record<string, any>): string | null {\n    const { source_path, destination_path } = params as MoveFileParams;\n\n    if (!source_path) {\n      return \"No source path provided\";\n    }\n    if (!destination_path) {\n      return \"No destination path provided\";\n    }\n\n    return null;\n  }\n\n  protected async executeInternal(\n    params: Record<string, any>,\n  ): Promise<IActionResult> {\n    try {\n      const { source_path, destination_path } = params as MoveFileParams;\n\n      this.logInfo(`Source path: ${source_path}`);\n      this.logInfo(`Destination path: ${destination_path}`);\n\n      const result = await this.fileOperations.move(\n        source_path,\n        destination_path,\n      );\n\n      if (!result.success) {\n        return this.createErrorResult(result.error!);\n      }\n\n      return this.createSuccessResult(result.data);\n    } catch (error) {\n      return this.createErrorResult(error as Error);\n    }\n  }\n}\n","import { IActionBlueprint } from \"../core/IAction\";\nimport { MoveFileAction } from \"../MoveFileAction\";\nimport { ActionPriority } from \"../types/ActionPriority\";\n\nexport const moveFileActionBlueprint: IActionBlueprint = {\n  tag: \"move_file\",\n  class: MoveFileAction,\n  description: \"Move a file from source to destination path\",\n  usageExplanation: `The move_file action moves or renames a file. Here are common use cases:\n\n1. Move a file to a different directory:\n<move_file>\n  <source_path>src/utils/helper.ts</source_path>\n  <destination_path>src/services/utils/helper.ts</destination_path>\n</move_file>\n\n2. Rename a file:\n<move_file>\n  <source_path>src/services/OldName.ts</source_path>\n  <destination_path>src/services/NewName.ts</destination_path>\n</move_file>\n\nNote:\n- Use relative paths from workspace root\n- Destination directory must exist\n- Will overwrite destination if it exists\n- Original file is removed after move\n- Update imports after moving`,\n  priority: ActionPriority.MEDIUM,\n  canRunInParallel: false,\n  requiresProcessing: false,\n  parameters: [\n    {\n      name: \"source_path\",\n      required: true,\n      description: \"The source path of the file to move\",\n      validator: (value: any) => typeof value === \"string\" && value.length > 0,\n    },\n    {\n      name: \"destination_path\",\n      required: true,\n      description: \"The destination path for the file\",\n      validator: (value: any) => typeof value === \"string\" && value.length > 0,\n    },\n  ],\n};\n","import { FileOperations } from \"@services/FileManagement/FileOperations\";\nimport { IFileOperationResult } from \"@services/FileManagement/types/FileManagementTypes\";\nimport { IActionResult } from \"@services/LLM/actions/types/ActionTypes\";\nimport { DebugLogger } from \"@services/logging/DebugLogger\";\nimport { autoInjectable } from \"tsyringe\";\nimport { ActionTagsExtractor } from \"./ActionTagsExtractor\";\nimport { readFileActionBlueprint as blueprint } from \"./blueprints/readFileActionBlueprint\";\nimport { BaseAction } from \"./core/BaseAction\";\nimport { IActionBlueprint } from \"./core/IAction\";\n\ninterface IReadFileParams {\n  path: string[];\n}\n\n@autoInjectable()\nexport class ReadFileAction extends BaseAction {\n  constructor(\n    protected actionTagsExtractor: ActionTagsExtractor,\n    private fileOperations: FileOperations,\n    private debugLogger: DebugLogger,\n  ) {\n    super(actionTagsExtractor);\n  }\n\n  protected getBlueprint(): IActionBlueprint {\n    return blueprint;\n  }\n\n  protected validateParams(params: IReadFileParams): string | null {\n    const paths = params.path;\n\n    if (!paths || !Array.isArray(paths) || paths.length === 0) {\n      return \"Must include at least one <path> tag\";\n    }\n\n    const invalidPaths = paths.filter((path) => !path);\n    if (invalidPaths.length > 0) {\n      return `Invalid paths found: ${invalidPaths.join(\", \")}. Try using a <search_file> to find the correct file path.`;\n    }\n\n    return null;\n  }\n\n  protected extractParamValue(\n    content: string,\n    paramName: string,\n  ): string | string[] | null {\n    if (paramName === \"path\") {\n      // Extract all path tags\n      const regex = new RegExp(`<${paramName}>(.*?)</${paramName}>`, \"g\");\n      const matches = Array.from(content.matchAll(regex));\n      const paths = matches.map((match) => match[1].trim());\n      return paths.length > 0 ? paths : null;\n    }\n\n    // Use default extraction for other parameters\n    return super.extractParamValue(content, paramName);\n  }\n\n  protected async executeInternal(\n    params: IReadFileParams,\n  ): Promise<IActionResult> {\n    // Extract paths either from path tags or from raw content\n    const filePaths = Array.isArray(params.path) ? params.path : [params.path];\n\n    // If only one path, use single file read\n    if (filePaths.length === 1) {\n      return await this.handleSingleFile(filePaths[0]);\n    }\n\n    // Handle multiple files\n    return await this.handleMultipleFiles(filePaths);\n  }\n\n  private async handleSingleFile(filePath: string): Promise<IActionResult> {\n    const result = await this.fileOperations.read(filePath);\n    return this.convertFileResult(result);\n  }\n\n  private async handleMultipleFiles(\n    filePaths: string[],\n  ): Promise<IActionResult> {\n    const result = await this.fileOperations.readMultiple(filePaths);\n    this.debugLogger.log(\"ReadFileAction\", \"execute\", result);\n\n    if (!result.success || !result.data) {\n      return this.createErrorResult(\n        result.error || \"Failed to read multiple files\",\n      );\n    }\n\n    this.logSuccess(\"Action completed successfully. Please wait...\\n\");\n    console.log(\"-\".repeat(50));\n\n    return this.createSuccessResult(result.data);\n  }\n\n  private convertFileResult(result: IFileOperationResult): IActionResult {\n    if (result?.success) {\n      this.logSuccess(\"Action completed successfully. Please wait...\\n\");\n    } else {\n      this.logError(result?.error?.message || \"Unknown error\");\n    }\n\n    console.log(\"-\".repeat(50));\n\n    return {\n      success: !!result?.success,\n      data: result?.data,\n      error: result?.error,\n    };\n  }\n}\n","import { IActionBlueprint } from \"../core/IAction\";\nimport { ReadFileAction } from \"../ReadFileAction\";\nimport { ActionPriority } from \"../types/ActionPriority\";\n\nexport const readFileActionBlueprint: IActionBlueprint = {\n  tag: \"read_file\",\n  class: ReadFileAction,\n  description: \"Reads content from one or more files\",\n  usageExplanation: `The read_file action allows you to read the contents of one or more files. Here are common use cases:\n\n1. Read a single file:\n<read_file>\n  <path>src/services/MyService.ts</path>\n</read_file>\n\n2. Read multiple files at once:\n<read_file>\n  <path>src/services/MyService.ts</path>\n  <path>src/types/MyTypes.ts</path>\n</read_file>\n\nNote:\n- Use relative paths from the workspace root\n- You can read up to 4 files at once\n- Avoid reading the same file multiple times\n- If you can't find a file, use search_file first`,\n  priority: ActionPriority.CRITICAL,\n  canRunInParallel: true,\n  requiresProcessing: true,\n  parameters: [\n    {\n      name: \"path\",\n      required: true,\n      description:\n        \"The path(s) of the file(s) to read. Can specify multiple path tags.\",\n      validator: (value: unknown): value is string =>\n        typeof value === \"string\" && value.length > 0,\n    },\n  ],\n};\n","import { PathAdjuster } from \"@services/FileManagement/PathAdjuster\";\nimport path from \"path\";\nimport { autoInjectable } from \"tsyringe\";\nimport { ActionTagsExtractor } from \"./ActionTagsExtractor\";\nimport { relativePathLookupActionBlueprint as blueprint } from \"./blueprints/relativePathLookupActionBlueprint\";\nimport { BaseAction } from \"./core/BaseAction\";\nimport { IActionBlueprint } from \"./core/IAction\";\nimport { IActionResult } from \"./types/ActionTypes\";\n\ninterface RelativePathLookupParams {\n  source_path: string;\n  path: string;\n  threshold?: number;\n}\n\n@autoInjectable()\nexport class RelativePathLookupAction extends BaseAction {\n  constructor(\n    protected actionTagsExtractor: ActionTagsExtractor,\n    private pathAdjuster: PathAdjuster,\n  ) {\n    super(actionTagsExtractor);\n  }\n\n  protected getBlueprint(): IActionBlueprint {\n    return blueprint;\n  }\n\n  protected parseParams(content: string): Record<string, any> {\n    // First extract the content from the outer tag\n    const tag = this.getBlueprint().tag;\n    const match = content.match(new RegExp(`<${tag}>[\\\\s\\\\S]*?<\\\\/${tag}>`));\n    if (!match) {\n      this.logError(\"Failed to parse relative path lookup content\");\n      return { source_path: \"\", path: \"\", threshold: undefined };\n    }\n\n    const tagContent = match[0];\n    const source_path = this.actionTagsExtractor.extractTag(\n      tagContent,\n      \"source_path\",\n    );\n    const path = this.actionTagsExtractor.extractTag(tagContent, \"path\");\n    const threshold = this.actionTagsExtractor.extractTag(\n      tagContent,\n      \"threshold\",\n    );\n\n    const getValue = (value: string | string[] | null): string => {\n      if (!value) return \"\";\n      return Array.isArray(value) ? value[0]?.trim() || \"\" : value.trim();\n    };\n\n    return {\n      source_path: getValue(source_path),\n      path: getValue(path),\n      threshold: threshold ? parseFloat(getValue(threshold)) : undefined,\n    };\n  }\n\n  protected validateParams(params: Record<string, any>): string | null {\n    const { source_path, path, threshold } = params as RelativePathLookupParams;\n\n    if (!source_path) {\n      return \"No source_path provided\";\n    }\n    if (!path) {\n      return \"No path provided\";\n    }\n    if (threshold !== undefined && (threshold <= 0 || threshold > 1)) {\n      return \"Threshold must be between 0 and 1\";\n    }\n\n    return null;\n  }\n\n  protected async executeInternal(\n    params: Record<string, any>,\n  ): Promise<IActionResult> {\n    try {\n      const {\n        source_path,\n        path: relativePath,\n        threshold = 0.6,\n      } = params as RelativePathLookupParams;\n\n      // Get the directory of the source file to resolve relative paths from\n      const sourceDir = path.dirname(source_path);\n\n      // Resolve the full path of the import relative to the source file\n      const fullImportPath = path.resolve(sourceDir, relativePath);\n\n      // Use PathAdjuster to find the correct path\n      const adjustedPath = await this.pathAdjuster.adjustPath(\n        fullImportPath,\n        threshold,\n      );\n\n      if (adjustedPath) {\n        // Convert the adjusted absolute path back to a relative path from the source file\n        const newRelativePath = path.relative(sourceDir, adjustedPath);\n        // Ensure proper directory separator and add ./ if needed\n        const formattedPath = newRelativePath.startsWith(\".\")\n          ? newRelativePath\n          : \"./\" + newRelativePath;\n\n        const result = {\n          originalPath: relativePath,\n          newPath: formattedPath.replace(/\\\\/g, \"/\"), // Ensure forward slashes\n          absolutePath: adjustedPath,\n        };\n\n        this.logSuccess(\n          `Found adjusted path: ${result.newPath} (absolute: ${result.absolutePath})`,\n        );\n        return this.createSuccessResult(result);\n      }\n\n      this.logInfo(\"No adjusted path found\");\n      return this.createSuccessResult(null);\n    } catch (error) {\n      this.logError(`Path lookup failed: ${(error as Error).message}`);\n      return this.createErrorResult(error as Error);\n    }\n  }\n}\n","import { IActionBlueprint } from \"../core/IAction\";\nimport { RelativePathLookupAction } from \"../RelativePathLookupAction\";\nimport { ActionPriority } from \"../types/ActionPriority\";\n\nexport const relativePathLookupActionBlueprint: IActionBlueprint = {\n  tag: \"relative_path_lookup\",\n  class: RelativePathLookupAction,\n  description: \"Adjust and validate relative file paths\",\n  usageExplanation: `The relative_path_lookup action helps resolve and validate relative paths. Here are common use cases:\n\n1. Find correct import path:\n<relative_path_lookup>\n  <source_path>src/services/MyService.ts</source_path>\n  <path>../utils/helper</path>\n</relative_path_lookup>\n\n2. Validate path with custom threshold:\n<relative_path_lookup>\n  <source_path>src/services/MyService.ts</source_path>\n  <path>../types/interfaces</path>\n  <threshold>0.8</threshold>\n</relative_path_lookup>\n\nNote:\n- source_path is where you're importing from\n- path is what you want to import\n- threshold controls fuzzy matching (0.0-1.0)\n- Higher threshold = stricter matching\n- Default threshold is 0.6`,\n  priority: ActionPriority.HIGH,\n  canRunInParallel: true,\n  requiresProcessing: true,\n  parameters: [\n    {\n      name: \"source_path\",\n      required: true,\n      description: \"The source file path to resolve relative paths from\",\n      validator: (value: any) => typeof value === \"string\" && value.length > 0,\n    },\n    {\n      name: \"path\",\n      required: true,\n      description: \"The relative path to adjust\",\n      validator: (value: any) => typeof value === \"string\" && value.length > 0,\n    },\n    {\n      name: \"threshold\",\n      required: false,\n      description: \"Similarity threshold for path matching (default: 0.6)\",\n      validator: (value: any) =>\n        !value || (typeof value === \"number\" && value > 0 && value <= 1),\n    },\n  ],\n};\n","import { FileSearch } from \"@services/FileManagement/FileSearch\";\nimport { autoInjectable } from \"tsyringe\";\nimport { ActionTagsExtractor } from \"./ActionTagsExtractor\";\nimport {\n  searchFileActionBlueprint,\n  searchStringActionBlueprint,\n} from \"./blueprints/searchActionsBlueprint\";\nimport { BaseAction } from \"./core/BaseAction\";\nimport { IActionBlueprint } from \"./core/IAction\";\nimport { IActionResult } from \"./types/ActionTypes\";\n\ninterface SearchParams {\n  directory: string;\n  term: string;\n  type: \"search_string\" | \"search_file\";\n}\n\n@autoInjectable()\nexport class SearchAction extends BaseAction {\n  private currentType: \"search_string\" | \"search_file\" = \"search_file\";\n\n  constructor(\n    protected actionTagsExtractor: ActionTagsExtractor,\n    private fileSearch: FileSearch,\n  ) {\n    super(actionTagsExtractor);\n  }\n\n  async execute(content: string): Promise<IActionResult> {\n    // Determine action type from the content\n    this.currentType = content.includes(\"<search_string>\")\n      ? \"search_string\"\n      : \"search_file\";\n    return super.execute(content);\n  }\n\n  protected getBlueprint(): IActionBlueprint {\n    return this.currentType === \"search_string\"\n      ? searchStringActionBlueprint\n      : searchFileActionBlueprint;\n  }\n\n  protected parseParams(content: string): Record<string, any> {\n    // First extract the content from the outer tag (search_string or search_file)\n    const tag = this.getBlueprint().tag;\n    const match = content.match(new RegExp(`<${tag}>[\\\\s\\\\S]*?<\\\\/${tag}>`));\n    if (!match) {\n      this.logError(\"Failed to parse search content\");\n      return { directory: \"\", term: \"\" };\n    }\n\n    const tagContent = match[0];\n    const directory = this.actionTagsExtractor.extractTag(\n      tagContent,\n      \"directory\",\n    );\n    const term = this.actionTagsExtractor.extractTag(tagContent, \"term\");\n\n    const getValue = (value: string | string[] | null): string => {\n      if (!value) return \"\";\n      return Array.isArray(value) ? value[0]?.trim() || \"\" : value.trim();\n    };\n\n    return {\n      directory: getValue(directory),\n      term: getValue(term),\n    };\n  }\n\n  protected validateParams(params: Record<string, any>): string | null {\n    const { directory, term } = params as SearchParams;\n\n    if (!directory) {\n      return \"No directory provided\";\n    }\n    if (!term) {\n      return \"No search term provided\";\n    }\n\n    return null;\n  }\n\n  protected async executeInternal(\n    params: Record<string, any>,\n  ): Promise<IActionResult> {\n    try {\n      const { directory, term } = params as SearchParams;\n\n      this.logInfo(`Searching in directory: ${directory}`);\n      this.logInfo(`Search term: ${term}`);\n      this.logInfo(`Search type: ${this.currentType}`);\n\n      let results;\n      if (this.currentType === \"search_string\") {\n        results = await this.fileSearch.findByContent(term, directory);\n      } else {\n        results = await this.fileSearch.findByName(term, directory);\n      }\n\n      if (!results || results.length === 0) {\n        this.logInfo(\"No results found\");\n        return this.createSuccessResult([]);\n      }\n\n      this.logSuccess(`Found ${results.length} results`);\n      return this.createSuccessResult(results);\n    } catch (error) {\n      this.logError(`Search failed: ${(error as Error).message}`);\n      return this.createErrorResult(error as Error);\n    }\n  }\n}\n","import { IActionBlueprint } from \"../core/IAction\";\nimport { SearchAction } from \"../SearchAction\";\nimport { ActionPriority } from \"../types/ActionPriority\";\n\nexport const searchStringActionBlueprint: IActionBlueprint = {\n  tag: \"search_string\",\n  class: SearchAction,\n  description: \"Search for content within files\",\n  usageExplanation: `The search_string action helps you find specific content within files. Here are common use cases:\n\n1. Search for a class or function:\n<search_string>\n  <directory>src</directory>\n  <term>export class MyService</term>\n</search_string>\n\n2. Search for specific code patterns:\n<search_string>\n  <directory>src/services</directory>\n  <term>@injectable()</term>\n</search_string>\n\nNote:\n- Use specific directories to narrow down search\n- Search terms can be partial matches\n- Case-sensitive by default\n- Results show file path and line number`,\n  priority: ActionPriority.HIGH,\n  canRunInParallel: true,\n  requiresProcessing: true,\n  parameters: [\n    {\n      name: \"directory\",\n      required: true,\n      description: \"The directory to search in\",\n      validator: (value: any) => typeof value === \"string\" && value.length > 0,\n    },\n    {\n      name: \"term\",\n      required: true,\n      description: \"The content to search for\",\n      validator: (value: any) => typeof value === \"string\" && value.length > 0,\n    },\n  ],\n};\n\nexport const searchFileActionBlueprint: IActionBlueprint = {\n  tag: \"search_file\",\n  class: SearchAction,\n  description: \"Search for files by name\",\n  usageExplanation: `The search_file action helps you find files by name or pattern. Here are common use cases:\n\n1. Search for a specific file:\n<search_file>\n  <directory>src</directory>\n  <term>MyService.ts</term>\n</search_file>\n\n2. Search using patterns:\n<search_file>\n  <directory>src/services</directory>\n  <term>*Service.ts</term>\n</search_file>\n\nNote:\n- Use * for wildcards in patterns\n- Search is case-sensitive\n- Results show full file paths\n- Use specific directories to narrow search`,\n  priority: ActionPriority.HIGH,\n  canRunInParallel: true,\n  requiresProcessing: true,\n  parameters: [\n    {\n      name: \"directory\",\n      required: true,\n      description: \"The directory to search in\",\n      validator: (value: any) => typeof value === \"string\" && value.length > 0,\n    },\n    {\n      name: \"term\",\n      required: true,\n      description: \"The filename pattern to search for\",\n      validator: (value: any) => typeof value === \"string\" && value.length > 0,\n    },\n  ],\n};\n","export const BLOCK_WRITE_IF_CONTENT_REMOVAL_THRESHOLD = 90;\n","export const MODEL_SCALING_INITIAL_TRY_COUNT = 2;\n","import { MODEL_SCALING_INITIAL_TRY_COUNT } from \"@/constants/modelScaling\";\nimport { DebugLogger } from \"@services/logging/DebugLogger\";\nimport { singleton } from \"tsyringe\";\nimport { ConfigService } from \"../ConfigService\";\nimport { ModelManager } from \"./ModelManager\";\nimport { PhaseManager } from \"./PhaseManager\";\nimport { Phase } from \"./types/PhaseTypes\";\n\n@singleton()\nexport class ModelScaler {\n  private tryCountMap: Map<string, number> = new Map();\n  private globalTryCount: number = 0;\n  private autoScalerEnabled: boolean = false;\n\n  constructor(\n    private debugLogger: DebugLogger,\n    private configService: ConfigService,\n    private modelManager: ModelManager,\n    private phaseManager: PhaseManager,\n  ) {\n    const config = this.configService.getConfig();\n    this.autoScalerEnabled = config.autoScaler || false;\n  }\n\n  isAutoScalerEnabled(): boolean {\n    return this.autoScalerEnabled;\n  }\n\n  async incrementTryCount(filePath: string): Promise<void> {\n    const currentPhase = this.phaseManager.getCurrentPhase();\n\n    if (!this.autoScalerEnabled || currentPhase !== Phase.Execute) {\n      return;\n    }\n\n    this.incrementCounts(filePath);\n    const currentCount = this.tryCountMap.get(filePath) || 0;\n\n    // Only scale if we've exceeded the threshold\n    if (currentCount > MODEL_SCALING_INITIAL_TRY_COUNT) {\n      await this.handleModelScaling(filePath, currentCount);\n    }\n  }\n\n  getTryCount(filePath: string): number {\n    if (!this.autoScalerEnabled) return 0;\n    return this.tryCountMap.get(filePath) || 0;\n  }\n\n  getGlobalTryCount(): number {\n    if (!this.autoScalerEnabled) return 0;\n    return this.globalTryCount;\n  }\n\n  reset(): void {\n    this.tryCountMap.clear();\n    this.globalTryCount = 0;\n    const config = this.configService.getConfig();\n    this.autoScalerEnabled = config.autoScaler || false;\n    this.modelManager.setCurrentModel(config.discoveryModel);\n  }\n\n  private incrementCounts(filePath: string): void {\n    if (!this.autoScalerEnabled) return;\n\n    this.globalTryCount++;\n    const currentCount = this.tryCountMap.get(filePath) || 0;\n    this.tryCountMap.set(filePath, currentCount + 1);\n  }\n\n  private getMaxTryCount(): number {\n    const values = Array.from(this.tryCountMap.values());\n    return values.length > 0 ? Math.max(...values) : 0;\n  }\n\n  private async handleModelScaling(\n    filePath: string,\n    currentCount: number,\n  ): Promise<void> {\n    if (!this.autoScalerEnabled) return;\n\n    const maxTries = this.getMaxTryCount();\n    const newModel = this.getModelForTryCount(\n      maxTries.toString(),\n      this.globalTryCount,\n    );\n\n    this.debugLogger.log(\"Model\", \"Incrementing try count\", {\n      filePath,\n      fileCount: currentCount + 1,\n      globalCount: this.globalTryCount,\n      maxTries,\n      newModel,\n      phase: this.phaseManager.getCurrentPhase(),\n    });\n\n    await this.modelManager.setCurrentModel(newModel);\n  }\n\n  private getModelForTryCount(\n    tryCount: string | null,\n    globalTries: number,\n  ): string {\n    const config = this.configService.getConfig();\n    const availableModels = config.autoScaleAvailableModels;\n\n    if (!tryCount) return availableModels[0].id;\n\n    const tries = parseInt(tryCount, 10);\n\n    for (let i = 0; i < availableModels.length; i++) {\n      const previousTriesSum = availableModels\n        .slice(0, i)\n        .reduce((sum, model) => sum + model.maxWriteTries, 0);\n\n      if (\n        tries >= previousTriesSum + availableModels[i].maxWriteTries ||\n        globalTries >= availableModels[i].maxGlobalTries\n      ) {\n        continue;\n      }\n\n      return availableModels[i].id;\n    }\n\n    return availableModels[availableModels.length - 1].id;\n  }\n}\n","import he from \"he\";\nimport { injectable } from \"tsyringe\";\n\ninterface IHtmlEntityDecoderOptions {\n  unescape?: boolean;\n  unescapeChars?: string[];\n}\n\n@injectable()\nexport class HtmlEntityDecoder {\n  /**\n   * Decodes HTML entities and cleans up character escaping in the provided text.\n   * @param text The string containing HTML entities and escaped characters.\n   * @param options Configuration options for decoding\n   * @returns The decoded and unescaped string.\n   */\n  decode(text: string, options?: IHtmlEntityDecoderOptions): string {\n    if (!text) {\n      return \"\";\n    }\n\n    let result = text;\n\n    // Always unescape if unescapeChars are provided, regardless of unescape option\n    if (options?.unescapeChars?.length || options?.unescape) {\n      result = this.unescapeString(result, options?.unescapeChars);\n    }\n\n    // Step 2: Decode HTML entities\n    return he.decode(result);\n  }\n\n  /**\n   * Unescapes specific backslash-escaped characters in a string.\n   * @param str The string with escaped characters.\n   * @param chars Optional array of specific characters to unescape\n   * @returns The unescaped string.\n   */\n  private unescapeString(str: string, chars?: string[]): string {\n    return str.replace(/\\\\u([0-9a-fA-F]{4})|\\\\(.)/g, (match, unicode, char) => {\n      if (unicode) {\n        // Handle Unicode escape sequences\n        const code = parseInt(unicode, 16);\n        return String.fromCharCode(code);\n      }\n\n      // Special characters map for escaped sequences\n      const specialCharMap: { [key: string]: string } = {\n        n: \"\\n\",\n        t: \"\\t\",\n        r: \"\\r\",\n        b: \"\\b\",\n        f: \"\\f\",\n        '\"': '\"',\n        \"'\": \"'\",\n        \"\\\\\": \"\\\\\",\n        \"/\": \"/\",\n      };\n\n      // If specific chars are provided, only unescape those\n      if (chars) {\n        return chars.includes(char) ? specialCharMap[char] || char : match;\n      }\n\n      // Handle other escaped characters when no specific chars are provided\n      return specialCharMap[char] || char;\n    });\n  }\n}\n","import { BLOCK_WRITE_IF_CONTENT_REMOVAL_THRESHOLD } from \"@constants/writeConstants\";\nimport { FileOperations } from \"@services/FileManagement/FileOperations\";\nimport { ModelScaler } from \"@services/LLM/ModelScaler\";\nimport { HtmlEntityDecoder } from \"@services/text/HTMLEntityDecoder\";\nimport { autoInjectable } from \"tsyringe\";\nimport { ActionTagsExtractor } from \"./ActionTagsExtractor\";\nimport { writeFileActionBlueprint as blueprint } from \"./blueprints/writeFileActionBlueprint\";\nimport { BaseAction } from \"./core/BaseAction\";\nimport { IActionBlueprint } from \"./core/IAction\";\nimport { IActionResult } from \"./types/ActionTypes\";\n\ninterface WriteFileParams {\n  path: string;\n  content: string;\n  type: \"new\" | \"update\";\n}\n\nconst MAX_CONTENT_SIZE_MB = 10;\nconst MAX_CONTENT_SIZE_BYTES = MAX_CONTENT_SIZE_MB * 1024 * 1024;\nconst MAX_LINE_LENGTH = 10000;\n\n@autoInjectable()\nexport class WriteFileAction extends BaseAction {\n  constructor(\n    protected actionTagsExtractor: ActionTagsExtractor,\n    private fileOperations: FileOperations,\n    private htmlEntityDecoder: HtmlEntityDecoder,\n    private modelScaler: ModelScaler,\n  ) {\n    super(actionTagsExtractor);\n  }\n\n  protected logWarning(message: string): void {\n    console.warn(`⚠️ write_file: ${message}`);\n  }\n\n  protected logError(message: string): void {\n    console.error(`❌ write_file: ${message}`);\n  }\n\n  protected logInfo(message: string): void {\n    console.info(`ℹ️ write_file: ${message}`);\n  }\n\n  protected getBlueprint(): IActionBlueprint {\n    return blueprint;\n  }\n\n  protected validateParams(params: Record<string, any>): string | null {\n    try {\n      const { path: filePath, content, type } = params as WriteFileParams;\n\n      if (!filePath) {\n        return \"No file path provided\";\n      }\n      if (!content) {\n        return \"No file content provided\";\n      }\n      if (!type || ![\"new\", \"update\"].includes(type)) {\n        return \"Invalid or missing type parameter (must be 'new' or 'update')\";\n      }\n\n      // Validate path\n      if (filePath.includes(\"..\")) {\n        return \"Path traversal is not allowed\";\n      }\n\n      // Validate content size\n      const contentSizeBytes = Buffer.byteLength(content, \"utf8\");\n      if (contentSizeBytes > MAX_CONTENT_SIZE_BYTES) {\n        return `Content size (${(contentSizeBytes / 1024 / 1024).toFixed(2)}MB) exceeds maximum allowed size (${MAX_CONTENT_SIZE_MB}MB)`;\n      }\n\n      return null;\n    } catch (error) {\n      this.logError(`Error in validateParams: ${error}`);\n      return `Validation error: ${error instanceof Error ? error.message : String(error)}`;\n    }\n  }\n\n  protected extractParamValue(\n    content: string,\n    paramName: string,\n  ): string | string[] | null {\n    try {\n      // Handle content parameter specially to preserve nested tags\n      if (paramName === \"content\") {\n        const contentMatch = content.match(/<content>([\\s\\S]*?)<\\/content>/);\n        if (!contentMatch) {\n          this.logWarning(\n            `Failed to extract content parameter from: ${content.substring(0, 100)}...`,\n          );\n          return null;\n        }\n        // Trim whitespace but preserve internal whitespace\n        return contentMatch[1].replace(/^\\s+|\\s+$/g, \"\");\n      }\n\n      // Use default extraction for other parameters\n      const value = super.extractParamValue(content, paramName);\n      return value;\n    } catch (error) {\n      this.logError(`Error extracting parameter ${paramName}: ${error}`);\n      return null;\n    }\n  }\n\n  protected async executeInternal(\n    params: Record<string, any>,\n  ): Promise<IActionResult> {\n    try {\n      const {\n        path: filePath,\n        content: fileContent,\n        type,\n      } = params as WriteFileParams;\n\n      this.logInfo(`Writing to file: ${filePath} (type: ${type})`);\n\n      // For updates, try to find the correct path if file doesn't exist\n      if (type === \"update\") {\n        const exists = await this.fileOperations.exists(filePath);\n        if (!exists) {\n          const similarFiles =\n            await this.fileOperations.findSimilarFiles(filePath);\n\n          if (similarFiles.length > 0) {\n            const bestMatch = similarFiles[0];\n            this.logInfo(`Found similar existing file: ${bestMatch}`);\n            params.path = bestMatch;\n          } else {\n            return this.createErrorResult(\n              `Cannot update file ${filePath} - file not found and no similar files exist`,\n            );\n          }\n        }\n\n        // Check for large content removal if file exists\n        const removalCheck = await this.checkLargeRemoval(\n          params.path,\n          fileContent,\n        );\n        if (!removalCheck.success) {\n          return removalCheck;\n        }\n      }\n\n      // Decode content and validate\n      const decodedContent = this.htmlEntityDecoder.decode(fileContent, {\n        unescapeChars: ['\"'],\n      });\n      if (!this.isValidContent(decodedContent)) {\n        return this.createErrorResult(\n          \"Invalid content detected after decoding\",\n        );\n      }\n\n      // Write file\n      const result = await this.fileOperations.write(\n        params.path,\n        decodedContent,\n      );\n\n      if (!result.success) {\n        this.logError(`Failed to write file ${params.path}: ${result.error}`);\n        return this.createErrorResult(result.error!);\n      }\n\n      this.logInfo(\n        `Successfully wrote ${Buffer.byteLength(decodedContent, \"utf8\")} bytes to ${params.path}`,\n      );\n      return this.createSuccessResult();\n    } catch (error) {\n      this.logError(`Unexpected error in WriteFileAction: ${error}`);\n      return this.createErrorResult(\n        `Unexpected error: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  private async checkLargeRemoval(\n    filePath: string,\n    newContent: string,\n  ): Promise<IActionResult> {\n    try {\n      const exists = await this.fileOperations.exists(filePath);\n      if (!exists) {\n        this.logInfo(`Creating new file: ${filePath}`);\n        return this.createSuccessResult();\n      }\n\n      this.logInfo(`File exists at: ${filePath}`);\n      this.modelScaler.incrementTryCount(filePath);\n\n      const readResult = await this.fileOperations.read(filePath);\n      if (!readResult.success) {\n        this.logWarning(\n          `Could not read existing file ${filePath}: ${readResult.error}`,\n        );\n        return this.createSuccessResult();\n      }\n\n      const existingContent = readResult.data as string;\n      const removalPercentage = this.calculateRemovalPercentage(\n        existingContent,\n        newContent,\n      );\n\n      this.logInfo(\n        `Content removal percentage: ${removalPercentage.toFixed(1)}%`,\n      );\n\n      if (removalPercentage > BLOCK_WRITE_IF_CONTENT_REMOVAL_THRESHOLD) {\n        return this.createErrorResult(\n          `Prevented removal of ${removalPercentage.toFixed(1)}% of file content. This appears to be a potential error. Please review the changes and ensure only necessary modifications are made.`,\n        );\n      }\n\n      return this.createSuccessResult();\n    } catch (error) {\n      this.logError(`Error in checkLargeRemoval: ${error}`);\n      return this.createErrorResult(\n        `Error checking content removal: ${error instanceof Error ? error.message : String(error)}`,\n      );\n    }\n  }\n\n  private calculateRemovalPercentage(\n    existingContent: string,\n    newContent: string,\n  ): number {\n    const existingLength = existingContent.trim().length;\n    const newLength = newContent.trim().length;\n\n    if (existingLength === 0) return 0;\n\n    const removedLength = Math.max(0, existingLength - newLength);\n    return (removedLength / existingLength) * 100;\n  }\n\n  private isValidContent(content: string | null): boolean {\n    try {\n      if (!content) {\n        this.logWarning(\"Content is null or empty\");\n        return false;\n      }\n\n      // Check for null bytes and other potentially dangerous content\n      if (content.includes(\"\\0\")) {\n        this.logWarning(\"Content contains null bytes\");\n        return false;\n      }\n\n      // Check for reasonable line length\n      const hasExcessiveLines = content\n        .split(\"\\n\")\n        .some((line) => line.length > MAX_LINE_LENGTH);\n      if (hasExcessiveLines) {\n        this.logWarning(\"Content contains excessively long lines\");\n        return false;\n      }\n\n      return true;\n    } catch (error) {\n      this.logError(`Error in isValidContent: ${error}`);\n      return false;\n    }\n  }\n}\n","import { IActionBlueprint } from \"../core/IAction\";\nimport { ActionPriority } from \"../types/ActionPriority\";\nimport { WriteFileAction } from \"../WriteFileAction\";\n\nexport const writeFileActionBlueprint: IActionBlueprint = {\n  tag: \"write_file\",\n  class: WriteFileAction,\n  description:\n    \"Writes content to a file with safety checks for content removal\",\n  usageExplanation: `The write_file action allows you to create new files or update existing ones. Here are common use cases:\n\n1. Create a new file:\n<write_file>\n  <type>new</type>\n  <path>src/services/NewService.ts</path>\n  <content>\nimport { injectable } from \"tsyringe\";\n\n@injectable()\nexport class NewService {\n  // ... your code here\n}\n  </content>\n</write_file>\n\n2. Update an existing file:\n<write_file>\n  <type>update</type>\n  <path>src/services/ExistingService.ts</path>\n  <content>\n// ... existing code ...\n// Your new code here\n// ... existing code ...\n  </content>\n</write_file>\n\nNote:\n- For new files: Include all necessary imports\n- For updates: Use // ... existing code ... to preserve unchanged parts\n- Always use relative paths from workspace root\n- Include proper type annotations and decorators\n- Run type checks after writing`,\n  priority: ActionPriority.MEDIUM,\n  canRunInParallel: false,\n  requiresProcessing: false,\n  parameters: [\n    {\n      name: \"type\",\n      required: true,\n      description:\n        \"Specifies whether this is a new file creation or an update to an existing file\",\n      validator: (value: unknown): value is string =>\n        typeof value === \"string\" &&\n        [\"new\", \"update\"].includes(value as string),\n    },\n    {\n      name: \"path\",\n      required: true,\n      description: \"The path where the file will be written\",\n      validator: (value: unknown): value is string =>\n        typeof value === \"string\" && value.length > 0,\n    },\n    {\n      name: \"content\",\n      required: true,\n      description:\n        \"The content to write to the file. Must not remove too much existing content if file exists.\",\n      validator: (value: unknown): value is string => typeof value === \"string\",\n    },\n  ],\n};\n","import { IActionBlueprint } from \"../core/IAction\";\n\n// Import all blueprints\nimport { actionExplainerBlueprint } from \"./actionExplainerBlueprint\";\nimport { commandActionBlueprint } from \"./commandActionBlueprint\";\nimport { copyFileActionBlueprint } from \"./copyFileActionBlueprint\";\nimport { deleteFileActionBlueprint } from \"./deleteFileActionBlueprint\";\nimport { endPhaseActionBlueprint } from \"./endPhaseActionBlueprint\";\nimport { endTaskActionBlueprint } from \"./endTaskActionBlueprint\";\nimport { fetchUrlActionBlueprint } from \"./fetchUrlActionBlueprint\";\nimport { gitDiffActionBlueprint } from \"./gitDiffActionBlueprint\";\nimport { gitPRDiffActionBlueprint } from \"./gitPRDiffActionBlueprint\";\nimport { moveFileActionBlueprint } from \"./moveFileActionBlueprint\";\nimport { readFileActionBlueprint } from \"./readFileActionBlueprint\";\nimport { relativePathLookupActionBlueprint } from \"./relativePathLookupActionBlueprint\";\nimport {\n  searchFileActionBlueprint,\n  searchStringActionBlueprint,\n} from \"./searchActionsBlueprint\";\nimport { writeFileActionBlueprint } from \"./writeFileActionBlueprint\";\n\n// Create a map of all blueprints\nexport const actionsBlueprints = {\n  [actionExplainerBlueprint.tag]: actionExplainerBlueprint,\n  [commandActionBlueprint.tag]: commandActionBlueprint,\n  [copyFileActionBlueprint.tag]: copyFileActionBlueprint,\n  [deleteFileActionBlueprint.tag]: deleteFileActionBlueprint,\n  [endPhaseActionBlueprint.tag]: endPhaseActionBlueprint,\n  [endTaskActionBlueprint.tag]: endTaskActionBlueprint,\n  [fetchUrlActionBlueprint.tag]: fetchUrlActionBlueprint,\n  [gitDiffActionBlueprint.tag]: gitDiffActionBlueprint,\n  [gitPRDiffActionBlueprint.tag]: gitPRDiffActionBlueprint,\n  [moveFileActionBlueprint.tag]: moveFileActionBlueprint,\n  [readFileActionBlueprint.tag]: readFileActionBlueprint,\n  [relativePathLookupActionBlueprint.tag]: relativePathLookupActionBlueprint,\n  [searchFileActionBlueprint.tag]: searchFileActionBlueprint,\n  [searchStringActionBlueprint.tag]: searchStringActionBlueprint,\n  [writeFileActionBlueprint.tag]: writeFileActionBlueprint,\n} as const;\n\n// Type for action tags based on the blueprint map\nexport type ActionTag = keyof typeof actionsBlueprints & string;\n\n// Helper functions\nexport function getBlueprint(tag: ActionTag): IActionBlueprint {\n  return actionsBlueprints[tag];\n}\n\nexport function getActionTags(): ActionTag[] {\n  return Object.keys(actionsBlueprints) as ActionTag[];\n}\n\nexport function getImplementedActions(): ActionTag[] {\n  return getActionTags().filter((tag) => {\n    const blueprint = actionsBlueprints[tag];\n    return !!(blueprint && blueprint.class && blueprint.tag);\n  });\n}\n","import { singleton } from \"tsyringe\";\nimport { ActionTag, getBlueprint } from \"../blueprints\";\nimport { ActionPriority } from \"../types/ActionPriority\";\nimport { IActionResult } from \"../types/ActionTypes\";\n\ninterface QueuedAction {\n  type: string;\n  content: string;\n  priority: ActionPriority;\n  requiresProcessing: boolean;\n  result?: IActionResult;\n}\n\n@singleton()\nexport class ActionQueue {\n  private queue: QueuedAction[] = [];\n  private processedResults: Map<string, unknown> = new Map();\n\n  enqueue(type: string, content: string): void {\n    const blueprint = getBlueprint(type as ActionTag);\n    const priority = blueprint?.priority || ActionPriority.LOW;\n    const requiresProcessing = blueprint?.requiresProcessing || false;\n\n    this.queue.push({\n      type,\n      content,\n      priority,\n      requiresProcessing,\n    });\n\n    // Sort queue by priority (lower numbers = higher priority)\n    this.queue.sort((a, b) => a.priority - b.priority);\n  }\n\n  dequeue(): QueuedAction | undefined {\n    if (this.queue.length === 0) {\n      return undefined;\n    }\n\n    // Get the highest priority action that hasn't been processed\n    const nextAction = this.queue.find((action) => !action.result);\n\n    if (!nextAction) {\n      return undefined;\n    }\n\n    // If it doesn't require processing, remove it from the queue\n    if (!nextAction.requiresProcessing) {\n      const index = this.queue.indexOf(nextAction);\n      this.queue.splice(index, 1);\n    }\n\n    return nextAction;\n  }\n\n  setActionResult(type: string, content: string, result: IActionResult): void {\n    const actionIndex = this.queue.findIndex(\n      (action) => action.type === type && action.content === content,\n    );\n\n    if (actionIndex !== -1) {\n      const action = this.queue[actionIndex];\n\n      if (action.requiresProcessing && result.success) {\n        // Store processed results\n        this.processedResults.set(`${type}:${content}`, result.data);\n        // Remove the processed action from the queue\n        this.queue.splice(actionIndex, 1);\n      } else if (action.requiresProcessing && !result.success) {\n        // Optionally, you can handle failed processing here\n        // For example, you might want to retry or log the failure\n        // Currently, the action remains in the queue for potential reprocessing\n      } else {\n        // If the action does not require processing, remove it\n        this.queue.splice(actionIndex, 1);\n      }\n    }\n  }\n\n  getProcessedResults(): Map<string, unknown> {\n    return this.processedResults;\n  }\n\n  isEmpty(): boolean {\n    return this.queue.length === 0;\n  }\n\n  size(): number {\n    return this.queue.length;\n  }\n\n  clear(): void {\n    this.queue = [];\n    this.processedResults.clear();\n  }\n}\n","import fs from \"fs\";\nimport path from \"path\";\nimport { autoInjectable } from \"tsyringe\";\n\nexport interface IProjectInfo {\n  mainDependencies: string[];\n  scripts: Record<string, string>;\n  dependencyFile?: string;\n}\n\n@autoInjectable()\nexport class ProjectInfo {\n  constructor() {}\n\n  async gatherProjectInfo(projectRoot: string): Promise<IProjectInfo> {\n    const files = await fs.promises.readdir(projectRoot, {\n      withFileTypes: true,\n    });\n    const dependencyFiles = [\n      \"package.json\",\n      \"requirements.txt\",\n      \"Cargo.toml\",\n      \"go.mod\",\n      \"pom.xml\",\n      \"composer.json\",\n      \"pyproject.toml\",\n    ];\n\n    const foundDependencyFile = dependencyFiles.find((depFile) =>\n      files.some((dirent) => dirent.isFile() && dirent.name === depFile),\n    );\n\n    if (!foundDependencyFile) {\n      return {\n        mainDependencies: [],\n        scripts: {},\n      };\n    }\n\n    switch (foundDependencyFile) {\n      case \"package.json\":\n        return this.gatherNodeInfo(projectRoot, foundDependencyFile);\n      case \"requirements.txt\":\n      case \"pyproject.toml\":\n        return this.gatherPythonInfo(projectRoot, foundDependencyFile);\n      case \"Cargo.toml\":\n        return this.gatherRustInfo(projectRoot, foundDependencyFile);\n      case \"go.mod\":\n        return this.gatherGoInfo(projectRoot, foundDependencyFile);\n      default:\n        return {\n          mainDependencies: [],\n          scripts: {},\n          dependencyFile: foundDependencyFile,\n        };\n    }\n  }\n\n  private async gatherNodeInfo(\n    projectRoot: string,\n    dependencyFile: string,\n  ): Promise<IProjectInfo> {\n    try {\n      const packageJsonPath = path.join(projectRoot, dependencyFile);\n      const content = await fs.promises.readFile(packageJsonPath, \"utf-8\");\n      const packageJson = JSON.parse(content);\n\n      return {\n        mainDependencies: [\n          ...Object.keys(packageJson.dependencies || {}),\n          ...Object.keys(packageJson.devDependencies || {}),\n        ],\n        scripts: packageJson.scripts || {},\n        dependencyFile,\n      };\n    } catch {\n      return { mainDependencies: [], scripts: {}, dependencyFile };\n    }\n  }\n\n  private async gatherPythonInfo(\n    projectRoot: string,\n    dependencyFile: string,\n  ): Promise<IProjectInfo> {\n    try {\n      let dependencies: string[] = [];\n      const reqPath = path.join(projectRoot, dependencyFile);\n      const content = await fs.promises.readFile(reqPath, \"utf-8\");\n\n      if (dependencyFile === \"requirements.txt\") {\n        dependencies = content\n          .split(\"\\n\")\n          .map((line) => line.trim())\n          .filter((line) => line && !line.startsWith(\"#\"))\n          .map((line) => line.split(\"==\")[0]);\n      }\n\n      return {\n        mainDependencies: dependencies,\n        scripts: {},\n        dependencyFile,\n      };\n    } catch {\n      return { mainDependencies: [], scripts: {}, dependencyFile };\n    }\n  }\n\n  private async gatherRustInfo(\n    projectRoot: string,\n    dependencyFile: string,\n  ): Promise<IProjectInfo> {\n    try {\n      const cargoPath = path.join(projectRoot, dependencyFile);\n      const content = await fs.promises.readFile(cargoPath, \"utf-8\");\n\n      const dependencies: string[] = [];\n      let inDepsSection = false;\n\n      content.split(\"\\n\").forEach((line) => {\n        if (line.trim().startsWith(\"[dependencies]\")) {\n          inDepsSection = true;\n        } else if (line.trim().startsWith(\"[\")) {\n          inDepsSection = false;\n        } else if (inDepsSection && line.includes(\"=\")) {\n          const dep = line.split(\"=\")[0].trim();\n          dependencies.push(dep);\n        }\n      });\n\n      return {\n        mainDependencies: dependencies,\n        scripts: {\n          build: \"cargo build\",\n          run: \"cargo run\",\n          test: \"cargo test\",\n        },\n        dependencyFile,\n      };\n    } catch {\n      return { mainDependencies: [], scripts: {}, dependencyFile };\n    }\n  }\n\n  private async gatherGoInfo(\n    projectRoot: string,\n    dependencyFile: string,\n  ): Promise<IProjectInfo> {\n    try {\n      const modPath = path.join(projectRoot, dependencyFile);\n      const content = await fs.promises.readFile(modPath, \"utf-8\");\n\n      const dependencies: string[] = [];\n      content.split(\"\\n\").forEach((line) => {\n        const trimmedLine = line.trim();\n        if (!trimmedLine.startsWith(\"//\") && trimmedLine.split(\" \")[0].includes(\"/\")) {\n          dependencies.push(trimmedLine.split(\" \")[0]);\n        }\n      });\n\n      return {\n        mainDependencies: dependencies,\n        scripts: {\n          build: \"go build\",\n          run: \"go run .\",\n          test: \"go test ./...\",\n        },\n        dependencyFile,\n      };\n    } catch {\n      return { mainDependencies: [], scripts: {}, dependencyFile };\n    }\n  }\n}","import { ConfigService } from \"@services/ConfigService\";\nimport { DirectoryScanner } from \"@services/FileManagement/DirectoryScanner\";\nimport { ActionExecutor } from \"@services/LLM/actions/ActionExecutor\";\nimport { IActionResult } from \"@services/LLM/actions/types/ActionTypes\";\nimport { ProjectInfo } from \"@services/LLM/utils/ProjectInfo\";\nimport * as fs from \"fs\";\nimport { autoInjectable } from \"tsyringe\";\nimport { MessageContextBuilder } from \"./context/MessageContextBuilder\";\nimport { MessageContextCleaner } from \"./context/MessageContextCleanup\";\nimport { MessageContextStore } from \"./context/MessageContextStore\";\nimport { PhaseManager } from \"./PhaseManager\";\nimport { IPhasePromptArgs } from \"./types/PhaseTypes\";\n\ninterface MessageContext {\n  message: string;\n  environmentDetails?: string;\n  projectInfo?: string;\n}\n\n@autoInjectable()\nexport class LLMContextCreator {\n  constructor(\n    private directoryScanner: DirectoryScanner,\n    private actionExecutor: ActionExecutor,\n    private projectInfo: ProjectInfo,\n    private configService: ConfigService,\n    private phaseManager: PhaseManager,\n    private messageContextCleaner: MessageContextCleaner,\n    private messageContextBuilder: MessageContextBuilder,\n    private messageContextStore: MessageContextStore,\n  ) {}\n\n  private async loadCustomInstructions(): Promise<string> {\n    const config = this.configService.getConfig();\n\n    if (config.customInstructionsPath) {\n      try {\n        const instructions = await fs.promises.readFile(\n          config.customInstructionsPath,\n          \"utf-8\",\n        );\n        return instructions.trim();\n      } catch (error) {\n        throw Error(\n          `Failed to load custom instructions from ${config.customInstructionsPath}, check if the file exists and is accessible.`,\n        );\n      }\n    }\n\n    if (config.customInstructions) {\n      return config.customInstructions;\n    }\n\n    throw new Error(\n      \"No custom instructions provided. Either customInstructionsPath or customInstructions must be set in config.\",\n    );\n  }\n\n  async create(\n    message: string,\n    root: string,\n    isFirstMessage: boolean = true,\n  ): Promise<string> {\n    const baseContext: MessageContext = {\n      message,\n    };\n\n    if (isFirstMessage) {\n      // Reset to discovery phase on first message\n      this.phaseManager.resetPhase();\n      // Clear message context only on first message\n      this.messageContextCleaner.cleanupContext();\n\n      const [environmentDetails, projectInfo] = await Promise.all([\n        this.getEnvironmentDetails(root),\n        this.getProjectInfo(root),\n      ]);\n\n      return this.formatFirstTimeMessage({\n        ...baseContext,\n        environmentDetails,\n        projectInfo,\n      });\n    }\n\n    // Only generate new phase prompt if phase has changed\n    const currentPhase = this.phaseManager.getCurrentPhase();\n    const contextData = this.messageContextStore.getContextData();\n\n    const phaseInstructions = Array.from(\n      contextData.phaseInstructions.values(),\n    );\n    const currentPhaseInstruction = phaseInstructions.find(\n      (instruction) => instruction.phase === currentPhase,\n    );\n\n    if (!currentPhaseInstruction) {\n      return this.formatSequentialMessage(baseContext);\n    }\n\n    // Return just the message if phase hasn't changed\n    return baseContext.message;\n  }\n\n  private async getEnvironmentDetails(root: string): Promise<string> {\n    const scanResult = await this.directoryScanner.scan(root);\n    if (!scanResult.success) {\n      throw new Error(`Failed to scan directory: ${scanResult.error}`);\n    }\n\n    return `# Current Working Directory (${root}) Files\\n${scanResult.data}`;\n  }\n\n  private async getProjectInfo(root: string): Promise<string> {\n    const info = await this.projectInfo.gatherProjectInfo(root);\n    const config = this.configService.getConfig();\n\n    if (!info.dependencyFile) {\n      return \"\";\n    }\n\n    const runAllTestsCmd = config.runAllTestsCmd || \"yarn test\";\n    const runOneTestCmd = config.runOneTestCmd || \"yarn test {testPath}\";\n    const runTypeCheckCmd = config.runTypeCheckCmd || \"yarn type-check\";\n\n    // Add project language and package manager info\n    const projectSetup = `# Project Setup\nLanguage: ${config.projectLanguage}\nPackage Manager: ${config.packageManager}`;\n\n    // Add flexible reference examples section\n    const referenceExamplesSection = Object.entries(\n      config.referenceExamples || {},\n    )\n      .map(([key, path]) => `${key}: ${path}`)\n      .join(\"\\n\");\n\n    return `${projectSetup}\n\n# Project Dependencies (from ${info.dependencyFile})\nMain Dependencies: ${info.mainDependencies.join(\", \")}\n\n# Available Scripts\n${Object.entries(info.scripts)\n  .map(([name, command]) => `${name}: ${command}`)\n  .join(\"\\n\")}\n\n# Test Commands\nRun All Tests: ${runAllTestsCmd}\nRun Single Test: ${runOneTestCmd}\nRun Type Check: ${runTypeCheckCmd}\n\n# Reference Examples\n${referenceExamplesSection}`;\n  }\n\n  private async formatInitialInstructions(\n    context: MessageContext,\n    customInstructions: string,\n    envDetails?: string,\n  ): Promise<string> {\n    const additionalInstructions = [envDetails, context.projectInfo]\n      .filter(Boolean)\n      .join(\"\\n\");\n\n    return `# Task\n${context.message}\n\n<instructions details=\"NEVER_OUTPUT\">\n<!-- These are internal instructions. Just follow them. Do not output. -->\n\n${customInstructions ? `# Custom Instructions\\n${customInstructions}\\n` : \"\"}\n## Initial Instructions\n- Keep messages brief, clear, and concise.\n- Break tasks into prioritized steps.\n- Use available actions sequentially.\n\n# Additional Instructions\n${additionalInstructions ? `${additionalInstructions}` : \"\"}\n</instructions>`;\n  }\n\n  private async formatFirstTimeMessage(\n    context: MessageContext,\n  ): Promise<string> {\n    const config = this.configService.getConfig();\n    const phaseConfig = this.phaseManager.getCurrentPhaseConfig();\n    const customInstructions = await this.loadCustomInstructions();\n\n    const envDetails = config.includeAllFilesOnEnvToContext\n      ? context.environmentDetails\n      : \"\";\n\n    const promptArgs: IPhasePromptArgs = {\n      message: context.message,\n      environmentDetails: envDetails,\n      projectInfo: context.projectInfo,\n      runAllTestsCmd: config.runAllTestsCmd,\n      runOneTestCmd: config.runOneTestCmd,\n      runTypeCheckCmd: config.runTypeCheckCmd,\n    };\n\n    const initialInstructions = await this.formatInitialInstructions(\n      context,\n      customInstructions,\n      envDetails,\n    );\n\n    return `${initialInstructions}\n\n## Phase Instructions\n${phaseConfig.generatePrompt(promptArgs)}`;\n  }\n\n  private formatSequentialMessage(context: MessageContext): string {\n    const phaseConfig = this.phaseManager.getCurrentPhaseConfig();\n    return phaseConfig.generatePrompt({ message: context.message });\n  }\n\n  async executeAction(actionContent: string): Promise<IActionResult> {\n    const result = await this.actionExecutor.executeAction(actionContent);\n    return result;\n  }\n}\n","import { DebugLogger } from \"@/services/logging/DebugLogger\";\nimport { singleton } from \"tsyringe\";\nimport { ModelInfo } from \"../ModelInfo\";\nimport { MessageContextBuilder } from \"./MessageContextBuilder\";\nimport { MessageContextHistory } from \"./MessageContextHistory\";\nimport { MessageContextStore } from \"./MessageContextStore\";\nimport { MessageContextTokenCount } from \"./MessageContextTokenCount\";\n\n@singleton()\nexport class MessageContextCleaner {\n  constructor(\n    private debugLogger: DebugLogger,\n    private modelInfo: ModelInfo,\n    private messageContextStore: MessageContextStore,\n    private messageContextBuilder: MessageContextBuilder,\n    private messageContextHistory: MessageContextHistory,\n    private messageContextTokenCount: MessageContextTokenCount,\n  ) {}\n\n  async cleanupContext(): Promise<boolean> {\n    const contextData = this.messageContextStore.getContextData();\n    const maxTokens = await this.modelInfo.getCurrentModelContextLength();\n    const messages = this.messageContextBuilder.getMessageContext(contextData);\n    const currentTokens =\n      this.messageContextTokenCount.estimateTokenCount(messages);\n\n    if (currentTokens <= maxTokens) {\n      return false; // No cleanup needed\n    }\n\n    const cleanedHistory = [...messages];\n    let cleanedTokens = currentTokens;\n\n    while (cleanedTokens > maxTokens && cleanedHistory.length > 0) {\n      const removedMessage = cleanedHistory.shift();\n      if (removedMessage) {\n        cleanedTokens -=\n          this.messageContextTokenCount.estimateTokenCountForMessage(\n            removedMessage,\n          );\n      }\n    }\n    const removedHistory = messages.slice(\n      0,\n      messages.length - cleanedHistory.length,\n    );\n\n    if (removedHistory.length > 0) {\n      const updatedHistory = contextData.conversationHistory.slice(\n        removedHistory.length,\n      );\n\n      // Update the context data with the cleaned history\n      this.messageContextStore.setContextData({\n        ...contextData,\n        conversationHistory: updatedHistory,\n      });\n\n      this.debugLogger.log(\"Context\", \"Context cleanup performed\", {\n        maxTokens,\n        removedMessages: removedHistory.length,\n      });\n\n      await this.modelInfo.logCurrentModelUsage(\n        this.messageContextStore.getTotalTokenCount(),\n      );\n\n      return true; // Cleanup was performed\n    }\n    return false; // No cleanup was performed\n  }\n}\n","import { LLMContextCreator } from \"@services/LLM/LLMContextCreator\";\nimport { ActionTagsExtractor } from \"@services/LLM/actions/ActionTagsExtractor\";\nimport {\n  IActionDependency,\n  IActionExecutionPlan,\n  IActionGroup,\n  WriteActionData,\n} from \"@services/LLM/actions/types/ActionTypes\";\nimport { DebugLogger } from \"@services/logging/DebugLogger\";\nimport { HtmlEntityDecoder } from \"@services/text/HTMLEntityDecoder\";\nimport path from \"path\";\nimport { autoInjectable } from \"tsyringe\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { getBlueprint, getImplementedActions } from \"./blueprints\";\n\nexport interface ActionExecutionResult {\n  actions: Array<{ action: string; result: any }>;\n  followupResponse?: string;\n  selectedModel?: string;\n}\n\n@autoInjectable()\nexport class ActionsParser {\n  private currentMessageBuffer: string = \"\";\n  private isProcessingAction: boolean = false;\n  private messageComplete: boolean = false;\n  private processedTags: string[] = [];\n  private currentModel: string = \"\";\n\n  constructor(\n    private debugLogger: DebugLogger,\n    private contextCreator: LLMContextCreator,\n    private htmlEntityDecoder: HtmlEntityDecoder,\n    private actionTagsExtractor: ActionTagsExtractor,\n  ) {}\n\n  reset() {\n    this.currentMessageBuffer = \"\";\n    this.isProcessingAction = false;\n    this.messageComplete = false;\n    this.processedTags = [];\n  }\n\n  isCompleteMessage(text: string): boolean {\n    return true;\n  }\n\n  private getActionsWithPathParam(): string[] {\n    return getImplementedActions().filter((tag) => {\n      const blueprint = getBlueprint(tag);\n      return blueprint.parameters?.some((param) => param.name === \"path\");\n    });\n  }\n\n  extractFilePath(tag: string): string | null {\n    // Get actions that have a path parameter from their blueprints\n    const fileActions = this.getActionsWithPathParam();\n    const actionMatch = new RegExp(`<(${fileActions.join(\"|\")})>`).exec(tag);\n    if (!actionMatch) return null;\n\n    const pathMatch = /<path>(.*?)<\\/path>/;\n    const match = tag.match(pathMatch);\n    if (!match) return null;\n\n    return path.resolve(process.cwd(), match[1]);\n  }\n\n  extractUrl(tag: string): string | null {\n    const actionMatch = /<fetch_url>[\\s\\S]*?<\\/fetch_url>/i.exec(tag);\n    if (!actionMatch) return null;\n\n    const urlMatch = /<url>(.*?)<\\/url>/i.exec(tag);\n    if (!urlMatch) return null;\n\n    return urlMatch[1];\n  }\n\n  private extractContentFromAction(actionContent: string): string {\n    // First try to find content tag\n    const contentMatch = actionContent.match(/<content>([\\s\\S]*?)<\\/content>/);\n    if (contentMatch) {\n      return contentMatch[1];\n    }\n\n    // If no content tag, try to find path tag for file operations\n    const pathMatch = actionContent.match(/<path>(.*?)<\\/path>/);\n    if (pathMatch) {\n      return pathMatch[1];\n    }\n\n    // For read_file actions, we want the entire content for dependency tracking\n    if (actionContent.includes(\"<read_file>\")) {\n      return actionContent;\n    }\n\n    return \"\";\n  }\n\n  private detectActionDependencies(\n    actions: IActionDependency[],\n  ): IActionDependency[] {\n    return actions.map((action) => {\n      const dependsOn: string[] = [];\n\n      if (action.type === \"write_file\") {\n        // Find read_file actions whose content is used in this write_file\n        const readActions = actions.filter((a) => {\n          if (a.type !== \"read_file\") return false;\n          const readContent = this.extractContentFromAction(a.content);\n          const writeContent = this.extractContentFromAction(action.content);\n          return writeContent.includes(readContent);\n        });\n        dependsOn.push(...readActions.map((a) => a.actionId));\n      }\n\n      if ([\"move_file\", \"delete_file\", \"copy_file\"].includes(action.type)) {\n        // These actions should wait for any write operations on the same file\n        const writeActions = actions.filter((a) => {\n          if (a.type !== \"write_file\") return false;\n          const writePath = this.extractFilePath(a.content);\n          const actionPath = this.extractFilePath(action.content);\n          return writePath === actionPath;\n        });\n        dependsOn.push(...writeActions.map((a) => a.actionId));\n      }\n\n      return { ...action, dependsOn };\n    });\n  }\n\n  private createExecutionPlan(\n    actions: IActionDependency[],\n  ): IActionExecutionPlan {\n    const groups: IActionGroup[] = [];\n    const unprocessedActions = [...actions];\n\n    // Helper to check if an action can be executed in parallel\n    const canRunInParallel = (action: IActionDependency) => {\n      const blueprint = getBlueprint(action.type);\n      return blueprint.canRunInParallel !== false;\n    };\n\n    while (unprocessedActions.length > 0) {\n      const currentGroup: IActionDependency[] = [];\n      const remainingActions: IActionDependency[] = [];\n\n      // First, find all actions that can be executed (no pending dependencies)\n      unprocessedActions.forEach((action) => {\n        const canExecute =\n          !action.dependsOn?.length ||\n          action.dependsOn.every(\n            (depId) =>\n              actions.find((a) => a.actionId === depId)?.type === \"end_task\" ||\n              !unprocessedActions.find((ua) => ua.actionId === depId),\n          );\n\n        if (canExecute) {\n          currentGroup.push(action);\n        } else {\n          remainingActions.push(action);\n        }\n      });\n\n      // If we have actions that can be executed, split them into parallel and sequential groups\n      if (currentGroup.length > 0) {\n        const parallelActions = currentGroup.filter(canRunInParallel);\n        const sequentialActions = currentGroup.filter(\n          (action) => !canRunInParallel(action),\n        );\n\n        // Add parallel actions as one group if there are any\n        if (parallelActions.length > 0) {\n          groups.push({\n            actions: parallelActions,\n            parallel: true,\n          });\n        }\n\n        // Add each sequential action as its own group\n        sequentialActions.forEach((action) => {\n          groups.push({\n            actions: [action],\n            parallel: false,\n          });\n        });\n      }\n\n      unprocessedActions.length = 0;\n      unprocessedActions.push(...remainingActions);\n    }\n\n    return { groups };\n  }\n\n  findCompleteTags(text: string): IActionExecutionPlan {\n    const combinedText = this.currentMessageBuffer + text;\n\n    // Validate tag structure before processing\n    const validationError =\n      this.actionTagsExtractor.validateStructure(combinedText);\n    if (validationError) {\n      this.debugLogger.log(\"Validation\", \"Tag structure validation failed\", {\n        error: validationError,\n      });\n      return { groups: [] };\n    }\n\n    // Find all action tags in order of appearance\n    const actions: IActionDependency[] = [];\n    const actionTags = getImplementedActions();\n    const allTagsRegex = new RegExp(\n      `<(${actionTags.join(\"|\")})>[\\\\s\\\\S]*?</\\\\1>`,\n      \"g\",\n    );\n    const matches = Array.from(combinedText.matchAll(allTagsRegex));\n\n    for (const match of matches) {\n      const content = match[0];\n      const type = match[1] as any; // The captured tag name\n      if (!this.processedTags.includes(content)) {\n        actions.push({\n          actionId: uuidv4(),\n          type,\n          content,\n        });\n        this.processedTags.push(content);\n      }\n    }\n\n    const actionsWithDependencies = this.detectActionDependencies(actions);\n    return this.createExecutionPlan(actionsWithDependencies);\n  }\n\n  appendToBuffer(chunk: string) {\n    this.currentMessageBuffer += chunk;\n  }\n\n  clearBuffer() {\n    this.currentMessageBuffer = \"\";\n    this.processedTags = [];\n  }\n\n  get buffer() {\n    return this.currentMessageBuffer;\n  }\n\n  get isProcessing() {\n    return this.isProcessingAction;\n  }\n\n  set isProcessing(value: boolean) {\n    this.isProcessingAction = value;\n  }\n\n  get isComplete() {\n    return this.messageComplete;\n  }\n\n  set isComplete(value: boolean) {\n    this.messageComplete = value;\n  }\n\n  private formatActionResult(action: string, result: any): string {\n    const actionMatch = /<(\\w+)>([\\s\\S]*?)<\\/\\1>/.exec(action);\n    if (!actionMatch) return `[Action Result] Invalid action format`;\n\n    const [_, actionType] = actionMatch;\n\n    if (actionType === \"execute_command\" && result.success) {\n      return `Command execution result:\\n\\n${result.data}\\n\\nPlease analyze this output and continue with the task.`;\n    }\n\n    if (actionType === \"read_file\" && result.success) {\n      const output = this.htmlEntityDecoder.decode(\n        JSON.stringify(result.data),\n        {\n          unescape: true,\n        },\n      );\n      if (typeof result.data === \"string\" && result.data.includes(\"# File:\")) {\n        return result.data;\n      }\n      return `Here's the content of the requested file:\\n\\n${output}\\n\\nPlease analyze this content and continue with the task.`;\n    }\n\n    if (actionType === \"fetch_url\" && result.success) {\n      return `Here's the content fetched from the URL:\\n\\n${result.data}\\n\\nPlease analyze this content and continue with the task.`;\n    }\n\n    if (actionType === \"end_task\" && result.success) {\n      return `Task completed: ${result.data}`;\n    }\n\n    if (actionType === \"end_phase\" && result.success) {\n      const data = result.data as WriteActionData;\n      if (data?.regenerate && data?.prompt) {\n        return data.prompt as string;\n      }\n      return `Phase completed. Moving to next phase.`;\n    }\n\n    if (actionType === \"relative_path_lookup\" && result.success) {\n      return `Found matching path: ${JSON.stringify(result.data)}`;\n    }\n\n    return `[Action Result] ${actionType}: ${JSON.stringify(result)} ${result.success && \"Proceed to next previously planned step.\"}`;\n  }\n\n  async parseAndExecuteActions(\n    text: string,\n    model: string,\n    llmCallback: (message: string) => Promise<string>,\n  ): Promise<ActionExecutionResult> {\n    try {\n      this.currentModel = model;\n\n      const executionPlan = this.findCompleteTags(text);\n\n      const results: Array<{ action: string; result: any }> = [];\n      let selectedModel = model;\n      let hasError = false;\n\n      for (const group of executionPlan.groups) {\n        if (hasError) break;\n\n        if (group.parallel) {\n          const actionPromises = group.actions.map((action) =>\n            this.contextCreator\n              .executeAction(action.content)\n              .then((result) => ({\n                action: action.content,\n                result,\n              })),\n          );\n          const groupResults = await Promise.all(actionPromises);\n          results.push(...groupResults);\n\n          // Check for errors in parallel actions\n          for (const result of groupResults) {\n            if (!result.result.success) {\n              this.debugLogger.log(\"Action\", \"Action failed\", {\n                action: result.action,\n                result: result.result,\n              });\n              hasError = true;\n              break;\n            }\n          }\n\n          if (!hasError) {\n            for (const result of groupResults) {\n              if (result.action.includes(\"<write_file>\")) {\n                const writeData = result.result.data as WriteActionData;\n                if (writeData?.selectedModel) {\n                  selectedModel = writeData.selectedModel;\n                  this.debugLogger.log(\n                    \"Model\",\n                    \"Updated model from write action\",\n                    {\n                      model: selectedModel,\n                    },\n                  );\n                }\n              }\n            }\n          }\n        } else {\n          for (const action of group.actions) {\n            const result = await this.contextCreator.executeAction(\n              action.content,\n            );\n\n            this.debugLogger.log(\"Action\", \"Action executed\", {\n              action: action.content,\n              result,\n            });\n\n            results.push({ action: action.content, result });\n\n            if (!result.success) {\n              this.debugLogger.log(\"Action\", \"Action failed\", {\n                action: action.content,\n                result,\n              });\n              hasError = true;\n              break;\n            }\n\n            if (action.type === \"write_file\") {\n              const writeData = result.data as WriteActionData;\n              if (writeData?.selectedModel) {\n                selectedModel = writeData.selectedModel;\n                this.debugLogger.log(\n                  \"Model\",\n                  \"Updated model from write action\",\n                  {\n                    model: selectedModel,\n                  },\n                );\n              }\n            }\n          }\n        }\n      }\n\n      const endTaskAction = results.find(\n        ({ action, result }) => action.includes(\"<end_task>\") && result.success,\n      );\n\n      if (endTaskAction) {\n        this.debugLogger.log(\"EndTask\", \"Task completed\", {\n          message: endTaskAction.result.data,\n        });\n        return { actions: results, selectedModel };\n      }\n\n      const actionResults = results\n        .map(({ action, result }) => this.formatActionResult(action, result))\n        .join(\"\\n\\n\");\n\n      // Only get followupResponse if there were no errors\n      let followupResponse;\n      if (!hasError) {\n        followupResponse = await llmCallback(actionResults);\n        this.debugLogger.log(\n          \"Response\",\n          \"Received LLM response for action results\",\n          {\n            response: followupResponse,\n            selectedModel,\n          },\n        );\n      }\n\n      return { actions: results, followupResponse, selectedModel };\n    } catch (error) {\n      console.error(\"Error in parseAndExecuteActions:\", error);\n      this.debugLogger.log(\"Error\", \"Failed to parse and execute actions\", {\n        error,\n      });\n      return { actions: [] };\n    }\n  }\n}\n","import { autoInjectable, singleton } from \"tsyringe\";\nimport { MessageContextCleaner } from \"./MessageContextCleanup\";\nimport { MessageContextStore } from \"./MessageContextStore\";\n\nimport { MessageContextLogger } from \"./MessageContextLogger\";\n\n@singleton()\n@autoInjectable()\nexport class MessageContextLimiter {\n  constructor(\n    private messageContextCleanup: MessageContextCleaner,\n    private messageContextStore: MessageContextStore,\n    private messageContextLogger: MessageContextLogger,\n  ) {}\n\n  public async cleanupContext(): Promise<boolean> {\n    const wasCleaned = await this.messageContextCleanup.cleanupContext();\n\n    if (wasCleaned) {\n      this.updateLogFile();\n      return true;\n    }\n    return false;\n  }\n\n  private updateLogFile(): void {\n    // Skip logging in test environment or if disabled\n    if (process.env.NODE_ENV === \"test\" || !this.isLoggingEnabled()) return;\n    this.messageContextLogger.updateConversationHistory(\n      this.messageContextStore.getContextData().conversationHistory,\n      this.messageContextStore.getContextData().systemInstructions,\n    );\n  }\n\n  private isLoggingEnabled(): boolean {\n    return this.messageContextLogger.getConversationLogPath() !== null;\n  }\n}\n","export interface IMessageContent {\n  type: string;\n  text: string;\n  cache_control?: {\n    type: \"ephemeral\";\n  };\n}\n\n// Matches any Anthropic model pattern:\n// - Starts with 'anthropic/claude-'\n// - Followed by version number (3 or 3.5 or 3-5)\n// - Followed by model type (opus, sonnet, haiku)\n// - Optionally followed by date (YYYYMMDD)\n// - Optionally followed by :beta\nconst ANTHROPIC_MODEL_REGEX =\n  /^anthropic\\/claude-(?:3(?:[.-]5)?)-(?:opus|sonnet|haiku)(?:-\\d{8})?(?::beta)?$/;\n\nconst MAX_CHUNK_SIZE = 8000;\nconst MAX_CACHE_BLOCKS = 4;\n\n// Lower thresholds to enable more effective caching\nconst MIN_CACHE_TOKENS = {\n  opus: 256, // Cache larger blocks for opus given higher cost\n  sonnet: 128, // Balance between caching and cost\n  haiku: 64, // More aggressive caching for cheaper model\n} as const;\n\nexport const isAnthropicModel = (model: string): boolean => {\n  return ANTHROPIC_MODEL_REGEX.test(model);\n};\n\nexport const getModelType = (\n  model: string,\n): keyof typeof MIN_CACHE_TOKENS | null => {\n  const match = model.match(/(?:opus|sonnet|haiku)/)?.[0];\n  return (match as keyof typeof MIN_CACHE_TOKENS) || null;\n};\n\nexport const estimateTokens = (text: string): number => {\n  // Count code blocks and technical patterns more accurately\n  const codeBlockMatches = text.match(/```[\\s\\S]*?```/g) || [];\n  let codeTokens = 0;\n  let regularContent = text;\n\n  for (const codeBlock of codeBlockMatches) {\n    const codeContent = codeBlock.slice(3, -3); // Remove ``` markers\n    codeTokens += Math.ceil(codeContent.length / 5.5);\n    codeTokens += 2; // Add tokens for ``` markers\n    regularContent = regularContent.replace(codeBlock, \"\");\n  }\n\n  // Regular text uses more characters per token\n  const regularTokens = Math.ceil(regularContent.length / 3.8);\n\n  return codeTokens + regularTokens;\n};\n\nexport const shouldApplyCache = (\n  content: string,\n  modelType: keyof typeof MIN_CACHE_TOKENS | null,\n  messageIndex: number,\n): boolean => {\n  if (!modelType || messageIndex >= MAX_CACHE_BLOCKS) return false;\n\n  const minTokens = MIN_CACHE_TOKENS[modelType];\n  return estimateTokens(content) >= minTokens;\n};\n\nexport const splitContentIntoChunks = (content: string): string[] => {\n  if (content.length <= MAX_CHUNK_SIZE) {\n    return [content];\n  }\n\n  const chunks: string[] = [];\n  let remaining = content;\n\n  while (remaining.length > 0) {\n    let chunkSize = MAX_CHUNK_SIZE;\n    if (remaining.length > MAX_CHUNK_SIZE) {\n      // Look for natural break points\n      const naturalBreak = remaining\n        .slice(0, MAX_CHUNK_SIZE)\n        .lastIndexOf(\"\\n\\n\");\n      if (naturalBreak > MAX_CHUNK_SIZE * 0.5) {\n        chunkSize = naturalBreak + 2; // Add 2 to include the \\n\\n\n      }\n    }\n    const chunk = remaining.slice(0, chunkSize);\n    chunks.push(chunk);\n    remaining = remaining.slice(chunkSize);\n  }\n\n  return chunks;\n};\n\nexport const formatMessageContent = (\n  content: string,\n  model: string,\n  messageIndex: number,\n  totalMessages: number,\n): string | IMessageContent[] => {\n  if (!isAnthropicModel(model)) {\n    return content;\n  }\n\n  const modelType = getModelType(model);\n  const shouldCache = shouldApplyCache(content, modelType, messageIndex);\n  const chunks = splitContentIntoChunks(content);\n\n  // For single chunk content\n  if (chunks.length === 1) {\n    return [\n      {\n        type: \"text\",\n        text: content,\n        ...(shouldCache && { cache_control: { type: \"ephemeral\" } }),\n      },\n    ];\n  }\n\n  // For multi-chunk content, prioritize caching larger chunks\n  if (shouldCache) {\n    const chunksWithTokens = chunks.map((chunk, idx) => ({\n      chunk,\n      tokens: estimateTokens(chunk),\n      index: idx,\n    }));\n\n    // Sort by token count descending\n    chunksWithTokens.sort((a, b) => b.tokens - a.tokens);\n\n    // Take top chunks that fit within remaining cache blocks\n    const remainingBlocks = MAX_CACHE_BLOCKS - messageIndex;\n    const chunksToCacheIndices = new Set(\n      chunksWithTokens.slice(0, remainingBlocks).map((c) => c.index),\n    );\n\n    return chunks.map((chunk, idx) => ({\n      type: \"text\",\n      text: chunk,\n      ...(chunksToCacheIndices.has(idx) && {\n        cache_control: { type: \"ephemeral\" },\n      }),\n    }));\n  }\n\n  // For non-cached content\n  return chunks.map((chunk) => ({\n    type: \"text\",\n    text: chunk,\n  }));\n};","// services/LLM/OpenRouterAPI.ts\n/* eslint-disable no-useless-catch */\nimport { MessageContextHistory } from \"@/services/LLM/context/MessageContextHistory\";\nimport { MessageContextLimiter } from \"@/services/LLM/context/MessageContextLimiter\";\nimport { MessageContextTokenCount } from \"@/services/LLM/context/MessageContextTokenCount\";\nimport { openRouterClient } from \"@constants/openRouterClient\";\nimport {\n  IConversationHistoryMessage,\n  ILLMProvider,\n} from \"@services/LLM/ILLMProvider\";\nimport { ModelInfo } from \"@services/LLM/ModelInfo\";\nimport { ModelManager } from \"@services/LLM/ModelManager\";\nimport { ModelScaler } from \"@services/LLM/ModelScaler\";\nimport {\n  formatMessageContent,\n  IMessageContent,\n  isAnthropicModel,\n} from \"@services/LLM/utils/ModelUtils\";\nimport { DebugLogger } from \"@services/logging/DebugLogger\";\nimport { HtmlEntityDecoder } from \"@services/text/HTMLEntityDecoder\";\nimport { inject, singleton } from \"tsyringe\";\nimport { OpenRouterAPICostTracking } from \"./OpenRouterAPICostTracking\";\n\nexport class LLMError extends Error {\n  constructor(\n    message: string,\n    public readonly type: string,\n    public readonly details: Record<string, unknown> = {},\n  ) {\n    super(message);\n    this.name = \"LLMError\";\n  }\n}\n\ninterface IFormattedMessage {\n  role: string;\n  content: string | IMessageContent[];\n}\n\ninterface IStreamError {\n  message?: string;\n  details?: Record<string, unknown>;\n}\n\n@singleton()\nexport class OpenRouterAPI implements ILLMProvider {\n  private readonly httpClient: typeof openRouterClient;\n  private streamBuffer: string = \"\";\n  private maxRetries: number = 3;\n  private retryDelay: number = 1000;\n  private stream: any;\n  private aborted: boolean = false;\n\n  constructor(\n    private htmlEntityDecoder: HtmlEntityDecoder,\n    private modelManager: ModelManager,\n    private modelInfo: ModelInfo,\n    private debugLogger: DebugLogger,\n    private modelScaler: ModelScaler,\n    @inject(OpenRouterAPICostTracking)\n    private costTracker: OpenRouterAPICostTracking,\n    private messageContextHistory: MessageContextHistory,\n    private messageContextLimiter: MessageContextLimiter,\n    private messageContextTokenCount: MessageContextTokenCount,\n  ) {\n    this.httpClient = openRouterClient;\n    this.initializeModelInfo();\n  }\n\n  private async initializeModelInfo(): Promise<void> {\n    try {\n      await this.modelInfo.initialize();\n    } catch (error) {\n      this.debugLogger.log(\"Model\", \"Failed to initialize model info\", {\n        error,\n      });\n    }\n  }\n\n  private getAnthropicHeaders(model: string): Record<string, string> {\n    if (!isAnthropicModel(model)) {\n      return {};\n    }\n\n    return {\n      \"anthropic-beta\": \"prompt-caching-2024-07-31\",\n      \"anthropic-version\": \"2023-06-01\",\n    };\n  }\n\n  private async makeRequest(\n    endpoint: string,\n    data: any,\n    options: any = {},\n  ): Promise<any> {\n    const model = data.model;\n    const headers = this.getAnthropicHeaders(model);\n\n    return this.httpClient.post(endpoint, data, {\n      ...options,\n      headers: {\n        ...options.headers,\n        ...headers,\n      },\n    });\n  }\n\n  private async handleLLMError(\n    error: Error | LLMError | unknown,\n  ): Promise<LLMError> {\n    if ((error as any)?.response?.data) {\n      const data = (error as any).response.data;\n\n      if (data.error?.message) {\n        return new LLMError(data.error.message, \"API_ERROR\", data.error);\n      }\n\n      if (\n        typeof data.error === \"string\" &&\n        data.error.includes(\"context length\")\n      ) {\n        const model = this.modelManager.getCurrentModel();\n        const contextLimit = await this.modelInfo.getModelContextLength(model);\n        return new LLMError(\n          \"Maximum context length exceeded\",\n          \"CONTEXT_LENGTH_EXCEEDED\",\n          {\n            maxLength: contextLimit,\n            currentLength: this.messageContextTokenCount.getTotalTokenCount(),\n          },\n        );\n      }\n    }\n\n    if (error instanceof LLMError) {\n      return error;\n    }\n\n    return new LLMError(\n      (error as Error)?.message || \"An unknown error occurred\",\n      \"UNKNOWN_ERROR\",\n      { originalError: error },\n    );\n  }\n\n  private formatMessages(\n    messages: IConversationHistoryMessage[],\n    model: string,\n  ): IFormattedMessage[] {\n    // Filter out messages with empty content before formatting\n    const filteredMessages = messages.filter(\n      (msg) => msg.content?.trim().length > 0,\n    );\n\n    return filteredMessages.map((msg, index) => ({\n      role: msg.role,\n      content: formatMessageContent(\n        msg.content,\n        model,\n        index,\n        filteredMessages.length,\n      ),\n    }));\n  }\n\n  async sendMessage(\n    model: string,\n    message: string,\n    options?: Record<string, unknown>,\n  ): Promise<string> {\n    const messages = this.getConversationContext();\n    const currentModel = this.modelManager.getCurrentModel() || model;\n\n    try {\n      await this.modelInfo.setCurrentModel(currentModel);\n\n      const formattedMessages = this.formatMessages(\n        [...messages, { role: \"user\", content: message }],\n        currentModel,\n      );\n\n      const response = await this.makeRequest(\"/chat/completions\", {\n        model: currentModel,\n        messages: formattedMessages,\n        ...options,\n      });\n\n      const assistantMessage = response.data.choices[0].message.content;\n\n      this.messageContextHistory.addMessage(\"user\", message);\n      this.messageContextHistory.addMessage(\"assistant\", assistantMessage);\n\n      const priceAll = this.modelInfo.getCurrentModelInfo()?.pricing;\n      const usage = this.modelInfo.getUsageHistory();\n      this.costTracker.logChatCosts(priceAll, usage);\n\n      return assistantMessage;\n    } catch (error) {\n      throw await this.handleLLMError(error);\n    }\n  }\n\n  async sendMessageWithContext(\n    model: string,\n    message: string,\n    systemInstructions?: string,\n    options?: Record<string, unknown>,\n  ): Promise<string> {\n    if (systemInstructions) {\n      this.addSystemInstructions(systemInstructions);\n    }\n    return this.sendMessage(model, message, options);\n  }\n\n  async clearConversationContext(): Promise<void> {\n    this.messageContextHistory.clear();\n  }\n\n  getConversationContext(): IConversationHistoryMessage[] {\n    return this.messageContextHistory.getMessages();\n  }\n\n  addSystemInstructions(instructions: string): void {\n    this.messageContextHistory.setSystemInstructions(instructions);\n    this.modelInfo.logCurrentModelUsage(\n      this.messageContextTokenCount.getTotalTokenCount(),\n    );\n  }\n\n  async getAvailableModels(): Promise<string[]> {\n    try {\n      await this.modelInfo.initialize();\n      return this.modelInfo.getAllModels();\n    } catch (error) {\n      throw await this.handleLLMError(error);\n    }\n  }\n\n  async validateModel(model: string): Promise<boolean> {\n    return this.modelInfo.isModelAvailable(model);\n  }\n\n  async getModelInfo(model: string): Promise<Record<string, unknown>> {\n    const info = await this.modelInfo.getModelInfo(model);\n    return info ? ({ ...info } as Record<string, unknown>) : {};\n  }\n\n  private async handleStreamError(\n    error: LLMError,\n    message: string,\n    callback: (chunk: string, error?: LLMError) => void,\n  ): Promise<void> {\n    this.debugLogger.log(\"Model\", \"Stream error\", {\n      error: error.type,\n      message,\n    });\n\n    if (error.type === \"CONTEXT_LENGTH_EXCEEDED\") {\n      const wasContextCleaned =\n        await this.messageContextLimiter.cleanupContext();\n      if (wasContextCleaned) {\n        await this.streamMessage(\n          this.modelManager.getCurrentModel(),\n          message,\n          callback,\n        );\n        return;\n      }\n    }\n\n    callback(\"\", error);\n  }\n\n  private async retryStreamOperation<T>(\n    operation: () => Promise<T>,\n    retries: number = this.maxRetries,\n  ): Promise<T> {\n    try {\n      if (this.aborted) {\n        throw new LLMError(\"Aborted\", \"ABORTED\");\n      }\n      return await operation();\n    } catch (error) {\n      if (retries > 0 && this.isRetryableError(error)) {\n        await new Promise((resolve) => setTimeout(resolve, this.retryDelay));\n        return this.retryStreamOperation(operation, retries - 1);\n      }\n\n      if (error instanceof LLMError) {\n        throw error;\n      }\n      throw await this.handleLLMError(error);\n    }\n  }\n\n  private isRetryableError(error: unknown): boolean {\n    if (error instanceof LLMError) {\n      return (\n        error.type === \"NETWORK_ERROR\" ||\n        error.type === \"CONTEXT_LENGTH_EXCEEDED\" ||\n        error.type === \"RATE_LIMIT_EXCEEDED\"\n      );\n    }\n    const err = error as { code?: string; message?: string };\n    return !!(\n      err.code === \"ECONNRESET\" ||\n      err.code === \"ETIMEDOUT\" ||\n      err.message?.includes(\"network\") ||\n      err.message?.includes(\"timeout\")\n    );\n  }\n\n  private async processCompleteMessage(message: string): Promise<{\n    content: string;\n    error?: IStreamError;\n  }> {\n    try {\n      const jsonStr = message.replace(/^data: /, \"\").trim();\n      if (\n        !jsonStr ||\n        jsonStr === \"[DONE]\" ||\n        (!jsonStr.startsWith(\"{\") && !jsonStr.startsWith(\"data: {\"))\n      ) {\n        return { content: \"\" };\n      }\n\n      const parsed = JSON.parse(jsonStr);\n\n      if (parsed.error) {\n        return { content: \"\", error: parsed.error };\n      }\n\n      if (parsed.usage) {\n        await this.modelInfo.logDetailedUsage(parsed.usage);\n      }\n\n      const deltaContent = parsed.choices?.[0]?.delta?.content;\n      if (!deltaContent) {\n        return { content: \"\" };\n      }\n\n      const decodedContent = this.htmlEntityDecoder.decode(deltaContent);\n\n      return { content: decodedContent };\n    } catch (e) {\n      this.debugLogger.log(\"Error\", \"Error parsing stream chunk\", { error: e });\n      return { content: \"\" };\n    }\n  }\n\n  private async parseStreamChunk(chunk: string): Promise<{\n    content: string;\n    error?: IStreamError;\n  }> {\n    this.streamBuffer += chunk;\n\n    let content = \"\";\n    let error;\n\n    const messages = this.streamBuffer.split(\"\\n\");\n    this.streamBuffer = messages.pop() || \"\";\n\n    for (const message of messages) {\n      const result = await this.processCompleteMessage(message);\n      if (result.error) error = result.error;\n      content += result.content;\n    }\n\n    return { content, error };\n  }\n\n  async streamMessage(\n    model: string,\n    message: string,\n    callback: (chunk: string, error?: LLMError) => void,\n    options?: Record<string, unknown>,\n  ): Promise<void> {\n    const messages = this.getConversationContext();\n    const currentModel = this.modelManager.getCurrentModel() || model;\n\n    let assistantMessage = \"\";\n    this.streamBuffer = \"\";\n\n    try {\n      await this.modelInfo.setCurrentModel(currentModel);\n\n      const formattedMessages = this.formatMessages(\n        [...messages, { role: \"user\", content: message }],\n        currentModel,\n      );\n\n      const streamOperation = async () => {\n        const response = await this.makeRequest(\n          \"/chat/completions\",\n          {\n            model: currentModel,\n            messages: formattedMessages,\n            stream: true,\n            ...options,\n          },\n          {\n            responseType: \"stream\",\n            timeout: 0,\n          },\n        );\n\n        try {\n          this.stream = response.data;\n\n          await new Promise<void>((resolve, reject) => {\n            const handleError = (err: Error) => {\n              this.debugLogger.log(\"Error\", \"Stream error\", { error: err });\n              reject(err);\n            };\n\n            this.stream.on(\"data\", async (chunk: Buffer) => {\n              if (this.aborted) {\n                this.cleanupStream();\n                return;\n              }\n\n              const { content, error } = await this.parseStreamChunk(\n                chunk.toString(),\n              );\n\n              if (error) {\n                const llmError = new LLMError(\n                  error.message || \"Stream error\",\n                  \"STREAM_ERROR\",\n                  error.details || {},\n                );\n                this.handleStreamError(llmError, message, callback);\n                reject(llmError);\n                return;\n              }\n\n              if (content) {\n                assistantMessage += content;\n                callback(content);\n              }\n            });\n\n            this.stream.on(\"end\", async () => {\n              if (this.aborted) return;\n\n              if (this.streamBuffer) {\n                const { content, error } = await this.parseStreamChunk(\n                  this.streamBuffer,\n                );\n                if (error) {\n                  handleError(\n                    new LLMError(\n                      error.message || \"Stream error\",\n                      \"STREAM_ERROR\",\n                      error.details || {},\n                    ),\n                  );\n                  return;\n                }\n                if (content) {\n                  assistantMessage += content;\n                  callback(content);\n                }\n              }\n              this.cleanupStream();\n              resolve();\n            });\n\n            this.stream.on(\"error\", handleError);\n          });\n\n          if (assistantMessage && !this.aborted) {\n            this.messageContextHistory.addMessage(\"user\", message);\n            this.messageContextHistory.addMessage(\n              \"assistant\",\n              assistantMessage,\n            );\n\n            const priceAll = this.modelInfo.getCurrentModelInfo()?.pricing;\n            const usage = this.modelInfo.getUsageHistory();\n            this.costTracker.logChatCosts(priceAll, usage);\n          }\n        } catch (error) {\n          throw error;\n        }\n      };\n\n      await this.retryStreamOperation(streamOperation);\n    } catch (error) {\n      const llmError =\n        error instanceof LLMError ? error : await this.handleLLMError(error);\n      await this.handleStreamError(llmError, message, callback);\n\n      if (assistantMessage && !this.aborted) {\n        this.messageContextHistory.addMessage(\"user\", message);\n        this.messageContextHistory.addMessage(\"assistant\", assistantMessage);\n\n        const priceAll = this.modelInfo.getCurrentModelInfo()?.pricing;\n        const usage = this.modelInfo.getUsageHistory();\n        this.costTracker.logChatCosts(priceAll, usage);\n      }\n    } finally {\n      this.cleanupStream();\n    }\n  }\n\n  private cleanupStream(): void {\n    if (this.stream) {\n      this.stream.removeAllListeners();\n      this.stream.destroy();\n      this.stream = null;\n    }\n    this.streamBuffer = \"\";\n    this.aborted = false;\n  }\n\n  cancelStream() {\n    this.aborted = true;\n    if (this.stream) {\n      this.stream.removeAllListeners();\n      this.stream.destroy();\n      this.stream = null;\n    }\n  }\n}\n","// OpenRouterAPICostTracking.ts\nimport { autoInjectable } from \"tsyringe\";\n\ninterface PriceInfo {\n  prompt: string;\n  completion: string;\n  image: string;\n  request: string;\n}\n\ninterface UsageEntry {\n  prompt_tokens: number;\n  completion_tokens: number;\n  total_tokens: number;\n}\n\ninterface UsageHistory {\n  [modelName: string]: UsageEntry[];\n}\n\n@autoInjectable()\nexport class OpenRouterAPICostTracking {\n  constructor() {}\n\n  private calculateCosts(priceAll: PriceInfo, usage: UsageHistory) {\n    const promptRate = parseFloat(priceAll.prompt);\n    const completionRate = parseFloat(priceAll.completion);\n\n    let currentCost = 0;\n    let totalCost = 0;\n\n    for (const modelKey in usage) {\n      const modelUsage = usage[modelKey];\n      if (modelUsage.length > 0) {\n        // Calculate total cost for the model\n        const modelTotalCost = modelUsage.reduce((sum, entry) => {\n          const cost =\n            entry.prompt_tokens * promptRate +\n            entry.completion_tokens * completionRate;\n          return sum + cost;\n        }, 0);\n\n        totalCost += modelTotalCost;\n\n        // Calculate current cost (last usage entry for the model)\n        const lastUsage = modelUsage[modelUsage.length - 1];\n        currentCost =\n          lastUsage.prompt_tokens * promptRate +\n          lastUsage.completion_tokens * completionRate;\n      }\n    }\n\n    return {\n      currentCost,\n      totalCost,\n    };\n  }\n\n  public logChatCosts(\n    priceAll: PriceInfo | undefined,\n    usage: UsageHistory,\n  ): void {\n    if (priceAll && usage) {\n      const { currentCost, totalCost } = this.calculateCosts(priceAll, usage);\n\n      console.log(\"Current Chat Cost: $\", currentCost.toFixed(10));\n      console.log(\"Total Chat Cost:   $\", totalCost.toFixed(10));\n    } else {\n      console.log(\n        \"PriceInfo or UsageHistory is undefined, cannot calculate costs.\",\n      );\n    }\n  }\n}\n","import {\n  IConversationHistoryMessage,\n  ILLMProvider,\n} from \"@services/LLM/ILLMProvider\";\nimport { OpenRouterAPI } from \"@services/LLMProviders/OpenRouter/OpenRouterAPI\";\nimport { autoInjectable, container, singleton } from \"tsyringe\";\n\nexport enum LLMProviderType {\n  OpenRouter = \"open-router\",\n}\n\n@singleton()\n@autoInjectable()\nexport class LLMProvider implements ILLMProvider {\n  private providers: Map<LLMProviderType, ILLMProvider>;\n  private currentProvider: ILLMProvider | null = null;\n\n  constructor() {\n    this.providers = new Map();\n    this.initializeProvider(LLMProviderType.OpenRouter);\n  }\n\n  private initializeProvider(type: LLMProviderType): void {\n    let provider: ILLMProvider;\n\n    switch (type) {\n      case LLMProviderType.OpenRouter:\n        provider = container.resolve(OpenRouterAPI);\n        break;\n      default:\n        throw new Error(`Unsupported provider type: ${type}`);\n    }\n\n    this.providers.set(type, provider);\n    this.currentProvider = provider;\n  }\n\n  public static getInstance(type: LLMProviderType): ILLMProvider {\n    const provider = container.resolve(LLMProvider).getProvider(type);\n    if (!provider) {\n      throw new Error(`Unsupported provider type: ${type}`);\n    }\n    return provider;\n  }\n\n  private getProvider(type: LLMProviderType): ILLMProvider | undefined {\n    return this.providers.get(type);\n  }\n\n  public sendMessage(\n    model: string,\n    message: string,\n    options?: Record<string, unknown>,\n  ): Promise<string> {\n    if (!this.currentProvider) {\n      throw new Error(\"Current provider not set\");\n    }\n    return this.currentProvider.sendMessage(model, message, options);\n  }\n\n  public sendMessageWithContext(\n    model: string,\n    message: string,\n    systemInstructions?: string,\n    options?: Record<string, unknown>,\n  ): Promise<string> {\n    if (!this.currentProvider) {\n      throw new Error(\"Current provider not set\");\n    }\n    return this.currentProvider.sendMessageWithContext(\n      model,\n      message,\n      systemInstructions,\n      options,\n    );\n  }\n\n  public clearConversationContext(): void {\n    if (!this.currentProvider) {\n      throw new Error(\"Current provider not set\");\n    }\n    this.currentProvider.clearConversationContext();\n  }\n\n  public getConversationContext(): IConversationHistoryMessage[] {\n    if (!this.currentProvider) {\n      throw new Error(\"Current provider not set\");\n    }\n    return this.currentProvider.getConversationContext();\n  }\n\n  public addSystemInstructions(instructions: string): void {\n    if (!this.currentProvider) {\n      throw new Error(\"Current provider not set\");\n    }\n    this.currentProvider.addSystemInstructions(instructions);\n  }\n\n  public getAvailableModels(): Promise<string[]> {\n    if (!this.currentProvider) {\n      throw new Error(\"Current provider not set\");\n    }\n    return this.currentProvider.getAvailableModels();\n  }\n\n  public validateModel(model: string): Promise<boolean> {\n    if (!this.currentProvider) {\n      throw new Error(\"Current provider not set\");\n    }\n    return this.currentProvider.validateModel(model);\n  }\n\n  public getModelInfo(model: string): Promise<Record<string, unknown>> {\n    if (!this.currentProvider) {\n      throw new Error(\"Current provider not set\");\n    }\n    return this.currentProvider.getModelInfo(model);\n  }\n\n  public streamMessage(\n    model: string,\n    message: string,\n    callback: (chunk: string) => void,\n    options?: Record<string, unknown>,\n  ): Promise<void> {\n    if (!this.currentProvider) {\n      throw new Error(\"Current provider not set\");\n    }\n    return this.currentProvider.streamMessage(\n      model,\n      message,\n      callback,\n      options,\n    );\n  }\n}\n","import { ActionsParser } from \"@services/LLM/actions/ActionsParser\";\n\nimport { DebugLogger } from \"@services/logging/DebugLogger\";\nimport { autoInjectable } from \"tsyringe\";\nimport { WriteStream } from \"tty\";\nimport { LLMError } from \"../LLMProviders/OpenRouter/OpenRouterAPI\";\n\nconst MAX_BUFFER_SIZE = 10 * 1024 * 1024; // 10MB default max buffer size\nconst CHUNK_SIZE = 1024 * 1024; // 1MB chunk size for processing\nconst STREAM_TIMEOUT = 10000; // 10 seconds timeout for inactivity\n\nexport interface StreamCallback {\n  (message: string): Promise<string>;\n}\n\nexport interface StreamChunkCallback {\n  (chunk: string, error?: LLMError): void;\n}\n\ninterface ErrorDisplay {\n  title: string;\n  details: string;\n  suggestion?: string;\n}\n\n@autoInjectable()\nexport class StreamHandler {\n  private responseBuffer: string = \"\";\n  private isStreamComplete: boolean = false;\n  private lastActivityTimestamp: number = Date.now();\n  private bufferSize: number = 0;\n  private inactivityTimer: NodeJS.Timeout | null = null;\n\n  constructor(\n    private debugLogger: DebugLogger,\n    private actionsParser: ActionsParser,\n  ) {}\n\n  reset() {\n    this.responseBuffer = \"\";\n    this.isStreamComplete = false;\n    this.lastActivityTimestamp = Date.now();\n    this.bufferSize = 0;\n    this.actionsParser.reset();\n    this.clearInactivityTimer();\n  }\n\n  get response() {\n    return this.responseBuffer;\n  }\n\n  private formatErrorDisplay(error: LLMError): ErrorDisplay {\n    if (!error)\n      return { title: \"Unknown Error\", details: \"An unknown error occurred\" };\n\n    switch (error.type) {\n      case \"CONTEXT_LENGTH_EXCEEDED\":\n        return {\n          title: \"Context Length Exceeded\",\n          details: `Maximum context length (${error.details?.maxLength} tokens) exceeded. Current length: ${error.details?.currentLength} tokens.`,\n          suggestion:\n            \"Try reducing the conversation history or splitting your request into smaller chunks.\",\n        };\n      case \"RATE_LIMIT_EXCEEDED\":\n        return {\n          title: \"Rate Limit Exceeded\",\n          details: `API rate limit reached.${\n            error.details?.retryAfter\n              ? ` Try again in ${error.details.retryAfter} seconds.`\n              : \"\"\n          }`,\n          suggestion: \"Please wait before making another request.\",\n        };\n      case \"MODEL_ERROR\":\n        return {\n          title: \"Model Error\",\n          details: `Error with model${\n            error.details?.modelId ? ` ${error.details.modelId}` : \"\"\n          }: ${error.message}`,\n          suggestion:\n            \"Try using a different model or reducing the complexity of your request.\",\n        };\n      case \"INSUFFICIENT_QUOTA\":\n        return {\n          title: \"Insufficient Token Budget\",\n          details: `Required: ${error.details?.required}, Available: ${error.details?.available}`,\n          suggestion: \"Please check your API quota or upgrade your plan.\",\n        };\n      case \"NETWORK_ERROR\":\n        return {\n          title: \"Network Error\",\n          details: error.message,\n          suggestion: \"Check your internet connection and try again.\",\n        };\n      case \"STREAM_TIMEOUT\":\n        return {\n          title: \"Stream Timeout\",\n          details: \"The stream was inactive for too long.\",\n          suggestion:\n            \"Try your request again. If the issue persists, try reducing the complexity of your request.\",\n        };\n      case \"STREAM_ERROR\":\n        return {\n          title: \"Stream Error\",\n          details: error.message,\n          suggestion:\n            \"Try your request again with a different prompt or model.\",\n        };\n      case \"BUFFER_OVERFLOW\":\n        return {\n          title: \"Buffer Overflow\",\n          details: \"The stream buffer has exceeded its maximum size limit.\",\n          suggestion:\n            \"Try processing the stream in smaller chunks or increase the buffer size limit.\",\n        };\n      default:\n        return {\n          title: \"Error\",\n          details: error.message || \"An unexpected error occurred\",\n          suggestion:\n            \"Try your request again. If the issue persists, try with different parameters.\",\n        };\n    }\n  }\n\n  private displayError(error: LLMError) {\n    const { title, details, suggestion } = this.formatErrorDisplay(error);\n\n    this.safeWriteToStdout(\"\\n\\n\");\n    this.safeWriteToStdout(\"\\x1b[31m\"); // Red color\n    this.safeWriteToStdout(`❌ ${title}\\n`);\n    this.safeWriteToStdout(\"\\x1b[0m\"); // Reset color\n\n    this.safeWriteToStdout(\"\\x1b[37m\"); // Light gray color\n    this.safeWriteToStdout(`${details}\\n`);\n\n    if (suggestion) {\n      this.safeWriteToStdout(\"\\n\");\n      this.safeWriteToStdout(\"\\x1b[36m\"); // Cyan color\n      this.safeWriteToStdout(`💡 ${suggestion}\\n`);\n    }\n\n    this.safeWriteToStdout(\"\\x1b[0m\"); // Reset color\n    this.safeWriteToStdout(\"\\n\");\n\n    // Log error to debug logger\n    this.debugLogger.log(\"Error\", details, { title, suggestion });\n  }\n\n  private safeWriteToStdout(text: string) {\n    try {\n      process.stdout.write(text);\n    } catch (error) {\n      console.error(\"Error writing to stdout\", error);\n    }\n  }\n\n  private safeClearLine() {\n    try {\n      if ((process.stdout as WriteStream).clearLine) {\n        (process.stdout as WriteStream).clearLine(0);\n      }\n    } catch (error) {\n      console.error(\"Error clearing line\", error);\n    }\n  }\n\n  private safeCursorTo(x: number) {\n    try {\n      if ((process.stdout as WriteStream).cursorTo) {\n        (process.stdout as WriteStream).cursorTo(x);\n      }\n    } catch (error) {\n      console.error(\"Error moving cursor\", error);\n    }\n  }\n\n  private processChunk(chunk: string): string[] {\n    if (!chunk) return [\"\"];\n\n    const chunks: string[] = [];\n    let remainingChunk = chunk;\n\n    while (remainingChunk.length > 0) {\n      const chunkToProcess = remainingChunk.slice(0, CHUNK_SIZE);\n      chunks.push(chunkToProcess);\n      remainingChunk = remainingChunk.slice(CHUNK_SIZE);\n    }\n\n    return chunks;\n  }\n\n  private handleBufferOverflow() {\n    // Keep the last 1MB of data when overflow occurs\n    const keepSize = 1024 * 1024;\n    this.responseBuffer = this.responseBuffer.slice(-keepSize);\n    this.bufferSize = this.responseBuffer.length;\n    this.actionsParser.clearBuffer();\n    this.actionsParser.appendToBuffer(this.responseBuffer);\n\n    this.debugLogger.log(\"Buffer Overflow\", \"Buffer size limit exceeded\", {\n      maxSize: MAX_BUFFER_SIZE,\n      currentSize: this.bufferSize,\n    });\n  }\n\n  private startInactivityTimer() {\n    this.clearInactivityTimer();\n    this.inactivityTimer = setTimeout(() => {\n      this.displayError(\n        new LLMError(\n          \"The stream was inactive for too long.\",\n          \"STREAM_TIMEOUT\",\n          { timeout: STREAM_TIMEOUT },\n        ),\n      );\n      this.reset();\n    }, STREAM_TIMEOUT);\n  }\n\n  private clearInactivityTimer() {\n    if (this.inactivityTimer) {\n      clearTimeout(this.inactivityTimer);\n      this.inactivityTimer = null;\n    }\n  }\n\n  async handleChunk(\n    chunk: string,\n    model: string,\n    llmCallback: StreamCallback,\n    streamCallback: (\n      message: string,\n      callback: StreamChunkCallback,\n    ) => Promise<void>,\n    options?: Record<string, unknown>,\n  ) {\n    this.lastActivityTimestamp = Date.now();\n    this.startInactivityTimer();\n\n    if (chunk.startsWith('{\"error\":')) {\n      try {\n        const error = JSON.parse(chunk).error;\n        const llmError = new LLMError(\n          error.message || \"Unknown error\",\n          error.type || \"UNKNOWN_ERROR\",\n          error.details,\n        );\n        this.displayError(llmError);\n        return [];\n      } catch (e) {\n        this.displayError(\n          new LLMError(\"Unknown error\", \"UNKNOWN_ERROR\", { originalError: e }),\n        );\n        return [];\n      }\n    }\n\n    const chunks = this.processChunk(chunk);\n\n    for (const subChunk of chunks) {\n      if (this.bufferSize + subChunk.length > MAX_BUFFER_SIZE) {\n        this.handleBufferOverflow();\n        this.displayError(\n          new LLMError(\"Buffer size limit exceeded\", \"BUFFER_OVERFLOW\", {\n            maxSize: MAX_BUFFER_SIZE,\n            currentSize: this.bufferSize,\n          }),\n        );\n      }\n\n      this.safeWriteToStdout(subChunk);\n      this.actionsParser.appendToBuffer(subChunk);\n      this.responseBuffer += subChunk;\n      this.bufferSize += subChunk.length;\n    }\n\n    const isMessageComplete = this.actionsParser.isCompleteMessage(\n      this.actionsParser.buffer,\n    );\n\n    if (!this.actionsParser.isComplete && isMessageComplete) {\n      this.actionsParser.isComplete = true;\n      this.isStreamComplete = true;\n      this.safeWriteToStdout(\"\\n\");\n    }\n\n    if (this.isStreamComplete && !this.actionsParser.isProcessing) {\n      this.actionsParser.isProcessing = true;\n\n      try {\n        const actionResult = await this.actionsParser.parseAndExecuteActions(\n          this.actionsParser.buffer,\n          model,\n          async (message) => {\n            let actionResponse = \"\";\n            await streamCallback(message, (chunk: string, error?: LLMError) => {\n              if (error) {\n                this.displayError(error);\n                return;\n              }\n              this.safeWriteToStdout(chunk);\n              actionResponse += chunk;\n              this.lastActivityTimestamp = Date.now();\n            });\n\n            if (this.bufferSize + actionResponse.length > MAX_BUFFER_SIZE) {\n              this.handleBufferOverflow();\n              this.displayError(\n                new LLMError(\n                  \"Buffer size limit exceeded after action\",\n                  \"BUFFER_OVERFLOW\",\n                  { maxSize: MAX_BUFFER_SIZE, currentSize: this.bufferSize },\n                ),\n              );\n            }\n\n            this.responseBuffer += actionResponse;\n            this.bufferSize += actionResponse.length;\n            return actionResponse;\n          },\n        );\n\n        // Properly reset state after action execution\n        this.actionsParser.reset();\n        this.isStreamComplete = false;\n        this.bufferSize = 0;\n\n        // Refresh terminal state for new input\n        this.safeWriteToStdout(\"\\n\");\n        this.safeWriteToStdout(\"\\x1B[?25h\"); // Show cursor\n        this.safeClearLine();\n        this.safeCursorTo(0);\n        this.safeWriteToStdout(\"> \");\n\n        this.clearInactivityTimer();\n\n        return actionResult.actions;\n      } catch (error) {\n        this.debugLogger.log(\"Error\", \"Error processing actions\", { error });\n        if (error instanceof LLMError) {\n          this.displayError(error);\n        } else {\n          this.displayError(\n            new LLMError(\n              error.message || \"Unknown error during action execution\",\n              \"ACTION_ERROR\",\n              { originalError: error },\n            ),\n          );\n        }\n        this.reset();\n        return [];\n      }\n    }\n\n    return [];\n  }\n}\n","import { DEFAULT_INSTRUCTIONS } from \"@constants/defaultInstructions\";\nimport { FileReader } from \"@services/FileManagement/FileReader\";\nimport { ActionsParser } from \"@services/LLM/actions/ActionsParser\";\nimport { ILLMProvider } from \"@services/LLM/ILLMProvider\";\nimport { LLMContextCreator } from \"@services/LLM/LLMContextCreator\";\nimport { LLMProvider, LLMProviderType } from \"@services/LLM/LLMProvider\";\nimport { DebugLogger } from \"@services/logging/DebugLogger\";\nimport { StreamHandler } from \"@services/streaming/StreamHandler\";\nimport { autoInjectable, singleton } from \"tsyringe\";\nimport { ModelManager } from \"./LLM/ModelManager\";\nimport { PhaseManager } from \"./LLM/PhaseManager\";\n\nexport interface CrackedAgentOptions {\n  root?: string;\n  instructionsPath?: string;\n  instructions?: string;\n  provider?: LLMProviderType;\n  stream?: boolean;\n  debug?: boolean;\n  options?: Record<string, unknown>;\n  clearContext?: boolean;\n  autoScaler?: boolean;\n}\n\nexport interface ExecutionResult {\n  response: string;\n  actions?: Array<{ action: string; result: any }>;\n}\n\n@autoInjectable()\n@singleton()\nexport class CrackedAgent {\n  private llm!: ILLMProvider;\n  private isFirstInteraction: boolean = true;\n  private currentModel: string = \"\";\n\n  constructor(\n    private fileReader: FileReader,\n    private contextCreator: LLMContextCreator,\n    private debugLogger: DebugLogger,\n    private actionsParser: ActionsParser,\n    private streamHandler: StreamHandler,\n    private phaseManager: PhaseManager,\n    private modelManager: ModelManager,\n  ) {}\n\n  async execute(\n    message: string,\n    options: CrackedAgentOptions,\n  ): Promise<ExecutionResult> {\n    this.phaseManager.initializePhaseConfigs();\n\n    const finalOptions = await this.setupExecution(options);\n    this.currentModel = this.modelManager.getCurrentModel();\n\n    const formattedMessage = await this.contextCreator.create(\n      message,\n      finalOptions.root,\n      this.isFirstInteraction,\n    );\n\n    // Update isFirstInteraction before returning\n    if (this.isFirstInteraction) {\n      this.isFirstInteraction = false;\n    }\n\n    this.debugLogger.log(\"Message\", \"Sending message to LLM\", {\n      message: formattedMessage,\n      conversationHistory: this.llm.getConversationContext(),\n    });\n\n    if (finalOptions.stream) {\n      return await this.handleStreamExecution(\n        formattedMessage,\n        this.currentModel,\n        finalOptions.options,\n        finalOptions.stream,\n      );\n    }\n\n    const result = await this.handleNormalExecution(\n      formattedMessage,\n      this.currentModel,\n      finalOptions.options,\n      finalOptions.stream,\n    );\n\n    return result;\n  }\n\n  private async setupExecution(options: CrackedAgentOptions) {\n    const finalOptions = {\n      root: process.cwd(),\n      provider: LLMProviderType.OpenRouter,\n      stream: false,\n      debug: false,\n      options: {},\n      clearContext: false,\n      autoScaler: false,\n      ...options,\n    };\n\n    this.debugLogger.setDebug(finalOptions.debug);\n    this.llm = LLMProvider.getInstance(finalOptions.provider);\n    this.streamHandler.reset();\n    this.actionsParser.reset();\n\n    if (finalOptions.clearContext) {\n      this.clearConversationHistory();\n    }\n\n    await this.validateModel(this.modelManager.getCurrentModel());\n    await this.setupInstructions(finalOptions);\n\n    return finalOptions;\n  }\n\n  private async validateModel(model: string) {\n    const isValidModel = await this.llm.validateModel(model);\n    if (!isValidModel) {\n      const availableModels = await this.llm.getAvailableModels();\n      throw new Error(\n        `Invalid model: ${model}. Available models: ${availableModels.join(\", \")}`,\n      );\n    }\n  }\n\n  private async setupInstructions(options: CrackedAgentOptions) {\n    if (!this.isFirstInteraction) return;\n\n    let instructions = options.instructions;\n    if (options.instructionsPath) {\n      instructions = await this.fileReader.readInstructionsFile(\n        options.instructionsPath,\n      );\n    }\n\n    if (instructions) {\n      this.debugLogger.log(\"Instructions\", \"Adding system instructions\", {\n        instructions,\n      });\n      this.llm.addSystemInstructions(instructions);\n    }\n\n    if (!instructions) {\n      this.llm.addSystemInstructions(DEFAULT_INSTRUCTIONS);\n    }\n  }\n\n  private async handleStreamExecution(\n    message: string,\n    model: string,\n    options?: Record<string, unknown>,\n    stream?: boolean,\n  ): Promise<ExecutionResult> {\n    let response = \"\";\n    await this.llm.streamMessage(\n      model,\n      message,\n      async (chunk: string) => {\n        response += chunk;\n        this.actionsParser.appendToBuffer(chunk);\n        process.stdout.write(chunk);\n      },\n      options,\n    );\n    process.stdout.write(\"\\n\");\n\n    if (!response) return { response: \"\" };\n\n    const { actions = [], followupResponse } =\n      await this.parseAndExecuteWithCallback(\n        this.actionsParser.buffer,\n        model,\n        options,\n        stream,\n      );\n\n    return {\n      response: followupResponse || response,\n      actions,\n    };\n  }\n\n  private async handleNormalExecution(\n    message: string,\n    model: string,\n    options?: Record<string, unknown>,\n    stream?: boolean,\n  ): Promise<ExecutionResult> {\n    const response = await this.llm.sendMessage(model, message, options);\n\n    this.debugLogger.log(\"Response\", \"Received LLM response\", {\n      response,\n      conversationHistory: this.llm.getConversationContext(),\n    });\n\n    if (!response) return { response: \"\" };\n\n    const { actions = [], followupResponse } =\n      await this.parseAndExecuteWithCallback(response, model, options, stream);\n\n    return {\n      response: followupResponse || response,\n      actions,\n    };\n  }\n\n  private async parseAndExecuteWithCallback(\n    response: string,\n    model: string,\n    options?: Record<string, unknown>,\n    stream?: boolean,\n  ): Promise<{\n    actions: Array<{ action: string; result: any }>;\n    followupResponse?: string;\n  }> {\n    this.actionsParser.reset();\n    const result = await this.actionsParser.parseAndExecuteActions(\n      response,\n      model,\n      async (followupMsg: string) => {\n        const formattedFollowup = await this.contextCreator.create(\n          followupMsg,\n          process.cwd(),\n          false,\n        );\n\n        if (stream) {\n          let followupResponse = \"\";\n          await this.llm.streamMessage(\n            this.currentModel,\n            formattedFollowup,\n            async (chunk: string) => {\n              followupResponse += chunk;\n              process.stdout.write(chunk);\n            },\n            options,\n          );\n          process.stdout.write(\"\\n\");\n\n          const followupResult = await this.parseAndExecuteWithCallback(\n            followupResponse,\n            this.currentModel,\n            options,\n            stream,\n          );\n\n          return followupResult.followupResponse || followupResponse;\n        } else {\n          const followupResponse = await this.llm.sendMessage(\n            this.currentModel,\n            formattedFollowup,\n            options,\n          );\n\n          const followupResult = await this.parseAndExecuteWithCallback(\n            followupResponse,\n            this.currentModel,\n            options,\n            stream,\n          );\n\n          return followupResult.followupResponse || followupResponse;\n        }\n      },\n    );\n\n    return {\n      actions: result?.actions || [],\n      followupResponse: result?.followupResponse,\n    };\n  }\n\n  getConversationHistory() {\n    return this.llm.getConversationContext();\n  }\n\n  clearConversationHistory() {\n    this.llm.clearConversationContext();\n    this.isFirstInteraction = true;\n  }\n}\n","import { Args, Command, Flags } from \"@oclif/core\";\nimport { CrackedAgent, CrackedAgentOptions } from \"@services/CrackedAgent\";\nimport { LLMProviderType } from \"@services/LLM/LLMProvider\";\nimport { ModelManager } from \"@services/LLM/ModelManager\";\nimport { OpenRouterAPI } from \"@services/LLMProviders/OpenRouter/OpenRouterAPI\";\nimport { InteractiveSessionManager } from \"@services/streaming/InteractiveSessionManager\";\nimport { StreamHandler } from \"@services/streaming/StreamHandler\";\nimport * as readline from \"readline\";\nimport { container } from \"tsyringe\";\nimport { ConfigService } from \"../services/ConfigService\";\n\nexport class Run extends Command {\n  static description = \"AI agent for performing operations on local projects\";\n\n  static examples = [\n    \"$ run 'Add error handling'\",\n    \"$ run --interactive # Start interactive mode\",\n    \"$ run --init # Initialize configuration\",\n  ];\n\n  static flags = {\n    init: Flags.boolean({\n      description: \"Initialize a default crkdrc.json configuration file\",\n      exclusive: [\"interactive\"],\n    }),\n  };\n\n  static args = {\n    message: Args.string({\n      description: \"Message describing the operation to perform\",\n      required: false,\n    }),\n  };\n\n  private configService: ConfigService;\n  private modelManager: ModelManager;\n  private streamHandler: StreamHandler;\n  private openRouterAPI: OpenRouterAPI;\n  private sessionManager: InteractiveSessionManager;\n  private rl: readline.Interface;\n\n  constructor(argv: string[], config: any) {\n    super(argv, config);\n    this.configService = container.resolve(ConfigService);\n    this.modelManager = container.resolve(ModelManager);\n    this.streamHandler = container.resolve(StreamHandler);\n    this.openRouterAPI = container.resolve(OpenRouterAPI);\n    this.sessionManager = container.resolve(InteractiveSessionManager);\n    this.rl = readline.createInterface({\n      input: process.stdin,\n      output: process.stdout,\n      prompt: \"> \",\n    });\n  }\n\n  private parseOptions(optionsString: string): Record<string, unknown> {\n    const options: Record<string, unknown> = {};\n\n    if (!optionsString) return options;\n\n    const pairs = optionsString.split(\",\");\n    for (const pair of pairs) {\n      const [key, value] = pair.trim().split(\"=\");\n      if (!key || !value) continue;\n\n      // Convert value to appropriate type\n      if (value === \"true\") options[key] = true;\n      else if (value === \"false\") options[key] = false;\n      else if (!isNaN(Number(value))) {\n        if (value.includes(\".\")) options[key] = parseFloat(value);\n        else options[key] = parseInt(value, 10);\n      } else options[key] = value;\n    }\n\n    return options;\n  }\n\n  async run(): Promise<void> {\n    const { args, flags } = await this.parse(Run);\n\n    if (flags.init) {\n      this.configService.createDefaultConfig();\n      return;\n    }\n\n    const config = this.configService.getConfig();\n\n    if (!config.openRouterApiKey) {\n      this.error(\n        \"OpenRouter API key is required. Please add it to crkdrc.json\",\n      );\n    }\n\n    const isInteractive = config.interactive ?? false;\n\n    if (isInteractive && args.message) {\n      this.error(\"Cannot provide both interactive mode and message argument\");\n    }\n\n    if (!isInteractive && !args.message) {\n      this.error(\"Must provide either interactive mode or message argument\");\n    }\n\n    try {\n      if (!config.discoveryModel) {\n        throw new Error(\"Discovery model is required in configuration\");\n      }\n\n      const options: CrackedAgentOptions = {\n        ...config,\n        options: this.parseOptions(config.options || \"\"),\n        provider: config.provider as LLMProviderType,\n      };\n\n      // Validate provider\n      if (!Object.values(LLMProviderType).includes(options.provider!)) {\n        throw new Error(`Invalid provider: ${options.provider}`);\n      }\n\n      this.modelManager.setCurrentModel(config.discoveryModel);\n\n      console.log(\n        `Using ${options.provider} provider and model: ${this.modelManager.getCurrentModel()}`,\n      );\n\n      const agent = container.resolve(CrackedAgent);\n      this.sessionManager.initialize(this.rl, agent, options);\n\n      if (isInteractive) {\n        await this.sessionManager.start();\n      } else {\n        console.log(\"Press Enter to start the stream...\");\n        this.rl.once(\"line\", async () => {\n          try {\n            const result = await agent.execute(args.message!, options);\n            if (!options.stream && result) {\n              this.log(result.response);\n              if (result.actions?.length) {\n                this.log(\"\\nExecuted Actions:\");\n                result.actions.forEach(({ action, result }) => {\n                  this.log(`\\nAction: ${action}`);\n                  this.log(`Result: ${JSON.stringify(result, null, 2)}`);\n                });\n              }\n            }\n            this.sessionManager.cleanup();\n            process.exit(0);\n          } catch (error) {\n            this.sessionManager.cleanup();\n            this.error((error as Error).message);\n          }\n        });\n      }\n    } catch (error) {\n      this.sessionManager.cleanup();\n      this.error((error as Error).message);\n    }\n  }\n}\n","import { CrackedAgent } from \"@services/CrackedAgent\";\nimport { OpenRouterAPI } from \"@services/LLMProviders/OpenRouter/OpenRouterAPI\";\nimport * as readline from \"readline\";\nimport { singleton } from \"tsyringe\";\nimport * as tty from \"tty\";\n\n@singleton()\nexport class InteractiveSessionManager {\n  private currentMessage: string = \"\";\n  private keypressHandler: ((buffer: Buffer) => void) | null = null;\n  private lineHandler: ((input: string) => void) | null = null;\n  private closeHandler: (() => void) | null = null;\n  private rl: readline.Interface | null = null;\n  private agent: CrackedAgent | null = null;\n  private options: any = null;\n\n  constructor(private openRouterAPI: OpenRouterAPI) {}\n\n  public initialize(rl: readline.Interface, agent: CrackedAgent, options: any) {\n    this.rl = rl;\n    this.agent = agent;\n    this.options = options;\n  }\n\n  private setupKeypressHandling() {\n    if (!this.rl) return;\n\n    if (process.stdin instanceof tty.ReadStream) {\n      process.stdin.setRawMode(true);\n      process.stdin.resume();\n\n      this.keypressHandler = async (buffer: Buffer) => {\n        const key = buffer.toString();\n        if (key === \"\\u001B\") {\n          // Escape key\n          this.openRouterAPI.cancelStream();\n          console.log(\"\\nStreaming cancelled.\");\n          await this.restartSession();\n        }\n      };\n\n      process.stdin.on(\"data\", this.keypressHandler);\n    }\n  }\n\n  private async restartSession() {\n    if (!this.rl) return;\n\n    console.log(\"Please type your new prompt and press enter...\");\n    this.rl.prompt();\n\n    // If we have a current message, restart with it\n    if (this.currentMessage) {\n      await this.handleInput(this.currentMessage);\n    } else {\n      // Otherwise, prompt for new input\n      this.rl.prompt();\n    }\n  }\n\n  private async handleInput(input: string) {\n    if (!this.rl || !this.agent || !this.options) return;\n\n    if (input.toLowerCase() === \"exit\") {\n      console.log(\"Goodbye!\");\n      this.cleanup();\n      process.exit(0);\n    }\n\n    this.currentMessage = input;\n\n    try {\n      const result = await this.agent.execute(input, this.options);\n      if (!this.options.stream && result) {\n        console.log(\"\\nResponse:\", result.response);\n        if (result.actions?.length) {\n          console.log(\"\\nExecuted Actions:\");\n          result.actions.forEach(({ action, result }) => {\n            console.log(`\\nAction: ${action}`);\n            console.log(`Result: ${JSON.stringify(result, null, 2)}`);\n          });\n        }\n      }\n    } catch (error) {\n      console.error(\"Error:\", (error as Error).message);\n    }\n\n    this.rl.prompt();\n  }\n\n  public async start() {\n    if (!this.rl) return;\n\n    console.log(\n      'Interactive mode started. Type \"exit\" or press Ctrl+C to quit.',\n    );\n    this.setupKeypressHandling();\n    this.rl.prompt();\n\n    this.lineHandler = async (input: string) => {\n      await this.handleInput(input);\n    };\n\n    this.closeHandler = () => {\n      this.cleanup();\n      process.exit(0);\n    };\n\n    this.rl.on(\"line\", this.lineHandler);\n    this.rl.on(\"close\", this.closeHandler);\n  }\n\n  public cleanup() {\n    if (this.keypressHandler && process.stdin instanceof tty.ReadStream) {\n      process.stdin.removeListener(\"data\", this.keypressHandler);\n      process.stdin.setRawMode(false);\n    }\n\n    if (this.lineHandler && this.rl) {\n      this.rl.removeListener(\"line\", this.lineHandler);\n    }\n\n    if (this.closeHandler && this.rl) {\n      this.rl.removeListener(\"close\", this.closeHandler);\n    }\n\n    if (this.rl) {\n      this.rl.close();\n      this.rl = null;\n    }\n\n    this.agent = null;\n    this.options = null;\n  }\n}\n"],"mappings":"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","names":["DEFAULT_INSTRUCTIONS","FileNotFoundError","Error","constructor","path","name","FileReadError","message","InvalidFileError","FileReader","readInstructionsFile","filePath","validateFilePath","readFileContent","error","FileNotFoundError","FileReadError","InvalidFileError","message","stats","stat","isFile","Error","readFile","import_tsyringe","configSchema","z","object","provider","string","customInstructions","optional","customInstructionsPath","interactive","boolean","stream","debug","options","openRouterApiKey","appUrl","default","appName","autoScaler","autoScaleMaxTryPerModel","number","includeAllFilesOnEnvToContext","discoveryModel","strategyModel","executeModel","autoScaleAvailableModels","array","id","description","maxWriteTries","maxGlobalTries","runAllTestsCmd","runOneTestCmd","runTypeCheckCmd","enableConversationLog","logDirectory","directoryScanner","defaultIgnore","maxDepth","allFiles","directoryFirst","excludeDirectories","gitDiff","excludeLockFiles","lockFiles","referenceExamples","record","projectLanguage","packageManager","ConfigService","CONFIG_PATH","resolve","GITIGNORE_PATH","ensureGitIgnore","gitignoreContent","existsSync","readFileSync","includes","updatedContent","endsWith","fs","writeFileSync","createDefaultConfig","console","log","defaultConfig","example1","example2","myService","anotherKey","JSON","stringify","chalk","yellow","green","getConfig","rawData","config","parse","parsedConfig","safeParse","success","error","Error","data","import_tsyringe","DirectoryScanner","constructor","configService","REQUIRED_IGNORE","Error","defaultOptions","config","getConfig","ignore","directoryScanner","defaultIgnore","allFiles","maxDepth","noreport","base","directoryFirst","excludeDirectories","getAllFiles","dirPath","basePath","arrayOfFiles","currentDepth","files","fs","readdirSync","forEach","file","includes","fullPath","path","join","relativePath","relative","statSync","isDirectory","push","scan","options","scanOptions","absolutePath","resolve","sort","success","data","map","f","trim","error","String","import_tsyringe","import_tsyringe","import_tsyringe","Colors","reset","cyan","yellow","green","magenta","blue","import_tsyringe","DebugLogger","constructor","debug","setDebug","formatData","data","JSON","stringify","replace","String","log","type","message","timestamp","Date","toISOString","divider","repeat","subDivider","console","Colors","cyan","reset","yellow","magenta","formattedData","split","map","line","join","blue","import_tsyringe","import_tsyringe","createOpenRouterClient","baseURL","configService","container","resolve","ConfigService","config","getConfig","headers","Authorization","openRouterApiKey","appUrl","appName","axios","create","timeout","maxBodyLength","Infinity","maxContentLength","openRouterClient","import_tsyringe","ModelInfo","constructor","debugLogger","modelInfoMap","currentModel","currentModelInfo","initialized","usageHistory","Map","initialize","response","openRouterClient","get","models","data","clear","forEach","model","set","id","error","log","ensureInitialized","setCurrentModel","modelId","isModelAvailable","Error","Array","from","keys","join","modelInfo","contextLength","context_length","maxCompletionTokens","top_provider","max_completion_tokens","getCurrentModel","getModelInfo","getCurrentModelInfo","getCurrentModelContextLength","getModelContextLength","getAllModels","available","has","availableModels","getModelMaxCompletionTokens","getCurrentModelMaxCompletionTokens","logCurrentModelUsage","usedTokens","usagePercent","toFixed","used","total","percentage","remaining","logDetailedUsage","usage","push","getUsageHistory","ModelManager","constructor","modelInfo","debugLogger","currentModel","setCurrentModel","model","log","getCurrentModel","Phase","import_tsyringe","configService","container","resolve","ConfigService","config","getConfig","discoveryPhaseBlueprint","model","discoveryModel","generatePrompt","args","runAllTestsCmd","runOneTestCmd","runTypeCheckCmd","projectInfo","environmentDetails","import_tsyringe","configService","container","resolve","ConfigService","config","getConfig","executePhaseBlueprint","model","executeModel","generatePrompt","args","runAllTestsCmd","runOneTestCmd","runTypeCheckCmd","projectInfo","import_tsyringe","configService","container","resolve","ConfigService","config","getConfig","strategyPhaseBlueprint","model","strategyModel","generatePrompt","args","runAllTestsCmd","runOneTestCmd","runTypeCheckCmd","phaseBlueprints","Phase","Discovery","discoveryPhaseBlueprint","Strategy","strategyPhaseBlueprint","Execute","executePhaseBlueprint","PhaseManager","constructor","configService","modelManager","currentPhase","phaseConfigs","Phase","Discovery","Map","initializePhaseConfigs","config","getConfig","phaseBlueprints","model","discoveryModel","Strategy","strategyModel","Execute","executeModel","phaseData","get","Error","setCurrentModel","getCurrentPhase","getCurrentPhaseConfig","resetPhase","setPhase","phase","getPhaseConfig","nextPhase","BaseError","Error","constructor","message","name","Object","setPrototypeOf","prototype","MessageContextError","BaseError","constructor","message","import_tsyringe","import_tsyringe","MessageContextExtractor","extractNonOperationContent","content","replace","trim","extractOperations","operations","now","Date","readMatches","Array","from","matchAll","forEach","match","push","type","path","timestamp","writeMatches","commandMatches","command","extractPhasePrompt","MessageContextBuilder","constructor","extractor","buildMessageContext","role","content","currentPhase","contextData","validateRole","validateContent","validateContextData","MessageContextError","updatedPhaseInstructions","Map","phasePromptMatches","match","existingPhaseInstruction","Array","from","phaseInstructions","values","find","instruction","phase","validPrompts","filter","isValidPhasePrompt","map","extractPhasePromptContent","Boolean","length","lastValidPrompt","set","timestamp","Date","now","operations","extractOperations","updatedFileOperations","fileOperations","updatedCommandOperations","commandOperations","filteredHistory","conversationHistory","msg","msgContent","trim","withoutPhasePrompt","replace","includes","updatedConversationHistory","contentWithoutPhasePrompt","push","forEach","operation","type","existingOperation","get","command","success","path","error","message","updateOperationResult","identifier","result","output","getMessageContext","currentPhaseInstructions","sort","a","b","criticalOperations","op","status","errorInfo","successfulOperations","userAssistantMessages","systemInstructions","getLatestPhaseInstructions","instructions","getFileOperation","getCommandOperation","prompt","contentMatch","fs","path","import_tsyringe","import_tsyringe","import_tsyringe","MessageContextTokenCount","constructor","messageContextStore","estimateTokenCount","messages","reduce","total","message","encode","content","length","estimateTokenCountForMessage","estimateTokenCountForText","text","getTotalTokenCount","contextData","getContextData","systemInstructions","conversationHistory","getTokenCount","MessageContextStore","MessageContextStore","constructor","messageContextTokenCount","contextData","phaseInstructions","Map","fileOperations","commandOperations","conversationHistory","systemInstructions","getContextData","setContextData","data","getUpdatedPhaseInstructions","getUpdatedOperations","getUpdatedValue","clear","getTotalTokenCount","undefined","instructions","Array","from","values","sort","a","b","timestamp","slice","map","i","phase","newOperations","existingOperations","newValue","existingValue","MessageContextTokenCount","MessageContextLogger","constructor","debugLogger","configService","messageContextBuilder","messageContextStore","logDirectory","conversationLogPath","conversationHistoryPath","logLock","isLogging","getLogDirectory","join","process","cwd","Promise","resolve","ensureLogDirectoryExists","ensureHistoryFileExists","config","getConfig","acquireLogLock","setTimeout","releaseLogLock","logDir","dirname","existsSync","fs","mkdirSync","recursive","writeFileSync","log","path","error","cleanupLogFiles","logMessage","message","timestamp","Date","toISOString","logEntry","role","content","appendFileSync","logActionResult","action","result","status","success","details","contextData","getContextData","updatedContextData","updateOperationResult","setContextData","updateConversationHistory","messages","systemInstructions","historyData","JSON","stringify","messagesCount","length","hasSystemInstructions","getLogDirectoryPath","getConversationLogPath","getConversationHistoryPath","getConversationHistory","readFileSync","parse","MessageContextHistory","constructor","messageContextStore","messageContextLogger","phaseManager","messageContextBuilder","addMessage","role","content","log","isFirstMessage","includes","Error","trim","isLoggingEnabled","cleanupLogFiles","updatedData","buildMessageContext","getCurrentPhase","getContextData","setContextData","logMessage","getMessages","getMessageContext","clear","setSystemInstructions","instructions","systemInstructions","getSystemInstructions","updateLogFile","process","env","NODE_ENV","updateConversationHistory","cleanContent","replace","message","getConversationLogPath","import_tsyringe","import_tsyringe","ActionTagsExtractor","getParameterTags","paramSet","Set","blueprints","Object","values","actionsBlueprints","blueprint","parameters","forEach","param","add","name","Array","from","validateStructure","content","actionTags","keys","tag","openCount","match","RegExp","length","closeCount","parameterTags","extractTag","tagName","regex","matches","matchAll","trim","map","extractTags","extractTagLines","tagContent","isArray","split","line","filter","Boolean","extractNestedTags","parentTag","childTag","parentContent","extractAllTagsWithContent","import_tsyringe","import_tsyringe","ActionFactory","constructor","blueprintCache","Map","instanceCache","implementedActions","getImplementedActions","forEach","tag","blueprint","actionsBlueprints","set","getBlueprint","get","getAllBlueprints","Array","from","values","createAction","has","class","undefined","instance","container","resolve","error","console","validateParameters","params","parameters","param","required","name","validator","isValid","ActionExplainer","constructor","actionFactory","explainAction","actionTag","blueprint","getBlueprint","formatActionExplanation","explainAllActions","blueprints","getAllBlueprints","map","join","explanation","tag","description","parameters","length","formatParameters","usageExplanation","param","name","required","BaseAction","constructor","actionTagsExtractor","parseParams","content","blueprint","getBlueprint","paramNames","parameters","map","p","name","params","paramName","value","extractParamValue","extractTag","execute","createErrorResult","validationError","validateParams","logError","result","executeInternal","success","logSuccess","error","message","errorMessage","Error","String","console","tag","logInfo","log","createSuccessResult","data","errorObj","ActionExplainerAction","BaseAction","constructor","actionTagsExtractor","actionExplainer","getBlueprint","actionExplainerBlueprint","validateParams","params","action","parseParams","content","actionMatch","match","trim","executeInternal","explanation","explainAction","success","data","error","ActionPriority","actionExplainerBlueprint","tag","class","ActionExplainerAction","description","usageExplanation","priority","ActionPriority","HIGH","canRunInParallel","requiresProcessing","parameters","name","required","validator","value","length","import_tsyringe","_ts_decorate","AnsiStripper","strip","input","TypeError","replace","ansiRegex","import_chalk","import_tsyringe","CommandAction","BaseAction","constructor","actionTagsExtractor","debugLogger","ansiStripper","getBlueprint","blueprint","parseParams","content","tag","match","RegExp","logError","command","replace","trim","logInfo","validateParams","params","length","executeInternal","executeCommand","error","createSuccessResult","message","isTestEnvironment","process","env","NODE_ENV","JEST_WORKER_ID","undefined","options","Promise","resolve","cmd","args","split","child","spawn","shell","stdoutData","stderrData","isResolved","stdoutBuffer","stderrBuffer","stdout","on","data","chunk","toString","strippedChunk","strip","write","chalk","green","stderr","red","finalizeAndResolve","exitCode","extra","output","combinedOutput","log","code","commandActionBlueprint","tag","class","CommandAction","description","usageExplanation","priority","ActionPriority","LOW","canRunInParallel","requiresProcessing","parameters","import_path","import_tsyringe","FileSearch","constructor","debugLogger","findAllMatches","text","searchStr","positions","pos","indexOf","push","findByPattern","pattern","directory","entries","fg","cwd","dot","absolute","results","entry","content","fs","readFile","lines","split","path","matches","map","line","index","error","console","findByContent","searchContent","searchTarget","toLowerCase","stats","stat","isFile","i","length","lineToSearch","position","findByName","name","targetName","basename","targetDir","dirname","log","onlyFiles","fileEntries","fullPath","dir","searchName","exactMatches","filter","entryName","startsWith","sort","a","b","aExact","bExact","fuse","Fuse","includeScore","threshold","minMatchCharLength","Math","min","keys","weight","search","result","score","item","includes","slice","import_fast_glob","import_fs_extra","Fuse","import_path","import_tsyringe","PathAdjuster","constructor","allFiles","fuse","initialized","initializationError","baseDirectory","process","cwd","defaultFuzzyOptions","includeScore","threshold","default","initialize","catch","error","console","cleanup","isInitialized","getInitializationError","getAllFiles","setCollection","Error","String","dir","entries","fg","sync","absolute","onlyFiles","followSymbolicLinks","map","filePath","path","resolve","message","findClosestMatch","wrongPath","absoluteWrongPath","results","search","limit","length","bestMatch","score","undefined","item","validatePath","exists","fsExtra","pathExistsSync","stats","lstatSync","isFile","adjustPath","closestMatch","toRelativePath","absolutePath","isAbsolute","possiblePath","join","normalizedPath","startsWith","relative","refreshFilePaths","import_fs_extra","import_path","import_tsyringe","FileOperations","constructor","pathAdjuster","fileSearch","debugLogger","ensureInitialized","timeout","startTime","Date","now","isInitialized","Promise","resolve","reject","checkInit","Error","setTimeout","error","getInitializationError","getAdjustedPath","filePath","adjustedPath","adjustPath","isRead","fs","pathExists","similarFiles","findByName","path","basename","process","cwd","length","bestMatch","stats","stat","isFile","log","confidence","originalPath","read","success","content","readFile","data","readMultiple","filePaths","fileContents","errors","push","message","join","validateAndAdjustWritePath","absolutePath","isNewFile","projectRoot","startsWith","write","ensureDir","dirname","writeFile","delete","remove","copy","source","destination","adjustedSource","move","overwrite","exists","fileStats","size","createdAt","birthtime","modifiedAt","mtime","isDirectory","findSimilarFiles","import_tsyringe","CopyFileAction","BaseAction","constructor","actionTagsExtractor","fileOperations","getBlueprint","blueprint","validateParams","params","source_path","destination_path","execute","content","structureError","validateStructure","createErrorResult","executeInternal","logInfo","result","copy","success","error","createSuccessResult","data","copyFileActionBlueprint","tag","class","CopyFileAction","description","usageExplanation","priority","ActionPriority","MEDIUM","canRunInParallel","requiresProcessing","parameters","name","required","validator","value","length","import_tsyringe","DeleteFileAction","BaseAction","constructor","actionTagsExtractor","fileOperations","getBlueprint","blueprint","validateParams","params","path","trim","executeInternal","filePath","logInfo","result","delete","success","logError","error","createErrorResult","createSuccessResult","data","execute","content","JSON","parse","Error","validationError","deleteFileActionBlueprint","tag","class","DeleteFileAction","description","usageExplanation","priority","ActionPriority","MEDIUM","canRunInParallel","requiresProcessing","parameters","name","required","validator","value","length","import_tsyringe","import_tsyringe","import_tsyringe","MessageContextPhase","constructor","messageContextStore","messageContextHistory","cleanupPhaseContent","currentData","getContextData","setContextData","phaseInstructions","Map","fileOperations","commandOperations","conversationHistory","systemInstructions","updateLogFile","PhaseTransitionService","constructor","phaseManager","modelManager","messageContextPhase","messageContextHistory","transitionToNextPhase","currentPhase","getCurrentPhase","nextPhase","getNextPhase","cleanupPhaseContent","console","log","getPhaseEmoji","nextPhaseConfig","getCurrentPhaseConfig","setCurrentModel","model","generatePrompt","message","addMessage","regenerate","selectedModel","Phase","Discovery","Strategy","Execute","phase","EndPhaseAction","BaseAction","constructor","actionTagsExtractor","phaseTransitionService","executeInternal","params","data","transitionToNextPhase","createSuccessResult","error","createErrorResult","validateParams","getBlueprint","endPhaseActionBlueprint","endPhaseActionBlueprint","tag","class","EndPhaseAction","description","usageExplanation","parameters","requiresProcessing","priority","ActionPriority","CRITICAL","import_tsyringe","EndTaskAction","BaseAction","constructor","actionTagsExtractor","getBlueprint","blueprint","validateParams","params","content","trim","executeInternal","message","logInfo","createSuccessResult","parseParams","match","endTaskActionBlueprint","tag","class","EndTaskAction","description","usageExplanation","priority","ActionPriority","LOWEST","canRunInParallel","requiresProcessing","parameters","import_axios","import_tsyringe","FetchUrlAction","BaseAction","constructor","actionTagsExtractor","getBlueprint","blueprint","validateParams","params","url","URL","executeInternal","logInfo","data","fetchUrl","createSuccessResult","error","createErrorResult","Error","response","axios","get","isAxiosError","message","fetchUrlActionBlueprint","tag","class","FetchUrlAction","description","usageExplanation","priority","ActionPriority","LOW","canRunInParallel","requiresProcessing","parameters","name","required","validator","value","length","startsWith","import_tsyringe","GitService","constructor","git","simpleGit","getDiff","fromCommit","toCommit","excludePattern","args","push","split","diff","getStatus","status","getPRDiff","baseBranch","compareBranch","getFileHistory","filepath","logResult","log","JSON","stringify","getCurrentBranch","branch","current","import_tsyringe","GitDiffAction","BaseAction","constructor","actionTagsExtractor","gitService","configService","getBlueprint","blueprint","parseParams","content","tag","match","RegExp","Error","tagContent","fromCommit","extractTag","toCommit","getValue","value","Array","isArray","trim","validateParams","params","executeInternal","config","getConfig","excludeLockFiles","lockFiles","gitDiff","excludePattern","map","file","join","diff","getDiff","createSuccessResult","error","createErrorResult","gitDiffActionBlueprint","tag","class","GitDiffAction","description","usageExplanation","priority","ActionPriority","HIGH","canRunInParallel","requiresProcessing","parameters","name","required","validator","value","length","import_tsyringe","GitPRDiffAction","BaseAction","constructor","actionTagsExtractor","gitService","debugLogger","configService","getBlueprint","blueprint","parseParams","content","tag","match","RegExp","Error","tagContent","baseBranch","extractTag","compareBranch","getValue","value","Array","isArray","trim","validateParams","params","executeInternal","config","getConfig","excludeLockFiles","lockFiles","gitDiff","excludePattern","map","file","join","console","warn","diff","getPRDiff","createSuccessResult","error","createErrorResult","gitPRDiffActionBlueprint","tag","class","GitPRDiffAction","description","usageExplanation","priority","ActionPriority","HIGH","canRunInParallel","requiresProcessing","parameters","name","required","validator","value","length","import_tsyringe","MoveFileAction","BaseAction","constructor","actionTagsExtractor","fileOperations","getBlueprint","blueprint","parseParams","content","tag","match","RegExp","logError","source_path","destination_path","tagContent","extractTag","getValue","value","Array","isArray","trim","validateParams","params","executeInternal","logInfo","result","move","success","createErrorResult","error","createSuccessResult","data","moveFileActionBlueprint","tag","class","MoveFileAction","description","usageExplanation","priority","ActionPriority","MEDIUM","canRunInParallel","requiresProcessing","parameters","name","required","validator","value","length","import_tsyringe","ReadFileAction","BaseAction","constructor","actionTagsExtractor","fileOperations","debugLogger","getBlueprint","blueprint","validateParams","params","paths","path","Array","isArray","length","invalidPaths","filter","join","extractParamValue","content","paramName","regex","RegExp","matches","from","matchAll","map","match","trim","executeInternal","filePaths","handleSingleFile","handleMultipleFiles","filePath","result","read","convertFileResult","readMultiple","log","success","data","createErrorResult","error","logSuccess","console","repeat","createSuccessResult","logError","message","readFileActionBlueprint","tag","class","ReadFileAction","description","usageExplanation","priority","ActionPriority","CRITICAL","canRunInParallel","requiresProcessing","parameters","name","required","validator","value","length","import_path","import_tsyringe","RelativePathLookupAction","BaseAction","constructor","actionTagsExtractor","pathAdjuster","getBlueprint","blueprint","parseParams","content","tag","match","RegExp","logError","source_path","path","threshold","undefined","tagContent","extractTag","getValue","value","Array","isArray","trim","parseFloat","validateParams","params","executeInternal","relativePath","sourceDir","dirname","fullImportPath","resolve","adjustedPath","adjustPath","newRelativePath","relative","formattedPath","startsWith","result","originalPath","newPath","replace","absolutePath","logSuccess","createSuccessResult","logInfo","error","message","createErrorResult","relativePathLookupActionBlueprint","tag","class","RelativePathLookupAction","description","usageExplanation","priority","ActionPriority","HIGH","canRunInParallel","requiresProcessing","parameters","name","required","validator","value","length","import_tsyringe","SearchAction","BaseAction","constructor","actionTagsExtractor","fileSearch","currentType","execute","content","includes","getBlueprint","searchStringActionBlueprint","searchFileActionBlueprint","parseParams","tag","match","RegExp","logError","directory","term","tagContent","extractTag","getValue","value","Array","isArray","trim","validateParams","params","executeInternal","logInfo","results","findByContent","findByName","length","createSuccessResult","logSuccess","error","message","createErrorResult","searchStringActionBlueprint","tag","class","SearchAction","description","usageExplanation","priority","ActionPriority","HIGH","canRunInParallel","requiresProcessing","parameters","name","required","validator","value","length","searchFileActionBlueprint","BLOCK_WRITE_IF_CONTENT_REMOVAL_THRESHOLD","MODEL_SCALING_INITIAL_TRY_COUNT","import_tsyringe","ModelScaler","constructor","debugLogger","configService","modelManager","phaseManager","tryCountMap","globalTryCount","autoScalerEnabled","Map","config","getConfig","autoScaler","isAutoScalerEnabled","incrementTryCount","filePath","currentPhase","getCurrentPhase","Phase","Execute","incrementCounts","currentCount","get","MODEL_SCALING_INITIAL_TRY_COUNT","handleModelScaling","getTryCount","getGlobalTryCount","reset","clear","setCurrentModel","discoveryModel","set","getMaxTryCount","values","Array","from","length","Math","max","maxTries","newModel","getModelForTryCount","toString","log","fileCount","globalCount","phase","tryCount","globalTries","availableModels","autoScaleAvailableModels","id","tries","parseInt","i","previousTriesSum","slice","reduce","sum","model","maxWriteTries","maxGlobalTries","import_tsyringe","HtmlEntityDecoder","decode","text","options","result","unescapeChars","length","unescape","unescapeString","he","str","chars","replace","match","unicode","char","code","parseInt","String","fromCharCode","specialCharMap","n","t","r","b","f","includes","import_tsyringe","MAX_CONTENT_SIZE_MB","MAX_CONTENT_SIZE_BYTES","MAX_LINE_LENGTH","WriteFileAction","BaseAction","constructor","actionTagsExtractor","fileOperations","htmlEntityDecoder","modelScaler","logWarning","message","console","warn","logError","error","logInfo","info","getBlueprint","blueprint","validateParams","params","path","filePath","content","type","includes","contentSizeBytes","Buffer","byteLength","toFixed","Error","String","extractParamValue","paramName","contentMatch","match","substring","replace","value","executeInternal","fileContent","exists","similarFiles","findSimilarFiles","length","bestMatch","createErrorResult","removalCheck","checkLargeRemoval","success","decodedContent","decode","unescapeChars","isValidContent","result","write","createSuccessResult","newContent","incrementTryCount","readResult","read","existingContent","data","removalPercentage","calculateRemovalPercentage","BLOCK_WRITE_IF_CONTENT_REMOVAL_THRESHOLD","existingLength","trim","newLength","removedLength","Math","max","hasExcessiveLines","split","some","line","writeFileActionBlueprint","tag","class","WriteFileAction","description","usageExplanation","priority","ActionPriority","MEDIUM","canRunInParallel","requiresProcessing","parameters","name","required","validator","value","includes","length","actionsBlueprints","actionExplainerBlueprint","tag","commandActionBlueprint","copyFileActionBlueprint","deleteFileActionBlueprint","endPhaseActionBlueprint","endTaskActionBlueprint","fetchUrlActionBlueprint","gitDiffActionBlueprint","gitPRDiffActionBlueprint","moveFileActionBlueprint","readFileActionBlueprint","relativePathLookupActionBlueprint","searchFileActionBlueprint","searchStringActionBlueprint","writeFileActionBlueprint","getBlueprint","getActionTags","Object","keys","getImplementedActions","filter","blueprint","class","import_tsyringe","ActionQueue","queue","processedResults","Map","enqueue","type","content","blueprint","getBlueprint","priority","ActionPriority","LOW","requiresProcessing","push","sort","a","b","dequeue","length","undefined","nextAction","find","action","result","index","indexOf","splice","setActionResult","actionIndex","findIndex","success","set","data","getProcessedResults","isEmpty","size","clear","ActionExecutor","constructor","actionFactory","actionQueue","messageContextLogger","messageContextHistory","executeAction","actionText","implementedActions","getImplementedActions","actionMatch","matches","Array","from","matchAll","length","error","Error","logActionResult","success","addMessage","fullMatch","actionType","startIndex","indexOf","beforeText","substring","hasOpenTag","test","hasCloseTag","includes","enqueue","lastResult","isEmpty","action","dequeue","actionInstance","createAction","type","blueprint","getBlueprint","console","log","description","execute","content","data","JSON","stringify","errorMessage","message","setActionResult","clear","requiresProcessing","processedResults","getProcessedResults","finalProcessedResults","size","import_fs","import_path","import_tsyringe","ProjectInfo","constructor","gatherProjectInfo","projectRoot","files","fs","promises","readdir","withFileTypes","dependencyFiles","foundDependencyFile","find","depFile","some","dirent","isFile","name","mainDependencies","scripts","gatherNodeInfo","gatherPythonInfo","gatherRustInfo","gatherGoInfo","dependencyFile","packageJsonPath","path","join","content","readFile","packageJson","JSON","parse","Object","keys","dependencies","devDependencies","reqPath","split","map","line","trim","filter","startsWith","cargoPath","inDepsSection","forEach","includes","dep","push","build","run","test","modPath","trimmedLine","fs","import_tsyringe","import_tsyringe","MessageContextCleaner","constructor","debugLogger","modelInfo","messageContextStore","messageContextBuilder","messageContextHistory","messageContextTokenCount","cleanupContext","contextData","getContextData","maxTokens","getCurrentModelContextLength","messages","getMessageContext","currentTokens","estimateTokenCount","cleanedHistory","cleanedTokens","length","removedMessage","shift","estimateTokenCountForMessage","removedHistory","slice","updatedHistory","conversationHistory","setContextData","log","removedMessages","logCurrentModelUsage","getTotalTokenCount","LLMContextCreator","constructor","directoryScanner","actionExecutor","projectInfo","configService","phaseManager","messageContextCleaner","messageContextBuilder","messageContextStore","loadCustomInstructions","config","getConfig","customInstructionsPath","instructions","promises","readFile","trim","error","Error","customInstructions","create","message","root","isFirstMessage","baseContext","resetPhase","cleanupContext","environmentDetails","Promise","all","getEnvironmentDetails","getProjectInfo","formatFirstTimeMessage","currentPhase","getCurrentPhase","contextData","getContextData","phaseInstructions","Array","from","values","currentPhaseInstruction","find","instruction","phase","formatSequentialMessage","scanResult","scan","success","data","info","gatherProjectInfo","dependencyFile","runAllTestsCmd","runOneTestCmd","runTypeCheckCmd","projectSetup","projectLanguage","packageManager","referenceExamplesSection","Object","entries","referenceExamples","map","key","path","join","mainDependencies","scripts","name","command","formatInitialInstructions","context","envDetails","additionalInstructions","filter","Boolean","phaseConfig","getCurrentPhaseConfig","includeAllFilesOnEnvToContext","promptArgs","initialInstructions","generatePrompt","executeAction","actionContent","result","import_path","import_tsyringe","ActionsParser","constructor","debugLogger","contextCreator","htmlEntityDecoder","actionTagsExtractor","currentMessageBuffer","isProcessingAction","messageComplete","processedTags","currentModel","reset","isCompleteMessage","text","getActionsWithPathParam","getImplementedActions","filter","tag","blueprint","getBlueprint","parameters","some","param","name","extractFilePath","fileActions","actionMatch","RegExp","join","exec","pathMatch","match","path","resolve","process","cwd","extractUrl","urlMatch","extractContentFromAction","actionContent","contentMatch","includes","detectActionDependencies","actions","map","action","dependsOn","type","readActions","a","readContent","content","writeContent","push","actionId","writeActions","writePath","actionPath","createExecutionPlan","groups","unprocessedActions","canRunInParallel","length","currentGroup","remainingActions","forEach","canExecute","every","depId","find","ua","parallelActions","sequentialActions","parallel","findCompleteTags","combinedText","validationError","validateStructure","log","error","actionTags","allTagsRegex","matches","Array","from","matchAll","uuidv4","actionsWithDependencies","appendToBuffer","chunk","clearBuffer","buffer","isProcessing","value","isComplete","formatActionResult","result","_","actionType","success","data","output","decode","JSON","stringify","unescape","regenerate","prompt","parseAndExecuteActions","model","llmCallback","executionPlan","results","selectedModel","hasError","group","actionPromises","executeAction","then","groupResults","Promise","all","writeData","endTaskAction","message","actionResults","followupResponse","response","console","import_tsyringe","MessageContextLimiter","constructor","messageContextCleanup","messageContextStore","messageContextLogger","cleanupContext","wasCleaned","updateLogFile","process","env","NODE_ENV","isLoggingEnabled","updateConversationHistory","getContextData","conversationHistory","systemInstructions","getConversationLogPath","ANTHROPIC_MODEL_REGEX","MAX_CHUNK_SIZE","MAX_CACHE_BLOCKS","MIN_CACHE_TOKENS","opus","sonnet","haiku","isAnthropicModel","model","test","getModelType","match","estimateTokens","text","codeBlockMatches","codeTokens","regularContent","codeBlock","codeContent","slice","Math","ceil","length","replace","regularTokens","shouldApplyCache","content","modelType","messageIndex","minTokens","splitContentIntoChunks","chunks","remaining","chunkSize","naturalBreak","lastIndexOf","chunk","push","formatMessageContent","totalMessages","shouldCache","type","cache_control","chunksWithTokens","map","idx","tokens","index","sort","a","b","remainingBlocks","chunksToCacheIndices","Set","c","has","import_tsyringe","import_tsyringe","OpenRouterAPICostTracking","constructor","calculateCosts","priceAll","usage","promptRate","parseFloat","prompt","completionRate","completion","currentCost","totalCost","modelKey","modelUsage","length","modelTotalCost","reduce","sum","entry","cost","prompt_tokens","completion_tokens","lastUsage","logChatCosts","console","log","toFixed","_ts_decorate","LLMError","Error","constructor","message","type","details","name","OpenRouterAPI","htmlEntityDecoder","modelManager","modelInfo","debugLogger","modelScaler","costTracker","messageContextHistory","messageContextLimiter","messageContextTokenCount","httpClient","streamBuffer","maxRetries","retryDelay","stream","aborted","openRouterClient","initializeModelInfo","initialize","error","log","getAnthropicHeaders","model","isAnthropicModel","makeRequest","endpoint","data","options","headers","post","handleLLMError","response","includes","getCurrentModel","contextLimit","getModelContextLength","maxLength","currentLength","getTotalTokenCount","originalError","formatMessages","messages","filteredMessages","filter","msg","content","trim","length","map","index","role","formatMessageContent","sendMessage","getConversationContext","currentModel","setCurrentModel","formattedMessages","assistantMessage","choices","addMessage","priceAll","getCurrentModelInfo","pricing","usage","getUsageHistory","logChatCosts","sendMessageWithContext","systemInstructions","addSystemInstructions","clearConversationContext","clear","getMessages","instructions","setSystemInstructions","logCurrentModelUsage","getAvailableModels","getAllModels","validateModel","isModelAvailable","getModelInfo","info","handleStreamError","callback","wasContextCleaned","cleanupContext","streamMessage","retryStreamOperation","operation","retries","isRetryableError","Promise","resolve","setTimeout","err","code","processCompleteMessage","jsonStr","replace","startsWith","parsed","JSON","parse","logDetailedUsage","deltaContent","delta","decodedContent","decode","e","parseStreamChunk","chunk","split","pop","result","streamOperation","responseType","timeout","reject","handleError","on","cleanupStream","toString","llmError","removeAllListeners","destroy","cancelStream","import_tsyringe","LLMProviderType","LLMProvider","constructor","providers","currentProvider","Map","initializeProvider","type","provider","container","resolve","OpenRouterAPI","Error","set","getInstance","getProvider","get","sendMessage","model","message","options","sendMessageWithContext","systemInstructions","clearConversationContext","getConversationContext","addSystemInstructions","instructions","getAvailableModels","validateModel","getModelInfo","streamMessage","callback","import_tsyringe","MAX_BUFFER_SIZE","CHUNK_SIZE","STREAM_TIMEOUT","StreamHandler","constructor","debugLogger","actionsParser","responseBuffer","isStreamComplete","lastActivityTimestamp","bufferSize","inactivityTimer","Date","now","reset","clearInactivityTimer","response","formatErrorDisplay","error","title","details","type","maxLength","currentLength","suggestion","retryAfter","modelId","message","required","available","displayError","safeWriteToStdout","log","text","process","stdout","write","console","safeClearLine","clearLine","safeCursorTo","x","cursorTo","processChunk","chunk","chunks","remainingChunk","length","chunkToProcess","slice","push","handleBufferOverflow","keepSize","clearBuffer","appendToBuffer","maxSize","currentSize","startInactivityTimer","setTimeout","LLMError","timeout","clearTimeout","handleChunk","model","llmCallback","streamCallback","options","startsWith","JSON","parse","llmError","e","originalError","subChunk","isMessageComplete","isCompleteMessage","buffer","isComplete","isProcessing","actionResult","parseAndExecuteActions","actionResponse","actions","import_tsyringe","CrackedAgent","constructor","fileReader","contextCreator","debugLogger","actionsParser","streamHandler","phaseManager","modelManager","llm","isFirstInteraction","currentModel","execute","message","options","initializePhaseConfigs","finalOptions","setupExecution","getCurrentModel","formattedMessage","create","root","log","conversationHistory","getConversationContext","stream","handleStreamExecution","result","handleNormalExecution","process","cwd","provider","LLMProviderType","OpenRouter","debug","clearContext","autoScaler","setDebug","LLMProvider","getInstance","reset","clearConversationHistory","validateModel","setupInstructions","model","isValidModel","availableModels","getAvailableModels","Error","join","instructions","instructionsPath","readInstructionsFile","addSystemInstructions","DEFAULT_INSTRUCTIONS","response","streamMessage","chunk","appendToBuffer","stdout","write","actions","followupResponse","parseAndExecuteWithCallback","buffer","sendMessage","parseAndExecuteActions","followupMsg","formattedFollowup","followupResult","getConversationHistory","clearConversationContext","import_tsyringe","import_tsyringe","InteractiveSessionManager","constructor","openRouterAPI","currentMessage","keypressHandler","lineHandler","closeHandler","rl","agent","options","initialize","setupKeypressHandling","process","stdin","ReadStream","setRawMode","resume","buffer","key","toString","cancelStream","console","log","restartSession","on","prompt","handleInput","input","toLowerCase","cleanup","exit","result","execute","stream","response","actions","length","forEach","action","JSON","stringify","error","message","start","removeListener","close","import_tsyringe","Run","Command","constructor","argv","config","configService","modelManager","streamHandler","openRouterAPI","sessionManager","rl","container","resolve","ConfigService","ModelManager","StreamHandler","OpenRouterAPI","InteractiveSessionManager","createInterface","input","process","stdin","output","stdout","prompt","parseOptions","optionsString","options","pairs","split","pair","key","value","trim","isNaN","Number","includes","parseFloat","parseInt","run","args","flags","parse","init","createDefaultConfig","getConfig","openRouterApiKey","error","isInteractive","interactive","message","discoveryModel","Error","provider","Object","values","LLMProviderType","setCurrentModel","console","log","getCurrentModel","agent","CrackedAgent","initialize","start","once","result","execute","stream","response","actions","length","forEach","action","JSON","stringify","cleanup","exit","description","examples","Flags","boolean","exclusive","Args","string","required","crackedAgent","container","resolve","CrackedAgent"]}